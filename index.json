[{"categories":null,"contents":"Xin chào! Tôi là Tiết Thanh Minh Hiếu 👋 Câu chuyện của tôi Tôi là một sinh viên đang theo đuổi ước mơ trở thành chuyên viên An Ninh Mạng, với niềm đam mê bảo vệ thế giới số khỏi những mối đe dọa ngày càng phức tạp. Nhưng điều đặc biệt là tôi không chỉ muốn \u0026ldquo;làm\u0026rdquo; mà còn muốn \u0026ldquo;truyền cảm hứng\u0026rdquo; - mục tiêu của tôi là trở thành một giảng viên Security, người có thể biến những kiến thức phức tạp thành những bài học dễ hiểu và thú vị.\nTại sao tôi tạo blog này? Ban đầu, blog này được tạo ra để hoàn thành yêu cầu môn học về Java \u0026amp; JavaScript. Nhưng tôi nhận ra đây chính là cơ hội tuyệt vời để bắt đầu hành trình chia sẻ kiến thức mà tôi đã ấp ủ từ lâu.\nTôi tin rằng: Cách học tốt nhất là dạy lại cho người khác. Mỗi bài viết tôi chia sẻ không chỉ giúp các bạn đọc mà còn giúp tôi củng cố và mở rộng kiến thức của chính mình.\nNhững gì tôi đang làm 🔍 An Ninh Mạng Hiện tại tôi đang xây dựng nền tảng vững chắc với các chứng chỉ từ Google Cybersecurity và IBM. Kiến thức mạng cơ bản đã giúp tôi hiểu được \u0026ldquo;bức tranh lớn\u0026rdquo; của bảo mật.\n🤖 AI \u0026amp; Machine Learning Tôi có kinh nghiệm training model, đặc biệt là BERT. Dự án gần nhất của tôi là \u0026ldquo;Phát hiện mã độc Android bằng Transformer Networks (BERT)\u0026rdquo; - một project thú vị kết hợp giữa AI và Cybersecurity.\n💻 Lập trình Java và JavaScript là những ngôn ngữ tôi đang tập trung, nhưng hành trình coding của tôi không dừng lại ở đó!\nĐiều gì khiến blog này khác biệt? Không chỉ là lý thuyết khô khan. Tôi sẽ chia sẻ:\n✨ Kinh nghiệm thực tế từ các project đã làm 🎯 Cách tiếp cận thực tế thay vì chỉ đọc sách vở 🔧 Tips \u0026amp; tricks mà tôi học được qua quá trình \u0026ldquo;vấp ngã\u0026rdquo; 📚 Kiến thức được \u0026ldquo;dịch\u0026rdquo; sang ngôn ngữ dễ hiểu Mục tiêu của tôi là biến những khái niệm phức tạp thành những câu chuyện thú vị mà bất kỳ ai cũng có thể hiểu được.\nTầm nhìn tương lai Tôi mơ ước một ngày nào đó sẽ đứng trên bục giảng, truyền cảm hứng cho thế hệ các chuyên gia bảo mật tương lai. Blog này chính là bước đầu tiên trong hành trình rèn luyện kỹ năng truyền đạt của tôi.\nMỗi bài viết là một bài giảng nhỏ, mỗi chia sẻ là một lần thực hành để tôi có thể diễn đạt tốt hơn, rõ ràng hơn.\nLời kết Nếu bạn là người:\n🎓 Đang học về Cybersecurity, Java, JavaScript hoặc AI 🔍 Muốn hiểu cách áp dụng kiến thức vào thực tế 💡 Thích học thông qua kinh nghiệm thực tế hơn là lý thuyết suông Thì blog này dành cho bạn! Tôi hy vọng những chia sẻ của mình sẽ giúp ích cho hành trình học tập của các bạn, đồng thời cũng giúp tôi trở thành một người truyền đạt giỏi hơn.\nHãy cùng học, cùng phát triển và cùng tạo nên một cộng đồng tech Việt Nam mạnh mẽ! 🚀\n\u0026ldquo;The best way to learn is to teach others\u0026rdquo; - và đó chính là triết lý tôi theo đuổi trong mỗi bài viết.\n","permalink":"http://localhost:1313/about/","tags":null,"title":"Giới thiệu"},{"categories":null,"contents":"Trong lập trình mạng bằng Java, Socket là công cụ giúp kết nối giữa client và server.\nBằng cách sử dụng java.net.Socket và java.net.ServerSocket, ta có thể xây dựng các ứng dụng chat, truyền file hoặc HTTP server đơn giản.\nMô hình Client-Server cơ bản trong lập trình Socket Ở mức thấp hơn, kết nối TCP được thiết lập qua quá trình bắt tay 3 bước (TCP Handshake).\nĐiều này đảm bảo client và server đồng bộ trạng thái trước khi truyền dữ liệu.\nCơ chế bắt tay 3 bước TCP (Three-Way Handshake) ","permalink":"http://localhost:1313/blog/java-socket/","tags":["Java","Networking"],"title":"Kết nối Socket trong Java"},{"categories":["Programming"],"contents":"Chào các bạn! Hôm nay mình muốn chia sẻ về hành trình học lập trình của mình, từ Java đến JavaScript. Có lẽ nhiều bạn cũng đang băn khoăn giống mình: nên bắt đầu với ngôn ngữ nào? Học Java trước hay JavaScript trước?\nKhởi đầu với Java - Nền tảng vững chắc Mình bắt đầu với Java từ năm nhất đại học. Thật sự lúc đầu khá choáng với cú pháp dài dòng của Java:\npublic class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Hello, World!\u0026#34;); } } So với \u0026ldquo;Hello World\u0026rdquo; của JavaScript:\nconsole.log(\u0026#34;Hello, World!\u0026#34;); Wow, khác biệt quá phải không? Nhưng qua thời gian, mình nhận ra Java đã dạy mình những điều quan trọng:\n1. Tư duy hướng đối tượng (OOP) Java buộc mình phải hiểu về Class, Object, Inheritance\u0026hellip; Lúc đầu khó hiểu lắm, nhưng sau này khi làm dự án lớn mới thấy tầm quan trọng của nó.\n2. Tính nghiêm ngặt về kiểu dữ liệu int number = 10; // Phải khai báo kiểu rõ ràng String text = \u0026#34;Hello\u0026#34;; // Không thể gán số vào String 3. Cấu trúc dự án rõ ràng Package, import, access modifier\u0026hellip; tất cả đều có quy tắc rõ ràng.\nChuyển sang JavaScript - Tự do nhưng cần kỷ luật Khi bắt đầu học JavaScript, mình cảm thấy như được \u0026ldquo;giải phóng\u0026rdquo;:\nlet data = 10; // Kiểu number data = \u0026#34;Hello\u0026#34;; // Giờ thành string data = [1, 2, 3]; // Giờ thành array data = { name: \u0026#34;John\u0026#34; }; // Giờ thành object Tự do quá! Nhưng cũng dễ rối loạn không kém.\nNhững khác biệt chính mình nhận ra: Java:\nCompiled language (biên dịch trước) Strongly typed (kiểu dữ liệu nghiêm ngặt) Platform independent (chạy trên JVM) Chủ yếu cho backend JavaScript:\nInterpreted language (thông dịch) Dynamically typed (kiểu dữ liệu linh hoạt) Chạy trên browser/Node.js Full-stack (cả frontend và backend) Bài học rút ra 1. Java là nền tảng tốt để bắt đầu Nếu bạn chưa biết gì về lập trình, mình khuyên nên bắt đầu với Java. Tại sao?\nBuộc bạn phải viết code chuẩn Hiểu rõ về cấu trúc dữ liệu Tư duy logic tốt hơn 2. JavaScript cần kỷ luật bản thân Vì quá linh hoạt, JavaScript dễ làm cho code trở nên lộn xộn. Mình học được:\nĐặt tên biến có ý nghĩa Sử dụng const/let thay vì var Comment code đầy đủ 3. Cả hai đều có giá trị Java: Tốt cho hệ thống lớn, enterprise applications JavaScript: Linh hoạt, phát triển nhanh, cộng đồng active Lời kết Hành trình từ Java đến JavaScript đã dạy mình rằng không có ngôn ngữ nào là \u0026ldquo;tốt nhất\u0026rdquo;. Mỗi ngôn ngữ đều có ưu nhược điểm riêng. Quan trọng là hiểu rõ bản chất và áp dụng đúng context.\nCác bạn có kinh nghiệm gì thú vị khi học hai ngôn ngữ này không? Hãy chia sẻ trong comment nhé!\nHappy coding! 🚀\n","permalink":"http://localhost:1313/blog/java-to-javascript/","tags":["java","javascript","kinh-nghiem","hoc-tap"],"title":"Từ Java đến JavaScript: Hành trình học lập trình của mình"},{"categories":["Java"],"contents":"Xin chào các bạn! Hôm nay mình muốn chia sẻ về những sai lầm \u0026ldquo;kinh điển\u0026rdquo; mà hầu như ai học Java cũng mắc phải, bao gồm cả mình. Hy vọng qua bài viết này, các bạn newbie sẽ tránh được những \u0026ldquo;hố đen\u0026rdquo; mà mình đã rơi vào.\nSai lầm #1: Lạm dụng public static void main Mình từng làm thế này: public class Calculator { public static void main(String[] args) { // Viết tất cả logic trong main int a = 10, b = 5; int sum = a + b; int diff = a - b; int product = a * b; int quotient = a / b; System.out.println(\u0026#34;Sum: \u0026#34; + sum); System.out.println(\u0026#34;Difference: \u0026#34; + diff); // ... và còn 50 dòng code nữa } } Vấn đề: Code không thể tái sử dụng Khó debug và maintain Không theo nguyên tắc OOP Cách khắc phục: public class Calculator { public int add(int a, int b) { return a + b; } public int subtract(int a, int b) { return a - b; } public static void main(String[] args) { Calculator calc = new Calculator(); System.out.println(\u0026#34;Sum: \u0026#34; + calc.add(10, 5)); System.out.println(\u0026#34;Difference: \u0026#34; + calc.subtract(10, 5)); } } Sai lầm #2: Không hiểu về Reference vs Value Mình từng nghĩ: public class Student { String name; public static void main(String[] args) { Student s1 = new Student(); s1.name = \u0026#34;Nam\u0026#34;; Student s2 = s1; // Mình tưởng s2 là bản copy của s1 s2.name = \u0026#34;Linh\u0026#34;; System.out.println(s1.name); // Tại sao lại in ra \u0026#34;Linh\u0026#34;??? } } Bài học: Trong Java, object được truyền theo reference, không phải value. Khi gán s2 = s1, cả hai đều trỏ đến cùng một object trong memory.\nGiải pháp: public class Student implements Cloneable { String name; public Student(String name) { this.name = name; } // Constructor copy public Student(Student other) { this.name = other.name; } public static void main(String[] args) { Student s1 = new Student(\u0026#34;Nam\u0026#34;); Student s2 = new Student(s1); // Tạo object mới s2.name = \u0026#34;Linh\u0026#34;; System.out.println(s1.name); // \u0026#34;Nam\u0026#34; System.out.println(s2.name); // \u0026#34;Linh\u0026#34; } } Sai lầm #3: Không xử lý Exception đúng cách Code \u0026ldquo;tệ\u0026rdquo; của mình: public void readFile(String fileName) { try { FileReader file = new FileReader(fileName); BufferedReader reader = new BufferedReader(file); String line = reader.readLine(); System.out.println(line); } catch (Exception e) { // Im lặng, không làm gì cả - RỐT THẬM TỆ! } } Vấn đề: \u0026ldquo;Nuốt\u0026rdquo; exception mà không xử lý Sử dụng Exception quá general Không đóng resource Cách đúng: public void readFile(String fileName) { try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) { String line = reader.readLine(); if (line != null) { System.out.println(line); } } catch (FileNotFoundException e) { System.err.println(\u0026#34;Không tìm thấy file: \u0026#34; + fileName); // Log hoặc throw lại exception } catch (IOException e) { System.err.println(\u0026#34;Lỗi đọc file: \u0026#34; + e.getMessage()); } } Sai lầm #4: So sánh String bằng == Code sai: public class StringComparison { public static void main(String[] args) { String s1 = \u0026#34;Hello\u0026#34;; String s2 = new String(\u0026#34;Hello\u0026#34;); if (s1 == s2) { // SAAAIIII! System.out.println(\u0026#34;Equal\u0026#34;); } else { System.out.println(\u0026#34;Not equal\u0026#34;); // Sẽ in ra này } } } Giải thích: == so sánh reference, không phải content s1 trỏ đến String Pool s2 trỏ đến object mới trong heap Cách đúng: public class StringComparison { public static void main(String[] args) { String s1 = \u0026#34;Hello\u0026#34;; String s2 = new String(\u0026#34;Hello\u0026#34;); if (s1.equals(s2)) { // So sánh content System.out.println(\u0026#34;Equal\u0026#34;); } // Hoặc an toàn hơn với null check if (Objects.equals(s1, s2)) { System.out.println(\u0026#34;Equal and null-safe\u0026#34;); } } } Sai lầm #5: Không hiểu về Access Modifier Code của mình lúc trước: public class BankAccount { public double balance; // Ai cũng có thể truy cập! public BankAccount(double initialBalance) { balance = initialBalance; } } // Ở nơi khác BankAccount account = new BankAccount(1000); account.balance = -500; // Oops! Balance âm??? Vấn đề: Dữ liệu quan trọng không được bảo vệ Vi phạm nguyên tắc Encapsulation Cách khắc phục: public class BankAccount { private double balance; // Chỉ class này truy cập được public BankAccount(double initialBalance) { if (initialBalance \u0026gt;= 0) { this.balance = initialBalance; } else { throw new IllegalArgumentException(\u0026#34;Balance không thể âm\u0026#34;); } } public double getBalance() { return balance; } public void deposit(double amount) { if (amount \u0026gt; 0) { balance += amount; } } public boolean withdraw(double amount) { if (amount \u0026gt; 0 \u0026amp;\u0026amp; amount \u0026lt;= balance) { balance -= amount; return true; } return false; } } Tổng kết Những sai lầm này đã giúp mình hiểu sâu hơn về Java. Đừng sợ mắc lỗi, quan trọng là học hỏi từ chúng!\nTips để tránh sai lầm: Practice coding every day - Luyện tập thường xuyên Read other people\u0026rsquo;s code - Đọc code của người khác Use IDE effectively - Tận dụng IDE để catch lỗi sớm Code review - Nhờ bạn bè review code Read documentation - Đọc docs chính thức của Java Các bạn đã mắc phải sai lầm nào trong danh sách này chưa? Hoặc có sai lầm nào khác muốn chia sẻ? Comment bên dưới nhé!\nKeep learning, keep coding! ☕\n","permalink":"http://localhost:1313/blog/5-wrong-errors/","tags":["java","sai-lam","kinh-nghiem","hoc-tap"],"title":"5 Sai lầm phổ biến khi học Java mà mình đã mắc phải"},{"categories":["JavaScript"],"contents":"Chào mọi người! Khi mới học JavaScript, mình chỉ biết đến cú pháp cũ ES5. Nhưng khi tiếp xúc với ES6+ (ES2015 trở lên), thật sự mình cảm thấy như được \u0026ldquo;khai sáng\u0026rdquo;. Hôm nay mình muốn chia sẻ những tính năng ES6+ đã thay đổi hoàn toàn cách mình viết JavaScript.\n1. Let \u0026amp; Const - Tạm biệt var nhé! Cách cũ với var: // Vấn đề với var function oldWay() { for (var i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; { console.log(i); // In ra 3, 3, 3 (WTF???) }, 100); } console.log(i); // 3 - i vẫn tồn tại ngoài loop! } Cách mới với let \u0026amp; const: function newWay() { for (let i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; { console.log(i); // In ra 0, 1, 2 (chính xác!) }, 100); } // console.log(i); // ReferenceError - i không tồn tại ở đây const API_URL = \u0026#34;https://api.example.com\u0026#34;; // API_URL = \u0026#39;other-url\u0026#39;; // TypeError - không thể reassign const } Bài học: Luôn dùng const cho giá trị không thay đổi, let cho biến có thể thay đổi. Quên var đi!\n2. Arrow Functions - Code ngắn gọn hơn ES5 way: // Function expression cũ var users = [\u0026#34;Nam\u0026#34;, \u0026#34;Linh\u0026#34;, \u0026#34;Hoa\u0026#34;]; var uppercaseUsers = users.map(function (user) { return user.toUpperCase(); }); var button = document.getElementById(\u0026#34;btn\u0026#34;); button.addEventListener(\u0026#34;click\u0026#34;, function () { console.log(this); // \u0026#39;this\u0026#39; trỏ đến button }); ES6 way: // Arrow function - clean và concise const users = [\u0026#34;Nam\u0026#34;, \u0026#34;Linh\u0026#34;, \u0026#34;Hoa\u0026#34;]; const uppercaseUsers = users.map((user) =\u0026gt; user.toUpperCase()); // Với multiple parameters const add = (a, b) =\u0026gt; a + b; // Với function body const processUser = (user) =\u0026gt; { const processed = user.trim().toUpperCase(); return `Hello, ${processed}!`; }; // Lưu ý về \u0026#39;this\u0026#39; binding const obj = { name: \u0026#34;MyObject\u0026#34;, regularFunction() { console.log(this.name); // \u0026#39;MyObject\u0026#39; const arrowFunction = () =\u0026gt; { console.log(this.name); // \u0026#39;MyObject\u0026#39; - inherit từ parent scope }; arrowFunction(); }, }; Tip: Arrow function không có this binding riêng, nó inherit từ parent scope.\n3. Template Literals - Goodbye string concatenation! Cách cũ: var name = \u0026#34;Nam\u0026#34;; var age = 20; var city = \u0026#34;Ho Chi Minh\u0026#34;; var introduction = \u0026#34;Xin chào, tôi là \u0026#34; + name + \u0026#34;, \u0026#34; + age + \u0026#34; tuổi, \u0026#34; + \u0026#34;đến từ \u0026#34; + city + \u0026#34;.\u0026#34;; var htmlTemplate = \u0026#39;\u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt;\u0026#39; + \u0026#34;\u0026lt;h2\u0026gt;\u0026#34; + name + \u0026#34;\u0026lt;/h2\u0026gt;\u0026#34; + \u0026#34;\u0026lt;p\u0026gt;Age: \u0026#34; + age + \u0026#34;\u0026lt;/p\u0026gt;\u0026#34; + \u0026#34;\u0026lt;/div\u0026gt;\u0026#34;; Cách mới: const name = \u0026#34;Nam\u0026#34;; const age = 20; const city = \u0026#34;Ho Chi Minh\u0026#34;; // Template literals với backticks const introduction = `Xin chào, tôi là ${name}, ${age} tuổi, đến từ ${city}.`; // Multi-line strings dễ dàng const htmlTemplate = ` \u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;${name}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Age: ${age}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Status: ${age \u0026gt;= 18 ? \u0026#34;Adult\u0026#34; : \u0026#34;Minor\u0026#34;}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `; // Tagged template literals (advanced) function highlight(strings, ...values) { return strings.reduce((result, string, i) =\u0026gt; { const value = values[i] ? `\u0026lt;mark\u0026gt;${values[i]}\u0026lt;/mark\u0026gt;` : \u0026#34;\u0026#34;; return result + string + value; }, \u0026#34;\u0026#34;); } const highlighted = highlight`Tôi tên là ${name} và ${age} tuổi.`; 4. Destructuring - Unpack dữ liệu như ninja Array Destructuring: // Cách cũ var numbers = [1, 2, 3, 4, 5]; var first = numbers[0]; var second = numbers[1]; var rest = numbers.slice(2); // Cách mới const [first, second, ...rest] = [1, 2, 3, 4, 5]; console.log(first); // 1 console.log(second); // 2 console.log(rest); // [3, 4, 5] // Skip elements const [a, , c] = [1, 2, 3]; console.log(a, c); // 1, 3 // Default values const [x = 0, y = 0] = [1]; // x = 1, y = 0 Object Destructuring: // Cách cũ var user = { name: \u0026#34;Nam\u0026#34;, age: 20, email: \u0026#34;nam@example.com\u0026#34;, address: { city: \u0026#34;Ho Chi Minh\u0026#34;, district: \u0026#34;District 1\u0026#34;, }, }; var name = user.name; var age = user.age; var email = user.email; // Cách mới const { name, age, email } = user; // Rename variables const { name: userName, age: userAge } = user; // Nested destructuring const { address: { city, district }, } = user; // Default values const { phone = \u0026#34;N/A\u0026#34; } = user; // Function parameters destructuring function greetUser({ name, age = \u0026#34;unknown\u0026#34; }) { return `Hello ${name}, you are ${age} years old`; } greetUser({ name: \u0026#34;Nam\u0026#34;, age: 20 }); 5. Spread \u0026amp; Rest Operators - Ba chấm ma thuật Spread Operator (\u0026hellip;): // Array spreading const arr1 = [1, 2, 3]; const arr2 = [4, 5, 6]; const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6] // Object spreading const user = { name: \u0026#34;Nam\u0026#34;, age: 20 }; const updatedUser = { ...user, age: 21, city: \u0026#34;HCM\u0026#34; }; // { name: \u0026#39;Nam\u0026#39;, age: 21, city: \u0026#39;HCM\u0026#39; } // Function arguments function sum(a, b, c) { return a + b + c; } const numbers = [1, 2, 3]; console.log(sum(...numbers)); // 6 Rest Operator (\u0026hellip;): // Function parameters function logAll(first, ...others) { console.log(\u0026#34;First:\u0026#34;, first); console.log(\u0026#34;Others:\u0026#34;, others); } logAll(1, 2, 3, 4, 5); // First: 1, Others: [2, 3, 4, 5] // Array destructuring (đã thấy ở trên) const [head, ...tail] = [1, 2, 3, 4, 5]; 6. Enhanced Object Literals const name = \u0026#34;Nam\u0026#34;; const age = 20; // Cách cũ var user = { name: name, age: age, greet: function () { return \u0026#34;Hello!\u0026#34;; }, }; // Cách mới - shorthand properties const user = { name, // tương đương name: name age, // tương đương age: age // Method shorthand greet() { return \u0026#34;Hello!\u0026#34;; }, // Computed property names [`full${name}`]: `${name} Nguyen`, // Dynamic property [getPropertyName()]: \u0026#34;dynamic value\u0026#34;, }; 7. Promises \u0026amp; Async/Await - Tạm biệt Callback Hell Callback Hell: // Cách cũ - callback hell fetchUser(userId, function (user) { fetchUserPosts(user.id, function (posts) { fetchPostComments(posts[0].id, function (comments) { // Nested callbacks - khó đọc và maintain console.log(comments); }); }); }); Promises: // Promise chain fetchUser(userId) .then((user) =\u0026gt; fetchUserPosts(user.id)) .then((posts) =\u0026gt; fetchPostComments(posts[0].id)) .then((comments) =\u0026gt; console.log(comments)) .catch((error) =\u0026gt; console.error(error)); Async/Await: // Async/await - code như synchronous async function getUserData(userId) { try { const user = await fetchUser(userId); const posts = await fetchUserPosts(user.id); const comments = await fetchPostComments(posts[0].id); return comments; } catch (error) { console.error(\u0026#34;Error:\u0026#34;, error); throw error; } } // Sử dụng getUserData(123).then((data) =\u0026gt; console.log(data)); Kết luận ES6+ đã thực sự thay đổi cách mình viết JavaScript:\nCode ngắn gọn và dễ đọc hơn Ít bugs hơn nhờ let/const Xử lý async code dễ dàng hơn Destructuring giúp unpack data elegantly Tips cho người mới: Học từ từ - Đừng cố gắng học tất cả một lúc Practice daily - Viết code ES6+ mỗi ngày Use Babel - Để support browser cũ Read MDN docs - Tài liệu chính thức luôn tốt nhất Các bạn đã dùng feature nào trong số này chưa? Feature nào khiến các bạn ấn tượng nhất? Share ở comment nhé!\nModern JavaScript is beautiful! 🚀✨\n","permalink":"http://localhost:1313/blog/javascript-es6+/","tags":["javascript","es6","modern-js","kinh-nghiem"],"title":"JavaScript ES6+: Những tính năng đã thay đổi cách mình code"},{"categories":null,"contents":"Xin chào! Tôi là Tiết Thanh Minh Hiếu 👋 Câu chuyện của tôi Tôi là một sinh viên đang theo đuổi ước mơ trở thành chuyên viên An Ninh Mạng, với niềm đam mê bảo vệ thế giới số khỏi những mối đe dọa ngày càng phức tạp. Nhưng điều đặc biệt là tôi không chỉ muốn \u0026ldquo;làm\u0026rdquo; mà còn muốn \u0026ldquo;truyền cảm hứng\u0026rdquo; - mục tiêu của tôi là trở thành một giảng viên Security, người có thể biến những kiến thức phức tạp thành những bài học dễ hiểu và thú vị.\nTại sao tôi tạo blog này? Ban đầu, blog này được tạo ra để hoàn thành yêu cầu môn học về Java \u0026amp; JavaScript. Nhưng tôi nhận ra đây chính là cơ hội tuyệt vời để bắt đầu hành trình chia sẻ kiến thức mà tôi đã ấp ủ từ lâu.\nTôi tin rằng: Cách học tốt nhất là dạy lại cho người khác. Mỗi bài viết tôi chia sẻ không chỉ giúp các bạn đọc mà còn giúp tôi củng cố và mở rộng kiến thức của chính mình.\nNhững gì tôi đang làm 🔍 An Ninh Mạng Hiện tại tôi đang xây dựng nền tảng vững chắc với các chứng chỉ từ Google Cybersecurity và IBM. Kiến thức mạng cơ bản đã giúp tôi hiểu được \u0026ldquo;bức tranh lớn\u0026rdquo; của bảo mật.\n🤖 AI \u0026amp; Machine Learning Tôi có kinh nghiệm training model, đặc biệt là BERT. Dự án gần nhất của tôi là \u0026ldquo;Phát hiện mã độc Android bằng Transformer Networks (BERT)\u0026rdquo; - một project thú vị kết hợp giữa AI và Cybersecurity.\n💻 Lập trình Java và JavaScript là những ngôn ngữ tôi đang tập trung, nhưng hành trình coding của tôi không dừng lại ở đó!\nĐiều gì khiến blog này khác biệt? Không chỉ là lý thuyết khô khan. Tôi sẽ chia sẻ:\n✨ Kinh nghiệm thực tế từ các project đã làm 🎯 Cách tiếp cận thực tế thay vì chỉ đọc sách vở 🔧 Tips \u0026amp; tricks mà tôi học được qua quá trình \u0026ldquo;vấp ngã\u0026rdquo; 📚 Kiến thức được \u0026ldquo;dịch\u0026rdquo; sang ngôn ngữ dễ hiểu Mục tiêu của tôi là biến những khái niệm phức tạp thành những câu chuyện thú vị mà bất kỳ ai cũng có thể hiểu được.\nTầm nhìn tương lai Tôi mơ ước một ngày nào đó sẽ đứng trên bục giảng, truyền cảm hứng cho thế hệ các chuyên gia bảo mật tương lai. Blog này chính là bước đầu tiên trong hành trình rèn luyện kỹ năng truyền đạt của tôi.\nMỗi bài viết là một bài giảng nhỏ, mỗi chia sẻ là một lần thực hành để tôi có thể diễn đạt tốt hơn, rõ ràng hơn.\nLời kết Nếu bạn là người:\n🎓 Đang học về Cybersecurity, Java, JavaScript hoặc AI 🔍 Muốn hiểu cách áp dụng kiến thức vào thực tế 💡 Thích học thông qua kinh nghiệm thực tế hơn là lý thuyết suông Thì blog này dành cho bạn! Tôi hy vọng những chia sẻ của mình sẽ giúp ích cho hành trình học tập của các bạn, đồng thời cũng giúp tôi trở thành một người truyền đạt giỏi hơn.\nHãy cùng học, cùng phát triển và cùng tạo nên một cộng đồng tech Việt Nam mạnh mẽ! 🚀\n\u0026ldquo;The best way to learn is to teach others\u0026rdquo; - và đó chính là triết lý tôi theo đuổi trong mỗi bài viết.\n","permalink":"http://localhost:1313/about/","tags":null,"title":"Giới thiệu"},{"categories":null,"contents":"Trong lập trình mạng bằng Java, Socket là công cụ giúp kết nối giữa client và server.\nBằng cách sử dụng java.net.Socket và java.net.ServerSocket, ta có thể xây dựng các ứng dụng chat, truyền file hoặc HTTP server đơn giản.\nMô hình Client-Server cơ bản trong lập trình Socket Ở mức thấp hơn, kết nối TCP được thiết lập qua quá trình bắt tay 3 bước (TCP Handshake).\nĐiều này đảm bảo client và server đồng bộ trạng thái trước khi truyền dữ liệu.\nCơ chế bắt tay 3 bước TCP (Three-Way Handshake) ","permalink":"http://localhost:1313/blog/java-socket/","tags":["Java","Networking"],"title":"Kết nối Socket trong Java"},{"categories":["Programming"],"contents":"Chào các bạn! Hôm nay mình muốn chia sẻ về hành trình học lập trình của mình, từ Java đến JavaScript. Có lẽ nhiều bạn cũng đang băn khoăn giống mình: nên bắt đầu với ngôn ngữ nào? Học Java trước hay JavaScript trước?\nKhởi đầu với Java - Nền tảng vững chắc Mình bắt đầu với Java từ năm nhất đại học. Thật sự lúc đầu khá choáng với cú pháp dài dòng của Java:\npublic class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Hello, World!\u0026#34;); } } So với \u0026ldquo;Hello World\u0026rdquo; của JavaScript:\nconsole.log(\u0026#34;Hello, World!\u0026#34;); Wow, khác biệt quá phải không? Nhưng qua thời gian, mình nhận ra Java đã dạy mình những điều quan trọng:\n1. Tư duy hướng đối tượng (OOP) Java buộc mình phải hiểu về Class, Object, Inheritance\u0026hellip; Lúc đầu khó hiểu lắm, nhưng sau này khi làm dự án lớn mới thấy tầm quan trọng của nó.\n2. Tính nghiêm ngặt về kiểu dữ liệu int number = 10; // Phải khai báo kiểu rõ ràng String text = \u0026#34;Hello\u0026#34;; // Không thể gán số vào String 3. Cấu trúc dự án rõ ràng Package, import, access modifier\u0026hellip; tất cả đều có quy tắc rõ ràng.\nChuyển sang JavaScript - Tự do nhưng cần kỷ luật Khi bắt đầu học JavaScript, mình cảm thấy như được \u0026ldquo;giải phóng\u0026rdquo;:\nlet data = 10; // Kiểu number data = \u0026#34;Hello\u0026#34;; // Giờ thành string data = [1, 2, 3]; // Giờ thành array data = { name: \u0026#34;John\u0026#34; }; // Giờ thành object Tự do quá! Nhưng cũng dễ rối loạn không kém.\nNhững khác biệt chính mình nhận ra: Java:\nCompiled language (biên dịch trước) Strongly typed (kiểu dữ liệu nghiêm ngặt) Platform independent (chạy trên JVM) Chủ yếu cho backend JavaScript:\nInterpreted language (thông dịch) Dynamically typed (kiểu dữ liệu linh hoạt) Chạy trên browser/Node.js Full-stack (cả frontend và backend) Bài học rút ra 1. Java là nền tảng tốt để bắt đầu Nếu bạn chưa biết gì về lập trình, mình khuyên nên bắt đầu với Java. Tại sao?\nBuộc bạn phải viết code chuẩn Hiểu rõ về cấu trúc dữ liệu Tư duy logic tốt hơn 2. JavaScript cần kỷ luật bản thân Vì quá linh hoạt, JavaScript dễ làm cho code trở nên lộn xộn. Mình học được:\nĐặt tên biến có ý nghĩa Sử dụng const/let thay vì var Comment code đầy đủ 3. Cả hai đều có giá trị Java: Tốt cho hệ thống lớn, enterprise applications JavaScript: Linh hoạt, phát triển nhanh, cộng đồng active Lời kết Hành trình từ Java đến JavaScript đã dạy mình rằng không có ngôn ngữ nào là \u0026ldquo;tốt nhất\u0026rdquo;. Mỗi ngôn ngữ đều có ưu nhược điểm riêng. Quan trọng là hiểu rõ bản chất và áp dụng đúng context.\nCác bạn có kinh nghiệm gì thú vị khi học hai ngôn ngữ này không? Hãy chia sẻ trong comment nhé!\nHappy coding! 🚀\n","permalink":"http://localhost:1313/blog/java-to-javascript/","tags":["java","javascript","kinh-nghiem","hoc-tap"],"title":"Từ Java đến JavaScript: Hành trình học lập trình của mình"},{"categories":["Java"],"contents":"Xin chào các bạn! Hôm nay mình muốn chia sẻ về những sai lầm \u0026ldquo;kinh điển\u0026rdquo; mà hầu như ai học Java cũng mắc phải, bao gồm cả mình. Hy vọng qua bài viết này, các bạn newbie sẽ tránh được những \u0026ldquo;hố đen\u0026rdquo; mà mình đã rơi vào.\nSai lầm #1: Lạm dụng public static void main Mình từng làm thế này: public class Calculator { public static void main(String[] args) { // Viết tất cả logic trong main int a = 10, b = 5; int sum = a + b; int diff = a - b; int product = a * b; int quotient = a / b; System.out.println(\u0026#34;Sum: \u0026#34; + sum); System.out.println(\u0026#34;Difference: \u0026#34; + diff); // ... và còn 50 dòng code nữa } } Vấn đề: Code không thể tái sử dụng Khó debug và maintain Không theo nguyên tắc OOP Cách khắc phục: public class Calculator { public int add(int a, int b) { return a + b; } public int subtract(int a, int b) { return a - b; } public static void main(String[] args) { Calculator calc = new Calculator(); System.out.println(\u0026#34;Sum: \u0026#34; + calc.add(10, 5)); System.out.println(\u0026#34;Difference: \u0026#34; + calc.subtract(10, 5)); } } Sai lầm #2: Không hiểu về Reference vs Value Mình từng nghĩ: public class Student { String name; public static void main(String[] args) { Student s1 = new Student(); s1.name = \u0026#34;Nam\u0026#34;; Student s2 = s1; // Mình tưởng s2 là bản copy của s1 s2.name = \u0026#34;Linh\u0026#34;; System.out.println(s1.name); // Tại sao lại in ra \u0026#34;Linh\u0026#34;??? } } Bài học: Trong Java, object được truyền theo reference, không phải value. Khi gán s2 = s1, cả hai đều trỏ đến cùng một object trong memory.\nGiải pháp: public class Student implements Cloneable { String name; public Student(String name) { this.name = name; } // Constructor copy public Student(Student other) { this.name = other.name; } public static void main(String[] args) { Student s1 = new Student(\u0026#34;Nam\u0026#34;); Student s2 = new Student(s1); // Tạo object mới s2.name = \u0026#34;Linh\u0026#34;; System.out.println(s1.name); // \u0026#34;Nam\u0026#34; System.out.println(s2.name); // \u0026#34;Linh\u0026#34; } } Sai lầm #3: Không xử lý Exception đúng cách Code \u0026ldquo;tệ\u0026rdquo; của mình: public void readFile(String fileName) { try { FileReader file = new FileReader(fileName); BufferedReader reader = new BufferedReader(file); String line = reader.readLine(); System.out.println(line); } catch (Exception e) { // Im lặng, không làm gì cả - RỐT THẬM TỆ! } } Vấn đề: \u0026ldquo;Nuốt\u0026rdquo; exception mà không xử lý Sử dụng Exception quá general Không đóng resource Cách đúng: public void readFile(String fileName) { try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) { String line = reader.readLine(); if (line != null) { System.out.println(line); } } catch (FileNotFoundException e) { System.err.println(\u0026#34;Không tìm thấy file: \u0026#34; + fileName); // Log hoặc throw lại exception } catch (IOException e) { System.err.println(\u0026#34;Lỗi đọc file: \u0026#34; + e.getMessage()); } } Sai lầm #4: So sánh String bằng == Code sai: public class StringComparison { public static void main(String[] args) { String s1 = \u0026#34;Hello\u0026#34;; String s2 = new String(\u0026#34;Hello\u0026#34;); if (s1 == s2) { // SAAAIIII! System.out.println(\u0026#34;Equal\u0026#34;); } else { System.out.println(\u0026#34;Not equal\u0026#34;); // Sẽ in ra này } } } Giải thích: == so sánh reference, không phải content s1 trỏ đến String Pool s2 trỏ đến object mới trong heap Cách đúng: public class StringComparison { public static void main(String[] args) { String s1 = \u0026#34;Hello\u0026#34;; String s2 = new String(\u0026#34;Hello\u0026#34;); if (s1.equals(s2)) { // So sánh content System.out.println(\u0026#34;Equal\u0026#34;); } // Hoặc an toàn hơn với null check if (Objects.equals(s1, s2)) { System.out.println(\u0026#34;Equal and null-safe\u0026#34;); } } } Sai lầm #5: Không hiểu về Access Modifier Code của mình lúc trước: public class BankAccount { public double balance; // Ai cũng có thể truy cập! public BankAccount(double initialBalance) { balance = initialBalance; } } // Ở nơi khác BankAccount account = new BankAccount(1000); account.balance = -500; // Oops! Balance âm??? Vấn đề: Dữ liệu quan trọng không được bảo vệ Vi phạm nguyên tắc Encapsulation Cách khắc phục: public class BankAccount { private double balance; // Chỉ class này truy cập được public BankAccount(double initialBalance) { if (initialBalance \u0026gt;= 0) { this.balance = initialBalance; } else { throw new IllegalArgumentException(\u0026#34;Balance không thể âm\u0026#34;); } } public double getBalance() { return balance; } public void deposit(double amount) { if (amount \u0026gt; 0) { balance += amount; } } public boolean withdraw(double amount) { if (amount \u0026gt; 0 \u0026amp;\u0026amp; amount \u0026lt;= balance) { balance -= amount; return true; } return false; } } Tổng kết Những sai lầm này đã giúp mình hiểu sâu hơn về Java. Đừng sợ mắc lỗi, quan trọng là học hỏi từ chúng!\nTips để tránh sai lầm: Practice coding every day - Luyện tập thường xuyên Read other people\u0026rsquo;s code - Đọc code của người khác Use IDE effectively - Tận dụng IDE để catch lỗi sớm Code review - Nhờ bạn bè review code Read documentation - Đọc docs chính thức của Java Các bạn đã mắc phải sai lầm nào trong danh sách này chưa? Hoặc có sai lầm nào khác muốn chia sẻ? Comment bên dưới nhé!\nKeep learning, keep coding! ☕\n","permalink":"http://localhost:1313/blog/5-wrong-errors/","tags":["java","sai-lam","kinh-nghiem","hoc-tap"],"title":"5 Sai lầm phổ biến khi học Java mà mình đã mắc phải"},{"categories":["JavaScript"],"contents":"Chào mọi người! Khi mới học JavaScript, mình chỉ biết đến cú pháp cũ ES5. Nhưng khi tiếp xúc với ES6+ (ES2015 trở lên), thật sự mình cảm thấy như được \u0026ldquo;khai sáng\u0026rdquo;. Hôm nay mình muốn chia sẻ những tính năng ES6+ đã thay đổi hoàn toàn cách mình viết JavaScript.\n1. Let \u0026amp; Const - Tạm biệt var nhé! Cách cũ với var: // Vấn đề với var function oldWay() { for (var i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; { console.log(i); // In ra 3, 3, 3 (WTF???) }, 100); } console.log(i); // 3 - i vẫn tồn tại ngoài loop! } Cách mới với let \u0026amp; const: function newWay() { for (let i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; { console.log(i); // In ra 0, 1, 2 (chính xác!) }, 100); } // console.log(i); // ReferenceError - i không tồn tại ở đây const API_URL = \u0026#34;https://api.example.com\u0026#34;; // API_URL = \u0026#39;other-url\u0026#39;; // TypeError - không thể reassign const } Bài học: Luôn dùng const cho giá trị không thay đổi, let cho biến có thể thay đổi. Quên var đi!\n2. Arrow Functions - Code ngắn gọn hơn ES5 way: // Function expression cũ var users = [\u0026#34;Nam\u0026#34;, \u0026#34;Linh\u0026#34;, \u0026#34;Hoa\u0026#34;]; var uppercaseUsers = users.map(function (user) { return user.toUpperCase(); }); var button = document.getElementById(\u0026#34;btn\u0026#34;); button.addEventListener(\u0026#34;click\u0026#34;, function () { console.log(this); // \u0026#39;this\u0026#39; trỏ đến button }); ES6 way: // Arrow function - clean và concise const users = [\u0026#34;Nam\u0026#34;, \u0026#34;Linh\u0026#34;, \u0026#34;Hoa\u0026#34;]; const uppercaseUsers = users.map((user) =\u0026gt; user.toUpperCase()); // Với multiple parameters const add = (a, b) =\u0026gt; a + b; // Với function body const processUser = (user) =\u0026gt; { const processed = user.trim().toUpperCase(); return `Hello, ${processed}!`; }; // Lưu ý về \u0026#39;this\u0026#39; binding const obj = { name: \u0026#34;MyObject\u0026#34;, regularFunction() { console.log(this.name); // \u0026#39;MyObject\u0026#39; const arrowFunction = () =\u0026gt; { console.log(this.name); // \u0026#39;MyObject\u0026#39; - inherit từ parent scope }; arrowFunction(); }, }; Tip: Arrow function không có this binding riêng, nó inherit từ parent scope.\n3. Template Literals - Goodbye string concatenation! Cách cũ: var name = \u0026#34;Nam\u0026#34;; var age = 20; var city = \u0026#34;Ho Chi Minh\u0026#34;; var introduction = \u0026#34;Xin chào, tôi là \u0026#34; + name + \u0026#34;, \u0026#34; + age + \u0026#34; tuổi, \u0026#34; + \u0026#34;đến từ \u0026#34; + city + \u0026#34;.\u0026#34;; var htmlTemplate = \u0026#39;\u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt;\u0026#39; + \u0026#34;\u0026lt;h2\u0026gt;\u0026#34; + name + \u0026#34;\u0026lt;/h2\u0026gt;\u0026#34; + \u0026#34;\u0026lt;p\u0026gt;Age: \u0026#34; + age + \u0026#34;\u0026lt;/p\u0026gt;\u0026#34; + \u0026#34;\u0026lt;/div\u0026gt;\u0026#34;; Cách mới: const name = \u0026#34;Nam\u0026#34;; const age = 20; const city = \u0026#34;Ho Chi Minh\u0026#34;; // Template literals với backticks const introduction = `Xin chào, tôi là ${name}, ${age} tuổi, đến từ ${city}.`; // Multi-line strings dễ dàng const htmlTemplate = ` \u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;${name}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Age: ${age}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Status: ${age \u0026gt;= 18 ? \u0026#34;Adult\u0026#34; : \u0026#34;Minor\u0026#34;}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `; // Tagged template literals (advanced) function highlight(strings, ...values) { return strings.reduce((result, string, i) =\u0026gt; { const value = values[i] ? `\u0026lt;mark\u0026gt;${values[i]}\u0026lt;/mark\u0026gt;` : \u0026#34;\u0026#34;; return result + string + value; }, \u0026#34;\u0026#34;); } const highlighted = highlight`Tôi tên là ${name} và ${age} tuổi.`; 4. Destructuring - Unpack dữ liệu như ninja Array Destructuring: // Cách cũ var numbers = [1, 2, 3, 4, 5]; var first = numbers[0]; var second = numbers[1]; var rest = numbers.slice(2); // Cách mới const [first, second, ...rest] = [1, 2, 3, 4, 5]; console.log(first); // 1 console.log(second); // 2 console.log(rest); // [3, 4, 5] // Skip elements const [a, , c] = [1, 2, 3]; console.log(a, c); // 1, 3 // Default values const [x = 0, y = 0] = [1]; // x = 1, y = 0 Object Destructuring: // Cách cũ var user = { name: \u0026#34;Nam\u0026#34;, age: 20, email: \u0026#34;nam@example.com\u0026#34;, address: { city: \u0026#34;Ho Chi Minh\u0026#34;, district: \u0026#34;District 1\u0026#34;, }, }; var name = user.name; var age = user.age; var email = user.email; // Cách mới const { name, age, email } = user; // Rename variables const { name: userName, age: userAge } = user; // Nested destructuring const { address: { city, district }, } = user; // Default values const { phone = \u0026#34;N/A\u0026#34; } = user; // Function parameters destructuring function greetUser({ name, age = \u0026#34;unknown\u0026#34; }) { return `Hello ${name}, you are ${age} years old`; } greetUser({ name: \u0026#34;Nam\u0026#34;, age: 20 }); 5. Spread \u0026amp; Rest Operators - Ba chấm ma thuật Spread Operator (\u0026hellip;): // Array spreading const arr1 = [1, 2, 3]; const arr2 = [4, 5, 6]; const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6] // Object spreading const user = { name: \u0026#34;Nam\u0026#34;, age: 20 }; const updatedUser = { ...user, age: 21, city: \u0026#34;HCM\u0026#34; }; // { name: \u0026#39;Nam\u0026#39;, age: 21, city: \u0026#39;HCM\u0026#39; } // Function arguments function sum(a, b, c) { return a + b + c; } const numbers = [1, 2, 3]; console.log(sum(...numbers)); // 6 Rest Operator (\u0026hellip;): // Function parameters function logAll(first, ...others) { console.log(\u0026#34;First:\u0026#34;, first); console.log(\u0026#34;Others:\u0026#34;, others); } logAll(1, 2, 3, 4, 5); // First: 1, Others: [2, 3, 4, 5] // Array destructuring (đã thấy ở trên) const [head, ...tail] = [1, 2, 3, 4, 5]; 6. Enhanced Object Literals const name = \u0026#34;Nam\u0026#34;; const age = 20; // Cách cũ var user = { name: name, age: age, greet: function () { return \u0026#34;Hello!\u0026#34;; }, }; // Cách mới - shorthand properties const user = { name, // tương đương name: name age, // tương đương age: age // Method shorthand greet() { return \u0026#34;Hello!\u0026#34;; }, // Computed property names [`full${name}`]: `${name} Nguyen`, // Dynamic property [getPropertyName()]: \u0026#34;dynamic value\u0026#34;, }; 7. Promises \u0026amp; Async/Await - Tạm biệt Callback Hell Callback Hell: // Cách cũ - callback hell fetchUser(userId, function (user) { fetchUserPosts(user.id, function (posts) { fetchPostComments(posts[0].id, function (comments) { // Nested callbacks - khó đọc và maintain console.log(comments); }); }); }); Promises: // Promise chain fetchUser(userId) .then((user) =\u0026gt; fetchUserPosts(user.id)) .then((posts) =\u0026gt; fetchPostComments(posts[0].id)) .then((comments) =\u0026gt; console.log(comments)) .catch((error) =\u0026gt; console.error(error)); Async/Await: // Async/await - code như synchronous async function getUserData(userId) { try { const user = await fetchUser(userId); const posts = await fetchUserPosts(user.id); const comments = await fetchPostComments(posts[0].id); return comments; } catch (error) { console.error(\u0026#34;Error:\u0026#34;, error); throw error; } } // Sử dụng getUserData(123).then((data) =\u0026gt; console.log(data)); Kết luận ES6+ đã thực sự thay đổi cách mình viết JavaScript:\nCode ngắn gọn và dễ đọc hơn Ít bugs hơn nhờ let/const Xử lý async code dễ dàng hơn Destructuring giúp unpack data elegantly Tips cho người mới: Học từ từ - Đừng cố gắng học tất cả một lúc Practice daily - Viết code ES6+ mỗi ngày Use Babel - Để support browser cũ Read MDN docs - Tài liệu chính thức luôn tốt nhất Các bạn đã dùng feature nào trong số này chưa? Feature nào khiến các bạn ấn tượng nhất? Share ở comment nhé!\nModern JavaScript is beautiful! 🚀✨\n","permalink":"http://localhost:1313/blog/javascript-es6+/","tags":["javascript","es6","modern-js","kinh-nghiem"],"title":"JavaScript ES6+: Những tính năng đã thay đổi cách mình code"},{"categories":null,"contents":"Xin chào! Tôi là Tiết Thanh Minh Hiếu 👋 Câu chuyện của tôi Tôi là một sinh viên đang theo đuổi ước mơ trở thành chuyên viên An Ninh Mạng, với niềm đam mê bảo vệ thế giới số khỏi những mối đe dọa ngày càng phức tạp. Nhưng điều đặc biệt là tôi không chỉ muốn \u0026ldquo;làm\u0026rdquo; mà còn muốn \u0026ldquo;truyền cảm hứng\u0026rdquo; - mục tiêu của tôi là trở thành một giảng viên Security, người có thể biến những kiến thức phức tạp thành những bài học dễ hiểu và thú vị.\nTại sao tôi tạo blog này? Ban đầu, blog này được tạo ra để hoàn thành yêu cầu môn học về Java \u0026amp; JavaScript. Nhưng tôi nhận ra đây chính là cơ hội tuyệt vời để bắt đầu hành trình chia sẻ kiến thức mà tôi đã ấp ủ từ lâu.\nTôi tin rằng: Cách học tốt nhất là dạy lại cho người khác. Mỗi bài viết tôi chia sẻ không chỉ giúp các bạn đọc mà còn giúp tôi củng cố và mở rộng kiến thức của chính mình.\nNhững gì tôi đang làm 🔍 An Ninh Mạng Hiện tại tôi đang xây dựng nền tảng vững chắc với các chứng chỉ từ Google Cybersecurity và IBM. Kiến thức mạng cơ bản đã giúp tôi hiểu được \u0026ldquo;bức tranh lớn\u0026rdquo; của bảo mật.\n🤖 AI \u0026amp; Machine Learning Tôi có kinh nghiệm training model, đặc biệt là BERT. Dự án gần nhất của tôi là \u0026ldquo;Phát hiện mã độc Android bằng Transformer Networks (BERT)\u0026rdquo; - một project thú vị kết hợp giữa AI và Cybersecurity.\n💻 Lập trình Java và JavaScript là những ngôn ngữ tôi đang tập trung, nhưng hành trình coding của tôi không dừng lại ở đó!\nĐiều gì khiến blog này khác biệt? Không chỉ là lý thuyết khô khan. Tôi sẽ chia sẻ:\n✨ Kinh nghiệm thực tế từ các project đã làm 🎯 Cách tiếp cận thực tế thay vì chỉ đọc sách vở 🔧 Tips \u0026amp; tricks mà tôi học được qua quá trình \u0026ldquo;vấp ngã\u0026rdquo; 📚 Kiến thức được \u0026ldquo;dịch\u0026rdquo; sang ngôn ngữ dễ hiểu Mục tiêu của tôi là biến những khái niệm phức tạp thành những câu chuyện thú vị mà bất kỳ ai cũng có thể hiểu được.\nTầm nhìn tương lai Tôi mơ ước một ngày nào đó sẽ đứng trên bục giảng, truyền cảm hứng cho thế hệ các chuyên gia bảo mật tương lai. Blog này chính là bước đầu tiên trong hành trình rèn luyện kỹ năng truyền đạt của tôi.\nMỗi bài viết là một bài giảng nhỏ, mỗi chia sẻ là một lần thực hành để tôi có thể diễn đạt tốt hơn, rõ ràng hơn.\nLời kết Nếu bạn là người:\n🎓 Đang học về Cybersecurity, Java, JavaScript hoặc AI 🔍 Muốn hiểu cách áp dụng kiến thức vào thực tế 💡 Thích học thông qua kinh nghiệm thực tế hơn là lý thuyết suông Thì blog này dành cho bạn! Tôi hy vọng những chia sẻ của mình sẽ giúp ích cho hành trình học tập của các bạn, đồng thời cũng giúp tôi trở thành một người truyền đạt giỏi hơn.\nHãy cùng học, cùng phát triển và cùng tạo nên một cộng đồng tech Việt Nam mạnh mẽ! 🚀\n\u0026ldquo;The best way to learn is to teach others\u0026rdquo; - và đó chính là triết lý tôi theo đuổi trong mỗi bài viết.\n","permalink":"http://localhost:1313/about/","tags":null,"title":"Giới thiệu"},{"categories":null,"contents":"Trong lập trình mạng bằng Java, Socket là công cụ giúp kết nối giữa client và server.\nBằng cách sử dụng java.net.Socket và java.net.ServerSocket, ta có thể xây dựng các ứng dụng chat, truyền file hoặc HTTP server đơn giản.\nMô hình Client-Server cơ bản trong lập trình Socket Ở mức thấp hơn, kết nối TCP được thiết lập qua quá trình bắt tay 3 bước (TCP Handshake).\nĐiều này đảm bảo client và server đồng bộ trạng thái trước khi truyền dữ liệu.\nCơ chế bắt tay 3 bước TCP (Three-Way Handshake) ","permalink":"http://localhost:1313/blog/java-socket/","tags":["Java","Networking"],"title":"Kết nối Socket trong Java"},{"categories":["Programming"],"contents":"Chào các bạn! Hôm nay mình muốn chia sẻ về hành trình học lập trình của mình, từ Java đến JavaScript. Có lẽ nhiều bạn cũng đang băn khoăn giống mình: nên bắt đầu với ngôn ngữ nào? Học Java trước hay JavaScript trước?\nKhởi đầu với Java - Nền tảng vững chắc Mình bắt đầu với Java từ năm nhất đại học. Thật sự lúc đầu khá choáng với cú pháp dài dòng của Java:\npublic class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Hello, World!\u0026#34;); } } So với \u0026ldquo;Hello World\u0026rdquo; của JavaScript:\nconsole.log(\u0026#34;Hello, World!\u0026#34;); Wow, khác biệt quá phải không? Nhưng qua thời gian, mình nhận ra Java đã dạy mình những điều quan trọng:\n1. Tư duy hướng đối tượng (OOP) Java buộc mình phải hiểu về Class, Object, Inheritance\u0026hellip; Lúc đầu khó hiểu lắm, nhưng sau này khi làm dự án lớn mới thấy tầm quan trọng của nó.\n2. Tính nghiêm ngặt về kiểu dữ liệu int number = 10; // Phải khai báo kiểu rõ ràng String text = \u0026#34;Hello\u0026#34;; // Không thể gán số vào String 3. Cấu trúc dự án rõ ràng Package, import, access modifier\u0026hellip; tất cả đều có quy tắc rõ ràng.\nChuyển sang JavaScript - Tự do nhưng cần kỷ luật Khi bắt đầu học JavaScript, mình cảm thấy như được \u0026ldquo;giải phóng\u0026rdquo;:\nlet data = 10; // Kiểu number data = \u0026#34;Hello\u0026#34;; // Giờ thành string data = [1, 2, 3]; // Giờ thành array data = { name: \u0026#34;John\u0026#34; }; // Giờ thành object Tự do quá! Nhưng cũng dễ rối loạn không kém.\nNhững khác biệt chính mình nhận ra: Java:\nCompiled language (biên dịch trước) Strongly typed (kiểu dữ liệu nghiêm ngặt) Platform independent (chạy trên JVM) Chủ yếu cho backend JavaScript:\nInterpreted language (thông dịch) Dynamically typed (kiểu dữ liệu linh hoạt) Chạy trên browser/Node.js Full-stack (cả frontend và backend) Bài học rút ra 1. Java là nền tảng tốt để bắt đầu Nếu bạn chưa biết gì về lập trình, mình khuyên nên bắt đầu với Java. Tại sao?\nBuộc bạn phải viết code chuẩn Hiểu rõ về cấu trúc dữ liệu Tư duy logic tốt hơn 2. JavaScript cần kỷ luật bản thân Vì quá linh hoạt, JavaScript dễ làm cho code trở nên lộn xộn. Mình học được:\nĐặt tên biến có ý nghĩa Sử dụng const/let thay vì var Comment code đầy đủ 3. Cả hai đều có giá trị Java: Tốt cho hệ thống lớn, enterprise applications JavaScript: Linh hoạt, phát triển nhanh, cộng đồng active Lời kết Hành trình từ Java đến JavaScript đã dạy mình rằng không có ngôn ngữ nào là \u0026ldquo;tốt nhất\u0026rdquo;. Mỗi ngôn ngữ đều có ưu nhược điểm riêng. Quan trọng là hiểu rõ bản chất và áp dụng đúng context.\nCác bạn có kinh nghiệm gì thú vị khi học hai ngôn ngữ này không? Hãy chia sẻ trong comment nhé!\nHappy coding! 🚀\n","permalink":"http://localhost:1313/blog/java-to-javascript/","tags":["java","javascript","kinh-nghiem","hoc-tap"],"title":"Từ Java đến JavaScript: Hành trình học lập trình của mình"},{"categories":["Java"],"contents":"Xin chào các bạn! Hôm nay mình muốn chia sẻ về những sai lầm \u0026ldquo;kinh điển\u0026rdquo; mà hầu như ai học Java cũng mắc phải, bao gồm cả mình. Hy vọng qua bài viết này, các bạn newbie sẽ tránh được những \u0026ldquo;hố đen\u0026rdquo; mà mình đã rơi vào.\nSai lầm #1: Lạm dụng public static void main Mình từng làm thế này: public class Calculator { public static void main(String[] args) { // Viết tất cả logic trong main int a = 10, b = 5; int sum = a + b; int diff = a - b; int product = a * b; int quotient = a / b; System.out.println(\u0026#34;Sum: \u0026#34; + sum); System.out.println(\u0026#34;Difference: \u0026#34; + diff); // ... và còn 50 dòng code nữa } } Vấn đề: Code không thể tái sử dụng Khó debug và maintain Không theo nguyên tắc OOP Cách khắc phục: public class Calculator { public int add(int a, int b) { return a + b; } public int subtract(int a, int b) { return a - b; } public static void main(String[] args) { Calculator calc = new Calculator(); System.out.println(\u0026#34;Sum: \u0026#34; + calc.add(10, 5)); System.out.println(\u0026#34;Difference: \u0026#34; + calc.subtract(10, 5)); } } Sai lầm #2: Không hiểu về Reference vs Value Mình từng nghĩ: public class Student { String name; public static void main(String[] args) { Student s1 = new Student(); s1.name = \u0026#34;Nam\u0026#34;; Student s2 = s1; // Mình tưởng s2 là bản copy của s1 s2.name = \u0026#34;Linh\u0026#34;; System.out.println(s1.name); // Tại sao lại in ra \u0026#34;Linh\u0026#34;??? } } Bài học: Trong Java, object được truyền theo reference, không phải value. Khi gán s2 = s1, cả hai đều trỏ đến cùng một object trong memory.\nGiải pháp: public class Student implements Cloneable { String name; public Student(String name) { this.name = name; } // Constructor copy public Student(Student other) { this.name = other.name; } public static void main(String[] args) { Student s1 = new Student(\u0026#34;Nam\u0026#34;); Student s2 = new Student(s1); // Tạo object mới s2.name = \u0026#34;Linh\u0026#34;; System.out.println(s1.name); // \u0026#34;Nam\u0026#34; System.out.println(s2.name); // \u0026#34;Linh\u0026#34; } } Sai lầm #3: Không xử lý Exception đúng cách Code \u0026ldquo;tệ\u0026rdquo; của mình: public void readFile(String fileName) { try { FileReader file = new FileReader(fileName); BufferedReader reader = new BufferedReader(file); String line = reader.readLine(); System.out.println(line); } catch (Exception e) { // Im lặng, không làm gì cả - RỐT THẬM TỆ! } } Vấn đề: \u0026ldquo;Nuốt\u0026rdquo; exception mà không xử lý Sử dụng Exception quá general Không đóng resource Cách đúng: public void readFile(String fileName) { try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) { String line = reader.readLine(); if (line != null) { System.out.println(line); } } catch (FileNotFoundException e) { System.err.println(\u0026#34;Không tìm thấy file: \u0026#34; + fileName); // Log hoặc throw lại exception } catch (IOException e) { System.err.println(\u0026#34;Lỗi đọc file: \u0026#34; + e.getMessage()); } } Sai lầm #4: So sánh String bằng == Code sai: public class StringComparison { public static void main(String[] args) { String s1 = \u0026#34;Hello\u0026#34;; String s2 = new String(\u0026#34;Hello\u0026#34;); if (s1 == s2) { // SAAAIIII! System.out.println(\u0026#34;Equal\u0026#34;); } else { System.out.println(\u0026#34;Not equal\u0026#34;); // Sẽ in ra này } } } Giải thích: == so sánh reference, không phải content s1 trỏ đến String Pool s2 trỏ đến object mới trong heap Cách đúng: public class StringComparison { public static void main(String[] args) { String s1 = \u0026#34;Hello\u0026#34;; String s2 = new String(\u0026#34;Hello\u0026#34;); if (s1.equals(s2)) { // So sánh content System.out.println(\u0026#34;Equal\u0026#34;); } // Hoặc an toàn hơn với null check if (Objects.equals(s1, s2)) { System.out.println(\u0026#34;Equal and null-safe\u0026#34;); } } } Sai lầm #5: Không hiểu về Access Modifier Code của mình lúc trước: public class BankAccount { public double balance; // Ai cũng có thể truy cập! public BankAccount(double initialBalance) { balance = initialBalance; } } // Ở nơi khác BankAccount account = new BankAccount(1000); account.balance = -500; // Oops! Balance âm??? Vấn đề: Dữ liệu quan trọng không được bảo vệ Vi phạm nguyên tắc Encapsulation Cách khắc phục: public class BankAccount { private double balance; // Chỉ class này truy cập được public BankAccount(double initialBalance) { if (initialBalance \u0026gt;= 0) { this.balance = initialBalance; } else { throw new IllegalArgumentException(\u0026#34;Balance không thể âm\u0026#34;); } } public double getBalance() { return balance; } public void deposit(double amount) { if (amount \u0026gt; 0) { balance += amount; } } public boolean withdraw(double amount) { if (amount \u0026gt; 0 \u0026amp;\u0026amp; amount \u0026lt;= balance) { balance -= amount; return true; } return false; } } Tổng kết Những sai lầm này đã giúp mình hiểu sâu hơn về Java. Đừng sợ mắc lỗi, quan trọng là học hỏi từ chúng!\nTips để tránh sai lầm: Practice coding every day - Luyện tập thường xuyên Read other people\u0026rsquo;s code - Đọc code của người khác Use IDE effectively - Tận dụng IDE để catch lỗi sớm Code review - Nhờ bạn bè review code Read documentation - Đọc docs chính thức của Java Các bạn đã mắc phải sai lầm nào trong danh sách này chưa? Hoặc có sai lầm nào khác muốn chia sẻ? Comment bên dưới nhé!\nKeep learning, keep coding! ☕\n","permalink":"http://localhost:1313/blog/5-wrong-errors/","tags":["java","sai-lam","kinh-nghiem","hoc-tap"],"title":"5 Sai lầm phổ biến khi học Java mà mình đã mắc phải"},{"categories":["JavaScript"],"contents":"Chào mọi người! Khi mới học JavaScript, mình chỉ biết đến cú pháp cũ ES5. Nhưng khi tiếp xúc với ES6+ (ES2015 trở lên), thật sự mình cảm thấy như được \u0026ldquo;khai sáng\u0026rdquo;. Hôm nay mình muốn chia sẻ những tính năng ES6+ đã thay đổi hoàn toàn cách mình viết JavaScript.\n1. Let \u0026amp; Const - Tạm biệt var nhé! Cách cũ với var: // Vấn đề với var function oldWay() { for (var i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; { console.log(i); // In ra 3, 3, 3 (WTF???) }, 100); } console.log(i); // 3 - i vẫn tồn tại ngoài loop! } Cách mới với let \u0026amp; const: function newWay() { for (let i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; { console.log(i); // In ra 0, 1, 2 (chính xác!) }, 100); } // console.log(i); // ReferenceError - i không tồn tại ở đây const API_URL = \u0026#34;https://api.example.com\u0026#34;; // API_URL = \u0026#39;other-url\u0026#39;; // TypeError - không thể reassign const } Bài học: Luôn dùng const cho giá trị không thay đổi, let cho biến có thể thay đổi. Quên var đi!\n2. Arrow Functions - Code ngắn gọn hơn ES5 way: // Function expression cũ var users = [\u0026#34;Nam\u0026#34;, \u0026#34;Linh\u0026#34;, \u0026#34;Hoa\u0026#34;]; var uppercaseUsers = users.map(function (user) { return user.toUpperCase(); }); var button = document.getElementById(\u0026#34;btn\u0026#34;); button.addEventListener(\u0026#34;click\u0026#34;, function () { console.log(this); // \u0026#39;this\u0026#39; trỏ đến button }); ES6 way: // Arrow function - clean và concise const users = [\u0026#34;Nam\u0026#34;, \u0026#34;Linh\u0026#34;, \u0026#34;Hoa\u0026#34;]; const uppercaseUsers = users.map((user) =\u0026gt; user.toUpperCase()); // Với multiple parameters const add = (a, b) =\u0026gt; a + b; // Với function body const processUser = (user) =\u0026gt; { const processed = user.trim().toUpperCase(); return `Hello, ${processed}!`; }; // Lưu ý về \u0026#39;this\u0026#39; binding const obj = { name: \u0026#34;MyObject\u0026#34;, regularFunction() { console.log(this.name); // \u0026#39;MyObject\u0026#39; const arrowFunction = () =\u0026gt; { console.log(this.name); // \u0026#39;MyObject\u0026#39; - inherit từ parent scope }; arrowFunction(); }, }; Tip: Arrow function không có this binding riêng, nó inherit từ parent scope.\n3. Template Literals - Goodbye string concatenation! Cách cũ: var name = \u0026#34;Nam\u0026#34;; var age = 20; var city = \u0026#34;Ho Chi Minh\u0026#34;; var introduction = \u0026#34;Xin chào, tôi là \u0026#34; + name + \u0026#34;, \u0026#34; + age + \u0026#34; tuổi, \u0026#34; + \u0026#34;đến từ \u0026#34; + city + \u0026#34;.\u0026#34;; var htmlTemplate = \u0026#39;\u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt;\u0026#39; + \u0026#34;\u0026lt;h2\u0026gt;\u0026#34; + name + \u0026#34;\u0026lt;/h2\u0026gt;\u0026#34; + \u0026#34;\u0026lt;p\u0026gt;Age: \u0026#34; + age + \u0026#34;\u0026lt;/p\u0026gt;\u0026#34; + \u0026#34;\u0026lt;/div\u0026gt;\u0026#34;; Cách mới: const name = \u0026#34;Nam\u0026#34;; const age = 20; const city = \u0026#34;Ho Chi Minh\u0026#34;; // Template literals với backticks const introduction = `Xin chào, tôi là ${name}, ${age} tuổi, đến từ ${city}.`; // Multi-line strings dễ dàng const htmlTemplate = ` \u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;${name}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Age: ${age}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Status: ${age \u0026gt;= 18 ? \u0026#34;Adult\u0026#34; : \u0026#34;Minor\u0026#34;}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `; // Tagged template literals (advanced) function highlight(strings, ...values) { return strings.reduce((result, string, i) =\u0026gt; { const value = values[i] ? `\u0026lt;mark\u0026gt;${values[i]}\u0026lt;/mark\u0026gt;` : \u0026#34;\u0026#34;; return result + string + value; }, \u0026#34;\u0026#34;); } const highlighted = highlight`Tôi tên là ${name} và ${age} tuổi.`; 4. Destructuring - Unpack dữ liệu như ninja Array Destructuring: // Cách cũ var numbers = [1, 2, 3, 4, 5]; var first = numbers[0]; var second = numbers[1]; var rest = numbers.slice(2); // Cách mới const [first, second, ...rest] = [1, 2, 3, 4, 5]; console.log(first); // 1 console.log(second); // 2 console.log(rest); // [3, 4, 5] // Skip elements const [a, , c] = [1, 2, 3]; console.log(a, c); // 1, 3 // Default values const [x = 0, y = 0] = [1]; // x = 1, y = 0 Object Destructuring: // Cách cũ var user = { name: \u0026#34;Nam\u0026#34;, age: 20, email: \u0026#34;nam@example.com\u0026#34;, address: { city: \u0026#34;Ho Chi Minh\u0026#34;, district: \u0026#34;District 1\u0026#34;, }, }; var name = user.name; var age = user.age; var email = user.email; // Cách mới const { name, age, email } = user; // Rename variables const { name: userName, age: userAge } = user; // Nested destructuring const { address: { city, district }, } = user; // Default values const { phone = \u0026#34;N/A\u0026#34; } = user; // Function parameters destructuring function greetUser({ name, age = \u0026#34;unknown\u0026#34; }) { return `Hello ${name}, you are ${age} years old`; } greetUser({ name: \u0026#34;Nam\u0026#34;, age: 20 }); 5. Spread \u0026amp; Rest Operators - Ba chấm ma thuật Spread Operator (\u0026hellip;): // Array spreading const arr1 = [1, 2, 3]; const arr2 = [4, 5, 6]; const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6] // Object spreading const user = { name: \u0026#34;Nam\u0026#34;, age: 20 }; const updatedUser = { ...user, age: 21, city: \u0026#34;HCM\u0026#34; }; // { name: \u0026#39;Nam\u0026#39;, age: 21, city: \u0026#39;HCM\u0026#39; } // Function arguments function sum(a, b, c) { return a + b + c; } const numbers = [1, 2, 3]; console.log(sum(...numbers)); // 6 Rest Operator (\u0026hellip;): // Function parameters function logAll(first, ...others) { console.log(\u0026#34;First:\u0026#34;, first); console.log(\u0026#34;Others:\u0026#34;, others); } logAll(1, 2, 3, 4, 5); // First: 1, Others: [2, 3, 4, 5] // Array destructuring (đã thấy ở trên) const [head, ...tail] = [1, 2, 3, 4, 5]; 6. Enhanced Object Literals const name = \u0026#34;Nam\u0026#34;; const age = 20; // Cách cũ var user = { name: name, age: age, greet: function () { return \u0026#34;Hello!\u0026#34;; }, }; // Cách mới - shorthand properties const user = { name, // tương đương name: name age, // tương đương age: age // Method shorthand greet() { return \u0026#34;Hello!\u0026#34;; }, // Computed property names [`full${name}`]: `${name} Nguyen`, // Dynamic property [getPropertyName()]: \u0026#34;dynamic value\u0026#34;, }; 7. Promises \u0026amp; Async/Await - Tạm biệt Callback Hell Callback Hell: // Cách cũ - callback hell fetchUser(userId, function (user) { fetchUserPosts(user.id, function (posts) { fetchPostComments(posts[0].id, function (comments) { // Nested callbacks - khó đọc và maintain console.log(comments); }); }); }); Promises: // Promise chain fetchUser(userId) .then((user) =\u0026gt; fetchUserPosts(user.id)) .then((posts) =\u0026gt; fetchPostComments(posts[0].id)) .then((comments) =\u0026gt; console.log(comments)) .catch((error) =\u0026gt; console.error(error)); Async/Await: // Async/await - code như synchronous async function getUserData(userId) { try { const user = await fetchUser(userId); const posts = await fetchUserPosts(user.id); const comments = await fetchPostComments(posts[0].id); return comments; } catch (error) { console.error(\u0026#34;Error:\u0026#34;, error); throw error; } } // Sử dụng getUserData(123).then((data) =\u0026gt; console.log(data)); Kết luận ES6+ đã thực sự thay đổi cách mình viết JavaScript:\nCode ngắn gọn và dễ đọc hơn Ít bugs hơn nhờ let/const Xử lý async code dễ dàng hơn Destructuring giúp unpack data elegantly Tips cho người mới: Học từ từ - Đừng cố gắng học tất cả một lúc Practice daily - Viết code ES6+ mỗi ngày Use Babel - Để support browser cũ Read MDN docs - Tài liệu chính thức luôn tốt nhất Các bạn đã dùng feature nào trong số này chưa? Feature nào khiến các bạn ấn tượng nhất? Share ở comment nhé!\nModern JavaScript is beautiful! 🚀✨\n","permalink":"http://localhost:1313/blog/javascript-es6+/","tags":["javascript","es6","modern-js","kinh-nghiem"],"title":"JavaScript ES6+: Những tính năng đã thay đổi cách mình code"},{"categories":null,"contents":"","permalink":"http://localhost:1313/blog/springboot-vs-nodejs/","tags":null,"title":""},{"categories":null,"contents":"Xin chào! Tôi là Tiết Thanh Minh Hiếu 👋 Câu chuyện của tôi Tôi là một sinh viên đang theo đuổi ước mơ trở thành chuyên viên An Ninh Mạng, với niềm đam mê bảo vệ thế giới số khỏi những mối đe dọa ngày càng phức tạp. Nhưng điều đặc biệt là tôi không chỉ muốn \u0026ldquo;làm\u0026rdquo; mà còn muốn \u0026ldquo;truyền cảm hứng\u0026rdquo; - mục tiêu của tôi là trở thành một giảng viên Security, người có thể biến những kiến thức phức tạp thành những bài học dễ hiểu và thú vị.\nTại sao tôi tạo blog này? Ban đầu, blog này được tạo ra để hoàn thành yêu cầu môn học về Java \u0026amp; JavaScript. Nhưng tôi nhận ra đây chính là cơ hội tuyệt vời để bắt đầu hành trình chia sẻ kiến thức mà tôi đã ấp ủ từ lâu.\nTôi tin rằng: Cách học tốt nhất là dạy lại cho người khác. Mỗi bài viết tôi chia sẻ không chỉ giúp các bạn đọc mà còn giúp tôi củng cố và mở rộng kiến thức của chính mình.\nNhững gì tôi đang làm 🔍 An Ninh Mạng Hiện tại tôi đang xây dựng nền tảng vững chắc với các chứng chỉ từ Google Cybersecurity và IBM. Kiến thức mạng cơ bản đã giúp tôi hiểu được \u0026ldquo;bức tranh lớn\u0026rdquo; của bảo mật.\n🤖 AI \u0026amp; Machine Learning Tôi có kinh nghiệm training model, đặc biệt là BERT. Dự án gần nhất của tôi là \u0026ldquo;Phát hiện mã độc Android bằng Transformer Networks (BERT)\u0026rdquo; - một project thú vị kết hợp giữa AI và Cybersecurity.\n💻 Lập trình Java và JavaScript là những ngôn ngữ tôi đang tập trung, nhưng hành trình coding của tôi không dừng lại ở đó!\nĐiều gì khiến blog này khác biệt? Không chỉ là lý thuyết khô khan. Tôi sẽ chia sẻ:\n✨ Kinh nghiệm thực tế từ các project đã làm 🎯 Cách tiếp cận thực tế thay vì chỉ đọc sách vở 🔧 Tips \u0026amp; tricks mà tôi học được qua quá trình \u0026ldquo;vấp ngã\u0026rdquo; 📚 Kiến thức được \u0026ldquo;dịch\u0026rdquo; sang ngôn ngữ dễ hiểu Mục tiêu của tôi là biến những khái niệm phức tạp thành những câu chuyện thú vị mà bất kỳ ai cũng có thể hiểu được.\nTầm nhìn tương lai Tôi mơ ước một ngày nào đó sẽ đứng trên bục giảng, truyền cảm hứng cho thế hệ các chuyên gia bảo mật tương lai. Blog này chính là bước đầu tiên trong hành trình rèn luyện kỹ năng truyền đạt của tôi.\nMỗi bài viết là một bài giảng nhỏ, mỗi chia sẻ là một lần thực hành để tôi có thể diễn đạt tốt hơn, rõ ràng hơn.\nLời kết Nếu bạn là người:\n🎓 Đang học về Cybersecurity, Java, JavaScript hoặc AI 🔍 Muốn hiểu cách áp dụng kiến thức vào thực tế 💡 Thích học thông qua kinh nghiệm thực tế hơn là lý thuyết suông Thì blog này dành cho bạn! Tôi hy vọng những chia sẻ của mình sẽ giúp ích cho hành trình học tập của các bạn, đồng thời cũng giúp tôi trở thành một người truyền đạt giỏi hơn.\nHãy cùng học, cùng phát triển và cùng tạo nên một cộng đồng tech Việt Nam mạnh mẽ! 🚀\n\u0026ldquo;The best way to learn is to teach others\u0026rdquo; - và đó chính là triết lý tôi theo đuổi trong mỗi bài viết.\n","permalink":"http://localhost:1313/about/","tags":null,"title":"Giới thiệu"},{"categories":null,"contents":"Trong lập trình mạng bằng Java, Socket là công cụ giúp kết nối giữa client và server.\nBằng cách sử dụng java.net.Socket và java.net.ServerSocket, ta có thể xây dựng các ứng dụng chat, truyền file hoặc HTTP server đơn giản.\nMô hình Client-Server cơ bản trong lập trình Socket Ở mức thấp hơn, kết nối TCP được thiết lập qua quá trình bắt tay 3 bước (TCP Handshake).\nĐiều này đảm bảo client và server đồng bộ trạng thái trước khi truyền dữ liệu.\nCơ chế bắt tay 3 bước TCP (Three-Way Handshake) ","permalink":"http://localhost:1313/blog/java-socket/","tags":["Java","Networking"],"title":"Kết nối Socket trong Java"},{"categories":["Programming"],"contents":"Chào các bạn! Hôm nay mình muốn chia sẻ về hành trình học lập trình của mình, từ Java đến JavaScript. Có lẽ nhiều bạn cũng đang băn khoăn giống mình: nên bắt đầu với ngôn ngữ nào? Học Java trước hay JavaScript trước?\nKhởi đầu với Java - Nền tảng vững chắc Mình bắt đầu với Java từ năm nhất đại học. Thật sự lúc đầu khá choáng với cú pháp dài dòng của Java:\npublic class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Hello, World!\u0026#34;); } } So với \u0026ldquo;Hello World\u0026rdquo; của JavaScript:\nconsole.log(\u0026#34;Hello, World!\u0026#34;); Wow, khác biệt quá phải không? Nhưng qua thời gian, mình nhận ra Java đã dạy mình những điều quan trọng:\n1. Tư duy hướng đối tượng (OOP) Java buộc mình phải hiểu về Class, Object, Inheritance\u0026hellip; Lúc đầu khó hiểu lắm, nhưng sau này khi làm dự án lớn mới thấy tầm quan trọng của nó.\n2. Tính nghiêm ngặt về kiểu dữ liệu int number = 10; // Phải khai báo kiểu rõ ràng String text = \u0026#34;Hello\u0026#34;; // Không thể gán số vào String 3. Cấu trúc dự án rõ ràng Package, import, access modifier\u0026hellip; tất cả đều có quy tắc rõ ràng.\nChuyển sang JavaScript - Tự do nhưng cần kỷ luật Khi bắt đầu học JavaScript, mình cảm thấy như được \u0026ldquo;giải phóng\u0026rdquo;:\nlet data = 10; // Kiểu number data = \u0026#34;Hello\u0026#34;; // Giờ thành string data = [1, 2, 3]; // Giờ thành array data = { name: \u0026#34;John\u0026#34; }; // Giờ thành object Tự do quá! Nhưng cũng dễ rối loạn không kém.\nNhững khác biệt chính mình nhận ra: Java:\nCompiled language (biên dịch trước) Strongly typed (kiểu dữ liệu nghiêm ngặt) Platform independent (chạy trên JVM) Chủ yếu cho backend JavaScript:\nInterpreted language (thông dịch) Dynamically typed (kiểu dữ liệu linh hoạt) Chạy trên browser/Node.js Full-stack (cả frontend và backend) Bài học rút ra 1. Java là nền tảng tốt để bắt đầu Nếu bạn chưa biết gì về lập trình, mình khuyên nên bắt đầu với Java. Tại sao?\nBuộc bạn phải viết code chuẩn Hiểu rõ về cấu trúc dữ liệu Tư duy logic tốt hơn 2. JavaScript cần kỷ luật bản thân Vì quá linh hoạt, JavaScript dễ làm cho code trở nên lộn xộn. Mình học được:\nĐặt tên biến có ý nghĩa Sử dụng const/let thay vì var Comment code đầy đủ 3. Cả hai đều có giá trị Java: Tốt cho hệ thống lớn, enterprise applications JavaScript: Linh hoạt, phát triển nhanh, cộng đồng active Lời kết Hành trình từ Java đến JavaScript đã dạy mình rằng không có ngôn ngữ nào là \u0026ldquo;tốt nhất\u0026rdquo;. Mỗi ngôn ngữ đều có ưu nhược điểm riêng. Quan trọng là hiểu rõ bản chất và áp dụng đúng context.\nCác bạn có kinh nghiệm gì thú vị khi học hai ngôn ngữ này không? Hãy chia sẻ trong comment nhé!\nHappy coding! 🚀\n","permalink":"http://localhost:1313/blog/java-to-javascript/","tags":["java","javascript","kinh-nghiem","hoc-tap"],"title":"Từ Java đến JavaScript: Hành trình học lập trình của mình"},{"categories":["Java"],"contents":"Xin chào các bạn! Hôm nay mình muốn chia sẻ về những sai lầm \u0026ldquo;kinh điển\u0026rdquo; mà hầu như ai học Java cũng mắc phải, bao gồm cả mình. Hy vọng qua bài viết này, các bạn newbie sẽ tránh được những \u0026ldquo;hố đen\u0026rdquo; mà mình đã rơi vào.\nSai lầm #1: Lạm dụng public static void main Mình từng làm thế này: public class Calculator { public static void main(String[] args) { // Viết tất cả logic trong main int a = 10, b = 5; int sum = a + b; int diff = a - b; int product = a * b; int quotient = a / b; System.out.println(\u0026#34;Sum: \u0026#34; + sum); System.out.println(\u0026#34;Difference: \u0026#34; + diff); // ... và còn 50 dòng code nữa } } Vấn đề: Code không thể tái sử dụng Khó debug và maintain Không theo nguyên tắc OOP Cách khắc phục: public class Calculator { public int add(int a, int b) { return a + b; } public int subtract(int a, int b) { return a - b; } public static void main(String[] args) { Calculator calc = new Calculator(); System.out.println(\u0026#34;Sum: \u0026#34; + calc.add(10, 5)); System.out.println(\u0026#34;Difference: \u0026#34; + calc.subtract(10, 5)); } } Sai lầm #2: Không hiểu về Reference vs Value Mình từng nghĩ: public class Student { String name; public static void main(String[] args) { Student s1 = new Student(); s1.name = \u0026#34;Nam\u0026#34;; Student s2 = s1; // Mình tưởng s2 là bản copy của s1 s2.name = \u0026#34;Linh\u0026#34;; System.out.println(s1.name); // Tại sao lại in ra \u0026#34;Linh\u0026#34;??? } } Bài học: Trong Java, object được truyền theo reference, không phải value. Khi gán s2 = s1, cả hai đều trỏ đến cùng một object trong memory.\nGiải pháp: public class Student implements Cloneable { String name; public Student(String name) { this.name = name; } // Constructor copy public Student(Student other) { this.name = other.name; } public static void main(String[] args) { Student s1 = new Student(\u0026#34;Nam\u0026#34;); Student s2 = new Student(s1); // Tạo object mới s2.name = \u0026#34;Linh\u0026#34;; System.out.println(s1.name); // \u0026#34;Nam\u0026#34; System.out.println(s2.name); // \u0026#34;Linh\u0026#34; } } Sai lầm #3: Không xử lý Exception đúng cách Code \u0026ldquo;tệ\u0026rdquo; của mình: public void readFile(String fileName) { try { FileReader file = new FileReader(fileName); BufferedReader reader = new BufferedReader(file); String line = reader.readLine(); System.out.println(line); } catch (Exception e) { // Im lặng, không làm gì cả - RỐT THẬM TỆ! } } Vấn đề: \u0026ldquo;Nuốt\u0026rdquo; exception mà không xử lý Sử dụng Exception quá general Không đóng resource Cách đúng: public void readFile(String fileName) { try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) { String line = reader.readLine(); if (line != null) { System.out.println(line); } } catch (FileNotFoundException e) { System.err.println(\u0026#34;Không tìm thấy file: \u0026#34; + fileName); // Log hoặc throw lại exception } catch (IOException e) { System.err.println(\u0026#34;Lỗi đọc file: \u0026#34; + e.getMessage()); } } Sai lầm #4: So sánh String bằng == Code sai: public class StringComparison { public static void main(String[] args) { String s1 = \u0026#34;Hello\u0026#34;; String s2 = new String(\u0026#34;Hello\u0026#34;); if (s1 == s2) { // SAAAIIII! System.out.println(\u0026#34;Equal\u0026#34;); } else { System.out.println(\u0026#34;Not equal\u0026#34;); // Sẽ in ra này } } } Giải thích: == so sánh reference, không phải content s1 trỏ đến String Pool s2 trỏ đến object mới trong heap Cách đúng: public class StringComparison { public static void main(String[] args) { String s1 = \u0026#34;Hello\u0026#34;; String s2 = new String(\u0026#34;Hello\u0026#34;); if (s1.equals(s2)) { // So sánh content System.out.println(\u0026#34;Equal\u0026#34;); } // Hoặc an toàn hơn với null check if (Objects.equals(s1, s2)) { System.out.println(\u0026#34;Equal and null-safe\u0026#34;); } } } Sai lầm #5: Không hiểu về Access Modifier Code của mình lúc trước: public class BankAccount { public double balance; // Ai cũng có thể truy cập! public BankAccount(double initialBalance) { balance = initialBalance; } } // Ở nơi khác BankAccount account = new BankAccount(1000); account.balance = -500; // Oops! Balance âm??? Vấn đề: Dữ liệu quan trọng không được bảo vệ Vi phạm nguyên tắc Encapsulation Cách khắc phục: public class BankAccount { private double balance; // Chỉ class này truy cập được public BankAccount(double initialBalance) { if (initialBalance \u0026gt;= 0) { this.balance = initialBalance; } else { throw new IllegalArgumentException(\u0026#34;Balance không thể âm\u0026#34;); } } public double getBalance() { return balance; } public void deposit(double amount) { if (amount \u0026gt; 0) { balance += amount; } } public boolean withdraw(double amount) { if (amount \u0026gt; 0 \u0026amp;\u0026amp; amount \u0026lt;= balance) { balance -= amount; return true; } return false; } } Tổng kết Những sai lầm này đã giúp mình hiểu sâu hơn về Java. Đừng sợ mắc lỗi, quan trọng là học hỏi từ chúng!\nTips để tránh sai lầm: Practice coding every day - Luyện tập thường xuyên Read other people\u0026rsquo;s code - Đọc code của người khác Use IDE effectively - Tận dụng IDE để catch lỗi sớm Code review - Nhờ bạn bè review code Read documentation - Đọc docs chính thức của Java Các bạn đã mắc phải sai lầm nào trong danh sách này chưa? Hoặc có sai lầm nào khác muốn chia sẻ? Comment bên dưới nhé!\nKeep learning, keep coding! ☕\n","permalink":"http://localhost:1313/blog/5-wrong-errors/","tags":["java","sai-lam","kinh-nghiem","hoc-tap"],"title":"5 Sai lầm phổ biến khi học Java mà mình đã mắc phải"},{"categories":["JavaScript"],"contents":"Chào mọi người! Khi mới học JavaScript, mình chỉ biết đến cú pháp cũ ES5. Nhưng khi tiếp xúc với ES6+ (ES2015 trở lên), thật sự mình cảm thấy như được \u0026ldquo;khai sáng\u0026rdquo;. Hôm nay mình muốn chia sẻ những tính năng ES6+ đã thay đổi hoàn toàn cách mình viết JavaScript.\n1. Let \u0026amp; Const - Tạm biệt var nhé! Cách cũ với var: // Vấn đề với var function oldWay() { for (var i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; { console.log(i); // In ra 3, 3, 3 (WTF???) }, 100); } console.log(i); // 3 - i vẫn tồn tại ngoài loop! } Cách mới với let \u0026amp; const: function newWay() { for (let i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; { console.log(i); // In ra 0, 1, 2 (chính xác!) }, 100); } // console.log(i); // ReferenceError - i không tồn tại ở đây const API_URL = \u0026#34;https://api.example.com\u0026#34;; // API_URL = \u0026#39;other-url\u0026#39;; // TypeError - không thể reassign const } Bài học: Luôn dùng const cho giá trị không thay đổi, let cho biến có thể thay đổi. Quên var đi!\n2. Arrow Functions - Code ngắn gọn hơn ES5 way: // Function expression cũ var users = [\u0026#34;Nam\u0026#34;, \u0026#34;Linh\u0026#34;, \u0026#34;Hoa\u0026#34;]; var uppercaseUsers = users.map(function (user) { return user.toUpperCase(); }); var button = document.getElementById(\u0026#34;btn\u0026#34;); button.addEventListener(\u0026#34;click\u0026#34;, function () { console.log(this); // \u0026#39;this\u0026#39; trỏ đến button }); ES6 way: // Arrow function - clean và concise const users = [\u0026#34;Nam\u0026#34;, \u0026#34;Linh\u0026#34;, \u0026#34;Hoa\u0026#34;]; const uppercaseUsers = users.map((user) =\u0026gt; user.toUpperCase()); // Với multiple parameters const add = (a, b) =\u0026gt; a + b; // Với function body const processUser = (user) =\u0026gt; { const processed = user.trim().toUpperCase(); return `Hello, ${processed}!`; }; // Lưu ý về \u0026#39;this\u0026#39; binding const obj = { name: \u0026#34;MyObject\u0026#34;, regularFunction() { console.log(this.name); // \u0026#39;MyObject\u0026#39; const arrowFunction = () =\u0026gt; { console.log(this.name); // \u0026#39;MyObject\u0026#39; - inherit từ parent scope }; arrowFunction(); }, }; Tip: Arrow function không có this binding riêng, nó inherit từ parent scope.\n3. Template Literals - Goodbye string concatenation! Cách cũ: var name = \u0026#34;Nam\u0026#34;; var age = 20; var city = \u0026#34;Ho Chi Minh\u0026#34;; var introduction = \u0026#34;Xin chào, tôi là \u0026#34; + name + \u0026#34;, \u0026#34; + age + \u0026#34; tuổi, \u0026#34; + \u0026#34;đến từ \u0026#34; + city + \u0026#34;.\u0026#34;; var htmlTemplate = \u0026#39;\u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt;\u0026#39; + \u0026#34;\u0026lt;h2\u0026gt;\u0026#34; + name + \u0026#34;\u0026lt;/h2\u0026gt;\u0026#34; + \u0026#34;\u0026lt;p\u0026gt;Age: \u0026#34; + age + \u0026#34;\u0026lt;/p\u0026gt;\u0026#34; + \u0026#34;\u0026lt;/div\u0026gt;\u0026#34;; Cách mới: const name = \u0026#34;Nam\u0026#34;; const age = 20; const city = \u0026#34;Ho Chi Minh\u0026#34;; // Template literals với backticks const introduction = `Xin chào, tôi là ${name}, ${age} tuổi, đến từ ${city}.`; // Multi-line strings dễ dàng const htmlTemplate = ` \u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;${name}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Age: ${age}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Status: ${age \u0026gt;= 18 ? \u0026#34;Adult\u0026#34; : \u0026#34;Minor\u0026#34;}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `; // Tagged template literals (advanced) function highlight(strings, ...values) { return strings.reduce((result, string, i) =\u0026gt; { const value = values[i] ? `\u0026lt;mark\u0026gt;${values[i]}\u0026lt;/mark\u0026gt;` : \u0026#34;\u0026#34;; return result + string + value; }, \u0026#34;\u0026#34;); } const highlighted = highlight`Tôi tên là ${name} và ${age} tuổi.`; 4. Destructuring - Unpack dữ liệu như ninja Array Destructuring: // Cách cũ var numbers = [1, 2, 3, 4, 5]; var first = numbers[0]; var second = numbers[1]; var rest = numbers.slice(2); // Cách mới const [first, second, ...rest] = [1, 2, 3, 4, 5]; console.log(first); // 1 console.log(second); // 2 console.log(rest); // [3, 4, 5] // Skip elements const [a, , c] = [1, 2, 3]; console.log(a, c); // 1, 3 // Default values const [x = 0, y = 0] = [1]; // x = 1, y = 0 Object Destructuring: // Cách cũ var user = { name: \u0026#34;Nam\u0026#34;, age: 20, email: \u0026#34;nam@example.com\u0026#34;, address: { city: \u0026#34;Ho Chi Minh\u0026#34;, district: \u0026#34;District 1\u0026#34;, }, }; var name = user.name; var age = user.age; var email = user.email; // Cách mới const { name, age, email } = user; // Rename variables const { name: userName, age: userAge } = user; // Nested destructuring const { address: { city, district }, } = user; // Default values const { phone = \u0026#34;N/A\u0026#34; } = user; // Function parameters destructuring function greetUser({ name, age = \u0026#34;unknown\u0026#34; }) { return `Hello ${name}, you are ${age} years old`; } greetUser({ name: \u0026#34;Nam\u0026#34;, age: 20 }); 5. Spread \u0026amp; Rest Operators - Ba chấm ma thuật Spread Operator (\u0026hellip;): // Array spreading const arr1 = [1, 2, 3]; const arr2 = [4, 5, 6]; const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6] // Object spreading const user = { name: \u0026#34;Nam\u0026#34;, age: 20 }; const updatedUser = { ...user, age: 21, city: \u0026#34;HCM\u0026#34; }; // { name: \u0026#39;Nam\u0026#39;, age: 21, city: \u0026#39;HCM\u0026#39; } // Function arguments function sum(a, b, c) { return a + b + c; } const numbers = [1, 2, 3]; console.log(sum(...numbers)); // 6 Rest Operator (\u0026hellip;): // Function parameters function logAll(first, ...others) { console.log(\u0026#34;First:\u0026#34;, first); console.log(\u0026#34;Others:\u0026#34;, others); } logAll(1, 2, 3, 4, 5); // First: 1, Others: [2, 3, 4, 5] // Array destructuring (đã thấy ở trên) const [head, ...tail] = [1, 2, 3, 4, 5]; 6. Enhanced Object Literals const name = \u0026#34;Nam\u0026#34;; const age = 20; // Cách cũ var user = { name: name, age: age, greet: function () { return \u0026#34;Hello!\u0026#34;; }, }; // Cách mới - shorthand properties const user = { name, // tương đương name: name age, // tương đương age: age // Method shorthand greet() { return \u0026#34;Hello!\u0026#34;; }, // Computed property names [`full${name}`]: `${name} Nguyen`, // Dynamic property [getPropertyName()]: \u0026#34;dynamic value\u0026#34;, }; 7. Promises \u0026amp; Async/Await - Tạm biệt Callback Hell Callback Hell: // Cách cũ - callback hell fetchUser(userId, function (user) { fetchUserPosts(user.id, function (posts) { fetchPostComments(posts[0].id, function (comments) { // Nested callbacks - khó đọc và maintain console.log(comments); }); }); }); Promises: // Promise chain fetchUser(userId) .then((user) =\u0026gt; fetchUserPosts(user.id)) .then((posts) =\u0026gt; fetchPostComments(posts[0].id)) .then((comments) =\u0026gt; console.log(comments)) .catch((error) =\u0026gt; console.error(error)); Async/Await: // Async/await - code như synchronous async function getUserData(userId) { try { const user = await fetchUser(userId); const posts = await fetchUserPosts(user.id); const comments = await fetchPostComments(posts[0].id); return comments; } catch (error) { console.error(\u0026#34;Error:\u0026#34;, error); throw error; } } // Sử dụng getUserData(123).then((data) =\u0026gt; console.log(data)); Kết luận ES6+ đã thực sự thay đổi cách mình viết JavaScript:\nCode ngắn gọn và dễ đọc hơn Ít bugs hơn nhờ let/const Xử lý async code dễ dàng hơn Destructuring giúp unpack data elegantly Tips cho người mới: Học từ từ - Đừng cố gắng học tất cả một lúc Practice daily - Viết code ES6+ mỗi ngày Use Babel - Để support browser cũ Read MDN docs - Tài liệu chính thức luôn tốt nhất Các bạn đã dùng feature nào trong số này chưa? Feature nào khiến các bạn ấn tượng nhất? Share ở comment nhé!\nModern JavaScript is beautiful! 🚀✨\n","permalink":"http://localhost:1313/blog/javascript-es6+/","tags":["javascript","es6","modern-js","kinh-nghiem"],"title":"JavaScript ES6+: Những tính năng đã thay đổi cách mình code"},{"categories":null,"contents":"","permalink":"http://localhost:1313/blog/springboot-vs-nodejs/","tags":null,"title":""},{"categories":null,"contents":"Xin chào! Tôi là Tiết Thanh Minh Hiếu 👋 Câu chuyện của tôi Tôi là một sinh viên đang theo đuổi ước mơ trở thành chuyên viên An Ninh Mạng, với niềm đam mê bảo vệ thế giới số khỏi những mối đe dọa ngày càng phức tạp. Nhưng điều đặc biệt là tôi không chỉ muốn \u0026ldquo;làm\u0026rdquo; mà còn muốn \u0026ldquo;truyền cảm hứng\u0026rdquo; - mục tiêu của tôi là trở thành một giảng viên Security, người có thể biến những kiến thức phức tạp thành những bài học dễ hiểu và thú vị.\nTại sao tôi tạo blog này? Ban đầu, blog này được tạo ra để hoàn thành yêu cầu môn học về Java \u0026amp; JavaScript. Nhưng tôi nhận ra đây chính là cơ hội tuyệt vời để bắt đầu hành trình chia sẻ kiến thức mà tôi đã ấp ủ từ lâu.\nTôi tin rằng: Cách học tốt nhất là dạy lại cho người khác. Mỗi bài viết tôi chia sẻ không chỉ giúp các bạn đọc mà còn giúp tôi củng cố và mở rộng kiến thức của chính mình.\nNhững gì tôi đang làm 🔍 An Ninh Mạng Hiện tại tôi đang xây dựng nền tảng vững chắc với các chứng chỉ từ Google Cybersecurity và IBM. Kiến thức mạng cơ bản đã giúp tôi hiểu được \u0026ldquo;bức tranh lớn\u0026rdquo; của bảo mật.\n🤖 AI \u0026amp; Machine Learning Tôi có kinh nghiệm training model, đặc biệt là BERT. Dự án gần nhất của tôi là \u0026ldquo;Phát hiện mã độc Android bằng Transformer Networks (BERT)\u0026rdquo; - một project thú vị kết hợp giữa AI và Cybersecurity.\n💻 Lập trình Java và JavaScript là những ngôn ngữ tôi đang tập trung, nhưng hành trình coding của tôi không dừng lại ở đó!\nĐiều gì khiến blog này khác biệt? Không chỉ là lý thuyết khô khan. Tôi sẽ chia sẻ:\n✨ Kinh nghiệm thực tế từ các project đã làm 🎯 Cách tiếp cận thực tế thay vì chỉ đọc sách vở 🔧 Tips \u0026amp; tricks mà tôi học được qua quá trình \u0026ldquo;vấp ngã\u0026rdquo; 📚 Kiến thức được \u0026ldquo;dịch\u0026rdquo; sang ngôn ngữ dễ hiểu Mục tiêu của tôi là biến những khái niệm phức tạp thành những câu chuyện thú vị mà bất kỳ ai cũng có thể hiểu được.\nTầm nhìn tương lai Tôi mơ ước một ngày nào đó sẽ đứng trên bục giảng, truyền cảm hứng cho thế hệ các chuyên gia bảo mật tương lai. Blog này chính là bước đầu tiên trong hành trình rèn luyện kỹ năng truyền đạt của tôi.\nMỗi bài viết là một bài giảng nhỏ, mỗi chia sẻ là một lần thực hành để tôi có thể diễn đạt tốt hơn, rõ ràng hơn.\nLời kết Nếu bạn là người:\n🎓 Đang học về Cybersecurity, Java, JavaScript hoặc AI 🔍 Muốn hiểu cách áp dụng kiến thức vào thực tế 💡 Thích học thông qua kinh nghiệm thực tế hơn là lý thuyết suông Thì blog này dành cho bạn! Tôi hy vọng những chia sẻ của mình sẽ giúp ích cho hành trình học tập của các bạn, đồng thời cũng giúp tôi trở thành một người truyền đạt giỏi hơn.\nHãy cùng học, cùng phát triển và cùng tạo nên một cộng đồng tech Việt Nam mạnh mẽ! 🚀\n\u0026ldquo;The best way to learn is to teach others\u0026rdquo; - và đó chính là triết lý tôi theo đuổi trong mỗi bài viết.\n","permalink":"http://localhost:1313/about/","tags":null,"title":"Giới thiệu"},{"categories":null,"contents":"Trong lập trình mạng bằng Java, Socket là công cụ giúp kết nối giữa client và server.\nBằng cách sử dụng java.net.Socket và java.net.ServerSocket, ta có thể xây dựng các ứng dụng chat, truyền file hoặc HTTP server đơn giản.\nMô hình Client-Server cơ bản trong lập trình Socket Ở mức thấp hơn, kết nối TCP được thiết lập qua quá trình bắt tay 3 bước (TCP Handshake).\nĐiều này đảm bảo client và server đồng bộ trạng thái trước khi truyền dữ liệu.\nCơ chế bắt tay 3 bước TCP (Three-Way Handshake) ","permalink":"http://localhost:1313/blog/java-socket/","tags":["Java","Networking"],"title":"Kết nối Socket trong Java"},{"categories":["Programming"],"contents":"Chào các bạn! Hôm nay mình muốn chia sẻ về hành trình học lập trình của mình, từ Java đến JavaScript. Có lẽ nhiều bạn cũng đang băn khoăn giống mình: nên bắt đầu với ngôn ngữ nào? Học Java trước hay JavaScript trước?\nKhởi đầu với Java - Nền tảng vững chắc Mình bắt đầu với Java từ năm nhất đại học. Thật sự lúc đầu khá choáng với cú pháp dài dòng của Java:\npublic class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Hello, World!\u0026#34;); } } So với \u0026ldquo;Hello World\u0026rdquo; của JavaScript:\nconsole.log(\u0026#34;Hello, World!\u0026#34;); Wow, khác biệt quá phải không? Nhưng qua thời gian, mình nhận ra Java đã dạy mình những điều quan trọng:\n1. Tư duy hướng đối tượng (OOP) Java buộc mình phải hiểu về Class, Object, Inheritance\u0026hellip; Lúc đầu khó hiểu lắm, nhưng sau này khi làm dự án lớn mới thấy tầm quan trọng của nó.\n2. Tính nghiêm ngặt về kiểu dữ liệu int number = 10; // Phải khai báo kiểu rõ ràng String text = \u0026#34;Hello\u0026#34;; // Không thể gán số vào String 3. Cấu trúc dự án rõ ràng Package, import, access modifier\u0026hellip; tất cả đều có quy tắc rõ ràng.\nChuyển sang JavaScript - Tự do nhưng cần kỷ luật Khi bắt đầu học JavaScript, mình cảm thấy như được \u0026ldquo;giải phóng\u0026rdquo;:\nlet data = 10; // Kiểu number data = \u0026#34;Hello\u0026#34;; // Giờ thành string data = [1, 2, 3]; // Giờ thành array data = { name: \u0026#34;John\u0026#34; }; // Giờ thành object Tự do quá! Nhưng cũng dễ rối loạn không kém.\nNhững khác biệt chính mình nhận ra: Java:\nCompiled language (biên dịch trước) Strongly typed (kiểu dữ liệu nghiêm ngặt) Platform independent (chạy trên JVM) Chủ yếu cho backend JavaScript:\nInterpreted language (thông dịch) Dynamically typed (kiểu dữ liệu linh hoạt) Chạy trên browser/Node.js Full-stack (cả frontend và backend) Bài học rút ra 1. Java là nền tảng tốt để bắt đầu Nếu bạn chưa biết gì về lập trình, mình khuyên nên bắt đầu với Java. Tại sao?\nBuộc bạn phải viết code chuẩn Hiểu rõ về cấu trúc dữ liệu Tư duy logic tốt hơn 2. JavaScript cần kỷ luật bản thân Vì quá linh hoạt, JavaScript dễ làm cho code trở nên lộn xộn. Mình học được:\nĐặt tên biến có ý nghĩa Sử dụng const/let thay vì var Comment code đầy đủ 3. Cả hai đều có giá trị Java: Tốt cho hệ thống lớn, enterprise applications JavaScript: Linh hoạt, phát triển nhanh, cộng đồng active Lời kết Hành trình từ Java đến JavaScript đã dạy mình rằng không có ngôn ngữ nào là \u0026ldquo;tốt nhất\u0026rdquo;. Mỗi ngôn ngữ đều có ưu nhược điểm riêng. Quan trọng là hiểu rõ bản chất và áp dụng đúng context.\nCác bạn có kinh nghiệm gì thú vị khi học hai ngôn ngữ này không? Hãy chia sẻ trong comment nhé!\nHappy coding! 🚀\n","permalink":"http://localhost:1313/blog/java-to-javascript/","tags":["java","javascript","kinh-nghiem","hoc-tap"],"title":"Từ Java đến JavaScript: Hành trình học lập trình của mình"},{"categories":["Java"],"contents":"Xin chào các bạn! Hôm nay mình muốn chia sẻ về những sai lầm \u0026ldquo;kinh điển\u0026rdquo; mà hầu như ai học Java cũng mắc phải, bao gồm cả mình. Hy vọng qua bài viết này, các bạn newbie sẽ tránh được những \u0026ldquo;hố đen\u0026rdquo; mà mình đã rơi vào.\nSai lầm #1: Lạm dụng public static void main Mình từng làm thế này: public class Calculator { public static void main(String[] args) { // Viết tất cả logic trong main int a = 10, b = 5; int sum = a + b; int diff = a - b; int product = a * b; int quotient = a / b; System.out.println(\u0026#34;Sum: \u0026#34; + sum); System.out.println(\u0026#34;Difference: \u0026#34; + diff); // ... và còn 50 dòng code nữa } } Vấn đề: Code không thể tái sử dụng Khó debug và maintain Không theo nguyên tắc OOP Cách khắc phục: public class Calculator { public int add(int a, int b) { return a + b; } public int subtract(int a, int b) { return a - b; } public static void main(String[] args) { Calculator calc = new Calculator(); System.out.println(\u0026#34;Sum: \u0026#34; + calc.add(10, 5)); System.out.println(\u0026#34;Difference: \u0026#34; + calc.subtract(10, 5)); } } Sai lầm #2: Không hiểu về Reference vs Value Mình từng nghĩ: public class Student { String name; public static void main(String[] args) { Student s1 = new Student(); s1.name = \u0026#34;Nam\u0026#34;; Student s2 = s1; // Mình tưởng s2 là bản copy của s1 s2.name = \u0026#34;Linh\u0026#34;; System.out.println(s1.name); // Tại sao lại in ra \u0026#34;Linh\u0026#34;??? } } Bài học: Trong Java, object được truyền theo reference, không phải value. Khi gán s2 = s1, cả hai đều trỏ đến cùng một object trong memory.\nGiải pháp: public class Student implements Cloneable { String name; public Student(String name) { this.name = name; } // Constructor copy public Student(Student other) { this.name = other.name; } public static void main(String[] args) { Student s1 = new Student(\u0026#34;Nam\u0026#34;); Student s2 = new Student(s1); // Tạo object mới s2.name = \u0026#34;Linh\u0026#34;; System.out.println(s1.name); // \u0026#34;Nam\u0026#34; System.out.println(s2.name); // \u0026#34;Linh\u0026#34; } } Sai lầm #3: Không xử lý Exception đúng cách Code \u0026ldquo;tệ\u0026rdquo; của mình: public void readFile(String fileName) { try { FileReader file = new FileReader(fileName); BufferedReader reader = new BufferedReader(file); String line = reader.readLine(); System.out.println(line); } catch (Exception e) { // Im lặng, không làm gì cả - RỐT THẬM TỆ! } } Vấn đề: \u0026ldquo;Nuốt\u0026rdquo; exception mà không xử lý Sử dụng Exception quá general Không đóng resource Cách đúng: public void readFile(String fileName) { try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) { String line = reader.readLine(); if (line != null) { System.out.println(line); } } catch (FileNotFoundException e) { System.err.println(\u0026#34;Không tìm thấy file: \u0026#34; + fileName); // Log hoặc throw lại exception } catch (IOException e) { System.err.println(\u0026#34;Lỗi đọc file: \u0026#34; + e.getMessage()); } } Sai lầm #4: So sánh String bằng == Code sai: public class StringComparison { public static void main(String[] args) { String s1 = \u0026#34;Hello\u0026#34;; String s2 = new String(\u0026#34;Hello\u0026#34;); if (s1 == s2) { // SAAAIIII! System.out.println(\u0026#34;Equal\u0026#34;); } else { System.out.println(\u0026#34;Not equal\u0026#34;); // Sẽ in ra này } } } Giải thích: == so sánh reference, không phải content s1 trỏ đến String Pool s2 trỏ đến object mới trong heap Cách đúng: public class StringComparison { public static void main(String[] args) { String s1 = \u0026#34;Hello\u0026#34;; String s2 = new String(\u0026#34;Hello\u0026#34;); if (s1.equals(s2)) { // So sánh content System.out.println(\u0026#34;Equal\u0026#34;); } // Hoặc an toàn hơn với null check if (Objects.equals(s1, s2)) { System.out.println(\u0026#34;Equal and null-safe\u0026#34;); } } } Sai lầm #5: Không hiểu về Access Modifier Code của mình lúc trước: public class BankAccount { public double balance; // Ai cũng có thể truy cập! public BankAccount(double initialBalance) { balance = initialBalance; } } // Ở nơi khác BankAccount account = new BankAccount(1000); account.balance = -500; // Oops! Balance âm??? Vấn đề: Dữ liệu quan trọng không được bảo vệ Vi phạm nguyên tắc Encapsulation Cách khắc phục: public class BankAccount { private double balance; // Chỉ class này truy cập được public BankAccount(double initialBalance) { if (initialBalance \u0026gt;= 0) { this.balance = initialBalance; } else { throw new IllegalArgumentException(\u0026#34;Balance không thể âm\u0026#34;); } } public double getBalance() { return balance; } public void deposit(double amount) { if (amount \u0026gt; 0) { balance += amount; } } public boolean withdraw(double amount) { if (amount \u0026gt; 0 \u0026amp;\u0026amp; amount \u0026lt;= balance) { balance -= amount; return true; } return false; } } Tổng kết Những sai lầm này đã giúp mình hiểu sâu hơn về Java. Đừng sợ mắc lỗi, quan trọng là học hỏi từ chúng!\nTips để tránh sai lầm: Practice coding every day - Luyện tập thường xuyên Read other people\u0026rsquo;s code - Đọc code của người khác Use IDE effectively - Tận dụng IDE để catch lỗi sớm Code review - Nhờ bạn bè review code Read documentation - Đọc docs chính thức của Java Các bạn đã mắc phải sai lầm nào trong danh sách này chưa? Hoặc có sai lầm nào khác muốn chia sẻ? Comment bên dưới nhé!\nKeep learning, keep coding! ☕\n","permalink":"http://localhost:1313/blog/5-wrong-errors/","tags":["java","sai-lam","kinh-nghiem","hoc-tap"],"title":"5 Sai lầm phổ biến khi học Java mà mình đã mắc phải"},{"categories":["Backend Development"],"contents":"Xin chào các bạn! Sau khi học cả Java và JavaScript, mình có cơ hội làm việc với cả Spring Boot và Node.js trong các dự án thực tế. Hôm nay mình muốn chia sẻ trải nghiệm của mình khi develop backend với hai platform này.\nDự án đầu tiên với Spring Boot 🍃 Setup ban đầu Khi mới bắt đầu với Spring Boot, mình cảm thấy hơi choáng với số lượng config:\n// Application.java @SpringBootApplication public class BlogApplication { public static void main(String[] args) { SpringApplication.run(BlogApplication.class, args); } } // User.java - JPA Entity @Entity @Table(name = \u0026#34;users\u0026#34;) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, unique = true) private String email; @Column(nullable = false) private String password; // Constructor, getters, setters... } // UserRepository.java @Repository public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt; { Optional\u0026lt;User\u0026gt; findByEmail(String email); } // UserController.java @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) public class UserController { @Autowired private UserService userService; @PostMapping public ResponseEntity\u0026lt;User\u0026gt; createUser(@Valid @RequestBody UserDTO userDTO) { User user = userService.createUser(userDTO); return ResponseEntity.status(HttpStatus.CREATED).body(user); } } Những điều mình thích ở Spring Boot: Convention over Configuration - Ít config hơn Spring truyền thống Dependency Injection - Auto-wiring cực kỳ mạnh mẽ JPA/Hibernate - ORM mạnh mẽ, query phức tạp dễ dàng Security - Spring Security handle authentication/authorization tốt Testing - Test infrastructure rất complete Những khó khăn: Learning curve - Cần hiểu về Spring ecosystem Memory usage - JVM khá \u0026ldquo;nặng\u0026rdquo; Startup time - Khởi động chậm hơn Node.js Annotation hell - Quá nhiều annotation có thể confusing Chuyển sang Node.js - Một thế giới khác 🚀 Express.js setup // app.js const express = require(\u0026#34;express\u0026#34;); const mongoose = require(\u0026#34;mongoose\u0026#34;); const bcrypt = require(\u0026#34;bcryptjs\u0026#34;); const jwt = require(\u0026#34;jsonwebtoken\u0026#34;); const app = express(); app.use(express.json()); // User Model với Mongoose const userSchema = new mongoose.Schema({ email: { type: String, required: true, unique: true }, password: { type: String, required: true }, createdAt: { type: Date, default: Date.now }, }); const User = mongoose.model(\u0026#34;User\u0026#34;, userSchema); // User Routes app.post(\u0026#34;/api/users\u0026#34;, async (req, res) =\u0026gt; { try { const { email, password } = req.body; const existingUser = await User.findOne({ email }); if (existingUser) { return res.status(400).json({ message: \u0026#34;User already exists\u0026#34; }); } const hashedPassword = await bcrypt.hash(password, 10); const user = new User({ email, password: hashedPassword }); await user.save(); res.status(201).json({ id: user._id, email: user.email }); } catch (error) { res.status(500).json({ message: error.message }); } }); // Connect to MongoDB mongoose .connect(\u0026#34;mongodb://localhost:27017/myapp\u0026#34;) .then(() =\u0026gt; console.log(\u0026#34;Connected to MongoDB\u0026#34;)) .catch((err) =\u0026gt; console.error(\u0026#34;MongoDB connection error:\u0026#34;, err)); app.listen(3000, () =\u0026gt; { console.log(\u0026#34;Server running on port 3000\u0026#34;); }); Những điều mình thích ở Node.js: Fast development - Viết code nhanh, setup đơn giản JavaScript everywhere - Same language frontend/backend NPM ecosystem - Package có sẵn cho mọi thứ Lightweight - Memory footprint nhỏ hơn JVM Fast startup - Server khởi động trong giây lát Những thách thức: Callback/Promise hell - Nếu không handle tốt async code Single-threaded - CPU-intensive tasks có thể block Type safety - JavaScript dynamic typing đôi khi gây bugs Package management - Dependency hell với npm So sánh thực tế qua dự án Dự án E-commerce Platform Mình đã implement cùng một API cho hệ thống e-commerce với cả hai technologies:\nPerformance Test Results: Concurrent Users: 1000\rTest Duration: 5 minutes\rSpring Boot (Java 17 + PostgreSQL):\r- Average Response Time: 45ms\r- Throughput: 2,200 req/sec\r- Memory Usage: 512MB\r- CPU Usage: 35%\rNode.js (Express + MongoDB):\r- Average Response Time: 38ms\r- Throughput: 2,800 req/sec\r- Memory Usage: 128MB\r- CPU Usage: 28% Development Speed: Spring Boot:\nSetup time: 30 phút (config database, dependencies) CRUD operations: 2 giờ Authentication: 1 giờ (Spring Security) Unit tests: 1.5 giờ Total: ~5 giờ Node.js:\nSetup time: 10 phút CRUD operations: 1 giờ Authentication: 1.5 giờ (custom JWT) Unit tests: 1 giờ Total: ~3.5 giờ Khi nào dùng gì? Chọn Spring Boot khi: ✅ Enterprise applications - Cần security, scalability cao\n✅ Complex business logic - Nhiều rules phức tạp\n✅ Team lớn - Structure rõ ràng, maintainable\n✅ Legacy systems - Integration với Java ecosystem\n✅ Microservices - Spring Cloud ecosystem mạnh\n// Example: Complex business logic dễ handle với Java @Service @Transactional public class OrderService { public Order processOrder(OrderRequest request) { // Validate inventory inventoryService.checkAvailability(request.getItems()); // Apply discounts BigDecimal finalAmount = pricingService .calculateDiscount(request, customer.getTier()); // Process payment PaymentResult payment = paymentService .processPayment(customer.getPaymentMethod(), finalAmount); if (payment.isSuccessful()) { // Create order Order order = orderRepository.save( Order.builder() .customerId(customer.getId()) .amount(finalAmount) .status(OrderStatus.CONFIRMED) .build() ); // Send notifications notificationService.sendOrderConfirmation(order); return order; } throw new PaymentProcessingException(\u0026#34;Payment failed\u0026#34;); } } Chọn Node.js khi: ✅ Rapid prototyping - Cần develop nhanh\n✅ Real-time apps - Chat, live updates (Socket.io)\n✅ API-first approach - RESTful APIs đơn giản\n✅ Startup/Small team - Ít developers, cần flexibility\n✅ I/O intensive - Nhiều database calls, external APIs\n// Example: Real-time chat với Socket.io const io = require(\u0026#34;socket.io\u0026#34;)(server); io.on(\u0026#34;connection\u0026#34;, (socket) =\u0026gt; { console.log(\u0026#34;User connected:\u0026#34;, socket.id); socket.on(\u0026#34;join-room\u0026#34;, (roomId) =\u0026gt; { socket.join(roomId); socket.to(roomId).emit(\u0026#34;user-joined\u0026#34;, socket.id); }); socket.on(\u0026#34;message\u0026#34;, async (data) =\u0026gt; { // Save to database const message = await Message.create({ content: data.message, userId: data.userId, roomId: data.roomId, }); // Broadcast to room io.to(data.roomId).emit(\u0026#34;new-message\u0026#34;, message); }); socket.on(\u0026#34;disconnect\u0026#34;, () =\u0026gt; { console.log(\u0026#34;User disconnected:\u0026#34;, socket.id); }); }); Lessons Learned 1. Không có \u0026ldquo;silver bullet\u0026rdquo; Cả hai đều có ưu nhược điểm. Quan trọng là chọn tool phù hợp với requirements.\n2. Team skill matter Team giỏi Java → Spring Boot sẽ productive hơn Team frontend developers → Node.js dễ tiếp cận hơn 3. Maintenance is key Spring Boot có structure rõ ràng hơn cho long-term projects.\n4. Performance isn\u0026rsquo;t everything Developer productivity và time-to-market cũng quan trọng.\nKết luận Sau kinh nghiệm với cả hai, mình nhận ra:\nSpring Boot giống như một chiếc Mercedes - robust, reliable, powerful nhưng cần thời gian để master.\nNode.js giống như một chiếc motorbike - agile, fast, flexible nhưng cần cẩn thận khi handle complex scenarios.\nHiện tại mình đang sử dụng:\nSpring Boot cho enterprise projects, complex business logic Node.js cho prototypes, real-time features, simple APIs Các bạn có kinh nghiệm gì với hai platform này? Share ở comment nhé!\nChoose the right tool for the job! 🛠️\n","permalink":"http://localhost:1313/blog/springboot-vs-nodejs/","tags":["java","javascript","spring-boot","nodejs","backend"],"title":"Spring Boot vs Node.js: Trải nghiệm backend development của mình"},{"categories":["JavaScript"],"contents":"Chào mọi người! Khi mới học JavaScript, mình chỉ biết đến cú pháp cũ ES5. Nhưng khi tiếp xúc với ES6+ (ES2015 trở lên), thật sự mình cảm thấy như được \u0026ldquo;khai sáng\u0026rdquo;. Hôm nay mình muốn chia sẻ những tính năng ES6+ đã thay đổi hoàn toàn cách mình viết JavaScript.\n1. Let \u0026amp; Const - Tạm biệt var nhé! Cách cũ với var: // Vấn đề với var function oldWay() { for (var i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; { console.log(i); // In ra 3, 3, 3 (WTF???) }, 100); } console.log(i); // 3 - i vẫn tồn tại ngoài loop! } Cách mới với let \u0026amp; const: function newWay() { for (let i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; { console.log(i); // In ra 0, 1, 2 (chính xác!) }, 100); } // console.log(i); // ReferenceError - i không tồn tại ở đây const API_URL = \u0026#34;https://api.example.com\u0026#34;; // API_URL = \u0026#39;other-url\u0026#39;; // TypeError - không thể reassign const } Bài học: Luôn dùng const cho giá trị không thay đổi, let cho biến có thể thay đổi. Quên var đi!\n2. Arrow Functions - Code ngắn gọn hơn ES5 way: // Function expression cũ var users = [\u0026#34;Nam\u0026#34;, \u0026#34;Linh\u0026#34;, \u0026#34;Hoa\u0026#34;]; var uppercaseUsers = users.map(function (user) { return user.toUpperCase(); }); var button = document.getElementById(\u0026#34;btn\u0026#34;); button.addEventListener(\u0026#34;click\u0026#34;, function () { console.log(this); // \u0026#39;this\u0026#39; trỏ đến button }); ES6 way: // Arrow function - clean và concise const users = [\u0026#34;Nam\u0026#34;, \u0026#34;Linh\u0026#34;, \u0026#34;Hoa\u0026#34;]; const uppercaseUsers = users.map((user) =\u0026gt; user.toUpperCase()); // Với multiple parameters const add = (a, b) =\u0026gt; a + b; // Với function body const processUser = (user) =\u0026gt; { const processed = user.trim().toUpperCase(); return `Hello, ${processed}!`; }; // Lưu ý về \u0026#39;this\u0026#39; binding const obj = { name: \u0026#34;MyObject\u0026#34;, regularFunction() { console.log(this.name); // \u0026#39;MyObject\u0026#39; const arrowFunction = () =\u0026gt; { console.log(this.name); // \u0026#39;MyObject\u0026#39; - inherit từ parent scope }; arrowFunction(); }, }; Tip: Arrow function không có this binding riêng, nó inherit từ parent scope.\n3. Template Literals - Goodbye string concatenation! Cách cũ: var name = \u0026#34;Nam\u0026#34;; var age = 20; var city = \u0026#34;Ho Chi Minh\u0026#34;; var introduction = \u0026#34;Xin chào, tôi là \u0026#34; + name + \u0026#34;, \u0026#34; + age + \u0026#34; tuổi, \u0026#34; + \u0026#34;đến từ \u0026#34; + city + \u0026#34;.\u0026#34;; var htmlTemplate = \u0026#39;\u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt;\u0026#39; + \u0026#34;\u0026lt;h2\u0026gt;\u0026#34; + name + \u0026#34;\u0026lt;/h2\u0026gt;\u0026#34; + \u0026#34;\u0026lt;p\u0026gt;Age: \u0026#34; + age + \u0026#34;\u0026lt;/p\u0026gt;\u0026#34; + \u0026#34;\u0026lt;/div\u0026gt;\u0026#34;; Cách mới: const name = \u0026#34;Nam\u0026#34;; const age = 20; const city = \u0026#34;Ho Chi Minh\u0026#34;; // Template literals với backticks const introduction = `Xin chào, tôi là ${name}, ${age} tuổi, đến từ ${city}.`; // Multi-line strings dễ dàng const htmlTemplate = ` \u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;${name}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Age: ${age}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Status: ${age \u0026gt;= 18 ? \u0026#34;Adult\u0026#34; : \u0026#34;Minor\u0026#34;}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `; // Tagged template literals (advanced) function highlight(strings, ...values) { return strings.reduce((result, string, i) =\u0026gt; { const value = values[i] ? `\u0026lt;mark\u0026gt;${values[i]}\u0026lt;/mark\u0026gt;` : \u0026#34;\u0026#34;; return result + string + value; }, \u0026#34;\u0026#34;); } const highlighted = highlight`Tôi tên là ${name} và ${age} tuổi.`; 4. Destructuring - Unpack dữ liệu như ninja Array Destructuring: // Cách cũ var numbers = [1, 2, 3, 4, 5]; var first = numbers[0]; var second = numbers[1]; var rest = numbers.slice(2); // Cách mới const [first, second, ...rest] = [1, 2, 3, 4, 5]; console.log(first); // 1 console.log(second); // 2 console.log(rest); // [3, 4, 5] // Skip elements const [a, , c] = [1, 2, 3]; console.log(a, c); // 1, 3 // Default values const [x = 0, y = 0] = [1]; // x = 1, y = 0 Object Destructuring: // Cách cũ var user = { name: \u0026#34;Nam\u0026#34;, age: 20, email: \u0026#34;nam@example.com\u0026#34;, address: { city: \u0026#34;Ho Chi Minh\u0026#34;, district: \u0026#34;District 1\u0026#34;, }, }; var name = user.name; var age = user.age; var email = user.email; // Cách mới const { name, age, email } = user; // Rename variables const { name: userName, age: userAge } = user; // Nested destructuring const { address: { city, district }, } = user; // Default values const { phone = \u0026#34;N/A\u0026#34; } = user; // Function parameters destructuring function greetUser({ name, age = \u0026#34;unknown\u0026#34; }) { return `Hello ${name}, you are ${age} years old`; } greetUser({ name: \u0026#34;Nam\u0026#34;, age: 20 }); 5. Spread \u0026amp; Rest Operators - Ba chấm ma thuật Spread Operator (\u0026hellip;): // Array spreading const arr1 = [1, 2, 3]; const arr2 = [4, 5, 6]; const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6] // Object spreading const user = { name: \u0026#34;Nam\u0026#34;, age: 20 }; const updatedUser = { ...user, age: 21, city: \u0026#34;HCM\u0026#34; }; // { name: \u0026#39;Nam\u0026#39;, age: 21, city: \u0026#39;HCM\u0026#39; } // Function arguments function sum(a, b, c) { return a + b + c; } const numbers = [1, 2, 3]; console.log(sum(...numbers)); // 6 Rest Operator (\u0026hellip;): // Function parameters function logAll(first, ...others) { console.log(\u0026#34;First:\u0026#34;, first); console.log(\u0026#34;Others:\u0026#34;, others); } logAll(1, 2, 3, 4, 5); // First: 1, Others: [2, 3, 4, 5] // Array destructuring (đã thấy ở trên) const [head, ...tail] = [1, 2, 3, 4, 5]; 6. Enhanced Object Literals const name = \u0026#34;Nam\u0026#34;; const age = 20; // Cách cũ var user = { name: name, age: age, greet: function () { return \u0026#34;Hello!\u0026#34;; }, }; // Cách mới - shorthand properties const user = { name, // tương đương name: name age, // tương đương age: age // Method shorthand greet() { return \u0026#34;Hello!\u0026#34;; }, // Computed property names [`full${name}`]: `${name} Nguyen`, // Dynamic property [getPropertyName()]: \u0026#34;dynamic value\u0026#34;, }; 7. Promises \u0026amp; Async/Await - Tạm biệt Callback Hell Callback Hell: // Cách cũ - callback hell fetchUser(userId, function (user) { fetchUserPosts(user.id, function (posts) { fetchPostComments(posts[0].id, function (comments) { // Nested callbacks - khó đọc và maintain console.log(comments); }); }); }); Promises: // Promise chain fetchUser(userId) .then((user) =\u0026gt; fetchUserPosts(user.id)) .then((posts) =\u0026gt; fetchPostComments(posts[0].id)) .then((comments) =\u0026gt; console.log(comments)) .catch((error) =\u0026gt; console.error(error)); Async/Await: // Async/await - code như synchronous async function getUserData(userId) { try { const user = await fetchUser(userId); const posts = await fetchUserPosts(user.id); const comments = await fetchPostComments(posts[0].id); return comments; } catch (error) { console.error(\u0026#34;Error:\u0026#34;, error); throw error; } } // Sử dụng getUserData(123).then((data) =\u0026gt; console.log(data)); Kết luận ES6+ đã thực sự thay đổi cách mình viết JavaScript:\nCode ngắn gọn và dễ đọc hơn Ít bugs hơn nhờ let/const Xử lý async code dễ dàng hơn Destructuring giúp unpack data elegantly Tips cho người mới: Học từ từ - Đừng cố gắng học tất cả một lúc Practice daily - Viết code ES6+ mỗi ngày Use Babel - Để support browser cũ Read MDN docs - Tài liệu chính thức luôn tốt nhất Các bạn đã dùng feature nào trong số này chưa? Feature nào khiến các bạn ấn tượng nhất? Share ở comment nhé!\nModern JavaScript is beautiful! 🚀✨\n","permalink":"http://localhost:1313/blog/javascript-es6+/","tags":["javascript","es6","modern-js","kinh-nghiem"],"title":"JavaScript ES6+: Những tính năng đã thay đổi cách mình code"},{"categories":null,"contents":"Xin chào! Tôi là Tiết Thanh Minh Hiếu 👋 Câu chuyện của tôi Tôi là một sinh viên đang theo đuổi ước mơ trở thành chuyên viên An Ninh Mạng, với niềm đam mê bảo vệ thế giới số khỏi những mối đe dọa ngày càng phức tạp. Nhưng điều đặc biệt là tôi không chỉ muốn \u0026ldquo;làm\u0026rdquo; mà còn muốn \u0026ldquo;truyền cảm hứng\u0026rdquo; - mục tiêu của tôi là trở thành một giảng viên Security, người có thể biến những kiến thức phức tạp thành những bài học dễ hiểu và thú vị.\nTại sao tôi tạo blog này? Ban đầu, blog này được tạo ra để hoàn thành yêu cầu môn học về Java \u0026amp; JavaScript. Nhưng tôi nhận ra đây chính là cơ hội tuyệt vời để bắt đầu hành trình chia sẻ kiến thức mà tôi đã ấp ủ từ lâu.\nTôi tin rằng: Cách học tốt nhất là dạy lại cho người khác. Mỗi bài viết tôi chia sẻ không chỉ giúp các bạn đọc mà còn giúp tôi củng cố và mở rộng kiến thức của chính mình.\nNhững gì tôi đang làm 🔍 An Ninh Mạng Hiện tại tôi đang xây dựng nền tảng vững chắc với các chứng chỉ từ Google Cybersecurity và IBM. Kiến thức mạng cơ bản đã giúp tôi hiểu được \u0026ldquo;bức tranh lớn\u0026rdquo; của bảo mật.\n🤖 AI \u0026amp; Machine Learning Tôi có kinh nghiệm training model, đặc biệt là BERT. Dự án gần nhất của tôi là \u0026ldquo;Phát hiện mã độc Android bằng Transformer Networks (BERT)\u0026rdquo; - một project thú vị kết hợp giữa AI và Cybersecurity.\n💻 Lập trình Java và JavaScript là những ngôn ngữ tôi đang tập trung, nhưng hành trình coding của tôi không dừng lại ở đó!\nĐiều gì khiến blog này khác biệt? Không chỉ là lý thuyết khô khan. Tôi sẽ chia sẻ:\n✨ Kinh nghiệm thực tế từ các project đã làm 🎯 Cách tiếp cận thực tế thay vì chỉ đọc sách vở 🔧 Tips \u0026amp; tricks mà tôi học được qua quá trình \u0026ldquo;vấp ngã\u0026rdquo; 📚 Kiến thức được \u0026ldquo;dịch\u0026rdquo; sang ngôn ngữ dễ hiểu Mục tiêu của tôi là biến những khái niệm phức tạp thành những câu chuyện thú vị mà bất kỳ ai cũng có thể hiểu được.\nTầm nhìn tương lai Tôi mơ ước một ngày nào đó sẽ đứng trên bục giảng, truyền cảm hứng cho thế hệ các chuyên gia bảo mật tương lai. Blog này chính là bước đầu tiên trong hành trình rèn luyện kỹ năng truyền đạt của tôi.\nMỗi bài viết là một bài giảng nhỏ, mỗi chia sẻ là một lần thực hành để tôi có thể diễn đạt tốt hơn, rõ ràng hơn.\nLời kết Nếu bạn là người:\n🎓 Đang học về Cybersecurity, Java, JavaScript hoặc AI 🔍 Muốn hiểu cách áp dụng kiến thức vào thực tế 💡 Thích học thông qua kinh nghiệm thực tế hơn là lý thuyết suông Thì blog này dành cho bạn! Tôi hy vọng những chia sẻ của mình sẽ giúp ích cho hành trình học tập của các bạn, đồng thời cũng giúp tôi trở thành một người truyền đạt giỏi hơn.\nHãy cùng học, cùng phát triển và cùng tạo nên một cộng đồng tech Việt Nam mạnh mẽ! 🚀\n\u0026ldquo;The best way to learn is to teach others\u0026rdquo; - và đó chính là triết lý tôi theo đuổi trong mỗi bài viết.\n","permalink":"http://localhost:1313/about/","tags":null,"title":"Giới thiệu"},{"categories":null,"contents":"Trong lập trình mạng bằng Java, Socket là công cụ giúp kết nối giữa client và server.\nBằng cách sử dụng java.net.Socket và java.net.ServerSocket, ta có thể xây dựng các ứng dụng chat, truyền file hoặc HTTP server đơn giản.\nMô hình Client-Server cơ bản trong lập trình Socket Ở mức thấp hơn, kết nối TCP được thiết lập qua quá trình bắt tay 3 bước (TCP Handshake).\nĐiều này đảm bảo client và server đồng bộ trạng thái trước khi truyền dữ liệu.\nCơ chế bắt tay 3 bước TCP (Three-Way Handshake) ","permalink":"http://localhost:1313/blog/java-socket/","tags":["Java","Networking"],"title":"Kết nối Socket trong Java"},{"categories":["Programming"],"contents":"Chào các bạn! Hôm nay mình muốn chia sẻ về hành trình học lập trình của mình, từ Java đến JavaScript. Có lẽ nhiều bạn cũng đang băn khoăn giống mình: nên bắt đầu với ngôn ngữ nào? Học Java trước hay JavaScript trước?\nKhởi đầu với Java - Nền tảng vững chắc Mình bắt đầu với Java từ năm nhất đại học. Thật sự lúc đầu khá choáng với cú pháp dài dòng của Java:\npublic class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Hello, World!\u0026#34;); } } So với \u0026ldquo;Hello World\u0026rdquo; của JavaScript:\nconsole.log(\u0026#34;Hello, World!\u0026#34;); Wow, khác biệt quá phải không? Nhưng qua thời gian, mình nhận ra Java đã dạy mình những điều quan trọng:\n1. Tư duy hướng đối tượng (OOP) Java buộc mình phải hiểu về Class, Object, Inheritance\u0026hellip; Lúc đầu khó hiểu lắm, nhưng sau này khi làm dự án lớn mới thấy tầm quan trọng của nó.\n2. Tính nghiêm ngặt về kiểu dữ liệu int number = 10; // Phải khai báo kiểu rõ ràng String text = \u0026#34;Hello\u0026#34;; // Không thể gán số vào String 3. Cấu trúc dự án rõ ràng Package, import, access modifier\u0026hellip; tất cả đều có quy tắc rõ ràng.\nChuyển sang JavaScript - Tự do nhưng cần kỷ luật Khi bắt đầu học JavaScript, mình cảm thấy như được \u0026ldquo;giải phóng\u0026rdquo;:\nlet data = 10; // Kiểu number data = \u0026#34;Hello\u0026#34;; // Giờ thành string data = [1, 2, 3]; // Giờ thành array data = { name: \u0026#34;John\u0026#34; }; // Giờ thành object Tự do quá! Nhưng cũng dễ rối loạn không kém.\nNhững khác biệt chính mình nhận ra: Java:\nCompiled language (biên dịch trước) Strongly typed (kiểu dữ liệu nghiêm ngặt) Platform independent (chạy trên JVM) Chủ yếu cho backend JavaScript:\nInterpreted language (thông dịch) Dynamically typed (kiểu dữ liệu linh hoạt) Chạy trên browser/Node.js Full-stack (cả frontend và backend) Bài học rút ra 1. Java là nền tảng tốt để bắt đầu Nếu bạn chưa biết gì về lập trình, mình khuyên nên bắt đầu với Java. Tại sao?\nBuộc bạn phải viết code chuẩn Hiểu rõ về cấu trúc dữ liệu Tư duy logic tốt hơn 2. JavaScript cần kỷ luật bản thân Vì quá linh hoạt, JavaScript dễ làm cho code trở nên lộn xộn. Mình học được:\nĐặt tên biến có ý nghĩa Sử dụng const/let thay vì var Comment code đầy đủ 3. Cả hai đều có giá trị Java: Tốt cho hệ thống lớn, enterprise applications JavaScript: Linh hoạt, phát triển nhanh, cộng đồng active Lời kết Hành trình từ Java đến JavaScript đã dạy mình rằng không có ngôn ngữ nào là \u0026ldquo;tốt nhất\u0026rdquo;. Mỗi ngôn ngữ đều có ưu nhược điểm riêng. Quan trọng là hiểu rõ bản chất và áp dụng đúng context.\nCác bạn có kinh nghiệm gì thú vị khi học hai ngôn ngữ này không? Hãy chia sẻ trong comment nhé!\nHappy coding! 🚀\n","permalink":"http://localhost:1313/blog/java-to-javascript/","tags":["java","javascript","kinh-nghiem","hoc-tap"],"title":"Từ Java đến JavaScript: Hành trình học lập trình của mình"},{"categories":["Java"],"contents":"Xin chào các bạn! Hôm nay mình muốn chia sẻ về những sai lầm \u0026ldquo;kinh điển\u0026rdquo; mà hầu như ai học Java cũng mắc phải, bao gồm cả mình. Hy vọng qua bài viết này, các bạn newbie sẽ tránh được những \u0026ldquo;hố đen\u0026rdquo; mà mình đã rơi vào.\nSai lầm #1: Lạm dụng public static void main Mình từng làm thế này: public class Calculator { public static void main(String[] args) { // Viết tất cả logic trong main int a = 10, b = 5; int sum = a + b; int diff = a - b; int product = a * b; int quotient = a / b; System.out.println(\u0026#34;Sum: \u0026#34; + sum); System.out.println(\u0026#34;Difference: \u0026#34; + diff); // ... và còn 50 dòng code nữa } } Vấn đề: Code không thể tái sử dụng Khó debug và maintain Không theo nguyên tắc OOP Cách khắc phục: public class Calculator { public int add(int a, int b) { return a + b; } public int subtract(int a, int b) { return a - b; } public static void main(String[] args) { Calculator calc = new Calculator(); System.out.println(\u0026#34;Sum: \u0026#34; + calc.add(10, 5)); System.out.println(\u0026#34;Difference: \u0026#34; + calc.subtract(10, 5)); } } Sai lầm #2: Không hiểu về Reference vs Value Mình từng nghĩ: public class Student { String name; public static void main(String[] args) { Student s1 = new Student(); s1.name = \u0026#34;Nam\u0026#34;; Student s2 = s1; // Mình tưởng s2 là bản copy của s1 s2.name = \u0026#34;Linh\u0026#34;; System.out.println(s1.name); // Tại sao lại in ra \u0026#34;Linh\u0026#34;??? } } Bài học: Trong Java, object được truyền theo reference, không phải value. Khi gán s2 = s1, cả hai đều trỏ đến cùng một object trong memory.\nGiải pháp: public class Student implements Cloneable { String name; public Student(String name) { this.name = name; } // Constructor copy public Student(Student other) { this.name = other.name; } public static void main(String[] args) { Student s1 = new Student(\u0026#34;Nam\u0026#34;); Student s2 = new Student(s1); // Tạo object mới s2.name = \u0026#34;Linh\u0026#34;; System.out.println(s1.name); // \u0026#34;Nam\u0026#34; System.out.println(s2.name); // \u0026#34;Linh\u0026#34; } } Sai lầm #3: Không xử lý Exception đúng cách Code \u0026ldquo;tệ\u0026rdquo; của mình: public void readFile(String fileName) { try { FileReader file = new FileReader(fileName); BufferedReader reader = new BufferedReader(file); String line = reader.readLine(); System.out.println(line); } catch (Exception e) { // Im lặng, không làm gì cả - RỐT THẬM TỆ! } } Vấn đề: \u0026ldquo;Nuốt\u0026rdquo; exception mà không xử lý Sử dụng Exception quá general Không đóng resource Cách đúng: public void readFile(String fileName) { try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) { String line = reader.readLine(); if (line != null) { System.out.println(line); } } catch (FileNotFoundException e) { System.err.println(\u0026#34;Không tìm thấy file: \u0026#34; + fileName); // Log hoặc throw lại exception } catch (IOException e) { System.err.println(\u0026#34;Lỗi đọc file: \u0026#34; + e.getMessage()); } } Sai lầm #4: So sánh String bằng == Code sai: public class StringComparison { public static void main(String[] args) { String s1 = \u0026#34;Hello\u0026#34;; String s2 = new String(\u0026#34;Hello\u0026#34;); if (s1 == s2) { // SAAAIIII! System.out.println(\u0026#34;Equal\u0026#34;); } else { System.out.println(\u0026#34;Not equal\u0026#34;); // Sẽ in ra này } } } Giải thích: == so sánh reference, không phải content s1 trỏ đến String Pool s2 trỏ đến object mới trong heap Cách đúng: public class StringComparison { public static void main(String[] args) { String s1 = \u0026#34;Hello\u0026#34;; String s2 = new String(\u0026#34;Hello\u0026#34;); if (s1.equals(s2)) { // So sánh content System.out.println(\u0026#34;Equal\u0026#34;); } // Hoặc an toàn hơn với null check if (Objects.equals(s1, s2)) { System.out.println(\u0026#34;Equal and null-safe\u0026#34;); } } } Sai lầm #5: Không hiểu về Access Modifier Code của mình lúc trước: public class BankAccount { public double balance; // Ai cũng có thể truy cập! public BankAccount(double initialBalance) { balance = initialBalance; } } // Ở nơi khác BankAccount account = new BankAccount(1000); account.balance = -500; // Oops! Balance âm??? Vấn đề: Dữ liệu quan trọng không được bảo vệ Vi phạm nguyên tắc Encapsulation Cách khắc phục: public class BankAccount { private double balance; // Chỉ class này truy cập được public BankAccount(double initialBalance) { if (initialBalance \u0026gt;= 0) { this.balance = initialBalance; } else { throw new IllegalArgumentException(\u0026#34;Balance không thể âm\u0026#34;); } } public double getBalance() { return balance; } public void deposit(double amount) { if (amount \u0026gt; 0) { balance += amount; } } public boolean withdraw(double amount) { if (amount \u0026gt; 0 \u0026amp;\u0026amp; amount \u0026lt;= balance) { balance -= amount; return true; } return false; } } Tổng kết Những sai lầm này đã giúp mình hiểu sâu hơn về Java. Đừng sợ mắc lỗi, quan trọng là học hỏi từ chúng!\nTips để tránh sai lầm: Practice coding every day - Luyện tập thường xuyên Read other people\u0026rsquo;s code - Đọc code của người khác Use IDE effectively - Tận dụng IDE để catch lỗi sớm Code review - Nhờ bạn bè review code Read documentation - Đọc docs chính thức của Java Các bạn đã mắc phải sai lầm nào trong danh sách này chưa? Hoặc có sai lầm nào khác muốn chia sẻ? Comment bên dưới nhé!\nKeep learning, keep coding! ☕\n","permalink":"http://localhost:1313/blog/5-wrong-errors/","tags":["java","sai-lam","kinh-nghiem","hoc-tap"],"title":"5 Sai lầm phổ biến khi học Java mà mình đã mắc phải"},{"categories":["Backend Development"],"contents":"Xin chào các bạn! Sau khi học cả Java và JavaScript, mình có cơ hội làm việc với cả Spring Boot và Node.js trong các dự án thực tế. Hôm nay mình muốn chia sẻ trải nghiệm của mình khi develop backend với hai platform này.\nDự án đầu tiên với Spring Boot 🍃 Setup ban đầu Khi mới bắt đầu với Spring Boot, mình cảm thấy hơi choáng với số lượng config:\n// Application.java @SpringBootApplication public class BlogApplication { public static void main(String[] args) { SpringApplication.run(BlogApplication.class, args); } } // User.java - JPA Entity @Entity @Table(name = \u0026#34;users\u0026#34;) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, unique = true) private String email; @Column(nullable = false) private String password; // Constructor, getters, setters... } // UserRepository.java @Repository public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt; { Optional\u0026lt;User\u0026gt; findByEmail(String email); } // UserController.java @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) public class UserController { @Autowired private UserService userService; @PostMapping public ResponseEntity\u0026lt;User\u0026gt; createUser(@Valid @RequestBody UserDTO userDTO) { User user = userService.createUser(userDTO); return ResponseEntity.status(HttpStatus.CREATED).body(user); } } Những điều mình thích ở Spring Boot: Convention over Configuration - Ít config hơn Spring truyền thống Dependency Injection - Auto-wiring cực kỳ mạnh mẽ JPA/Hibernate - ORM mạnh mẽ, query phức tạp dễ dàng Security - Spring Security handle authentication/authorization tốt Testing - Test infrastructure rất complete Những khó khăn: Learning curve - Cần hiểu về Spring ecosystem Memory usage - JVM khá \u0026ldquo;nặng\u0026rdquo; Startup time - Khởi động chậm hơn Node.js Annotation hell - Quá nhiều annotation có thể confusing Chuyển sang Node.js - Một thế giới khác 🚀 Express.js setup // app.js const express = require(\u0026#34;express\u0026#34;); const mongoose = require(\u0026#34;mongoose\u0026#34;); const bcrypt = require(\u0026#34;bcryptjs\u0026#34;); const jwt = require(\u0026#34;jsonwebtoken\u0026#34;); const app = express(); app.use(express.json()); // User Model với Mongoose const userSchema = new mongoose.Schema({ email: { type: String, required: true, unique: true }, password: { type: String, required: true }, createdAt: { type: Date, default: Date.now }, }); const User = mongoose.model(\u0026#34;User\u0026#34;, userSchema); // User Routes app.post(\u0026#34;/api/users\u0026#34;, async (req, res) =\u0026gt; { try { const { email, password } = req.body; const existingUser = await User.findOne({ email }); if (existingUser) { return res.status(400).json({ message: \u0026#34;User already exists\u0026#34; }); } const hashedPassword = await bcrypt.hash(password, 10); const user = new User({ email, password: hashedPassword }); await user.save(); res.status(201).json({ id: user._id, email: user.email }); } catch (error) { res.status(500).json({ message: error.message }); } }); // Connect to MongoDB mongoose .connect(\u0026#34;mongodb://localhost:27017/myapp\u0026#34;) .then(() =\u0026gt; console.log(\u0026#34;Connected to MongoDB\u0026#34;)) .catch((err) =\u0026gt; console.error(\u0026#34;MongoDB connection error:\u0026#34;, err)); app.listen(3000, () =\u0026gt; { console.log(\u0026#34;Server running on port 3000\u0026#34;); }); Những điều mình thích ở Node.js: Fast development - Viết code nhanh, setup đơn giản JavaScript everywhere - Same language frontend/backend NPM ecosystem - Package có sẵn cho mọi thứ Lightweight - Memory footprint nhỏ hơn JVM Fast startup - Server khởi động trong giây lát Những thách thức: Callback/Promise hell - Nếu không handle tốt async code Single-threaded - CPU-intensive tasks có thể block Type safety - JavaScript dynamic typing đôi khi gây bugs Package management - Dependency hell với npm So sánh thực tế qua dự án Dự án E-commerce Platform Mình đã implement cùng một API cho hệ thống e-commerce với cả hai technologies:\nPerformance Test Results: Concurrent Users: 1000\rTest Duration: 5 minutes\rSpring Boot (Java 17 + PostgreSQL):\r- Average Response Time: 45ms\r- Throughput: 2,200 req/sec\r- Memory Usage: 512MB\r- CPU Usage: 35%\rNode.js (Express + MongoDB):\r- Average Response Time: 38ms\r- Throughput: 2,800 req/sec\r- Memory Usage: 128MB\r- CPU Usage: 28% Development Speed: Spring Boot:\nSetup time: 30 phút (config database, dependencies) CRUD operations: 2 giờ Authentication: 1 giờ (Spring Security) Unit tests: 1.5 giờ Total: ~5 giờ Node.js:\nSetup time: 10 phút CRUD operations: 1 giờ Authentication: 1.5 giờ (custom JWT) Unit tests: 1 giờ Total: ~3.5 giờ Khi nào dùng gì? Chọn Spring Boot khi: ✅ Enterprise applications - Cần security, scalability cao\n✅ Complex business logic - Nhiều rules phức tạp\n✅ Team lớn - Structure rõ ràng, maintainable\n✅ Legacy systems - Integration với Java ecosystem\n✅ Microservices - Spring Cloud ecosystem mạnh\n// Example: Complex business logic dễ handle với Java @Service @Transactional public class OrderService { public Order processOrder(OrderRequest request) { // Validate inventory inventoryService.checkAvailability(request.getItems()); // Apply discounts BigDecimal finalAmount = pricingService .calculateDiscount(request, customer.getTier()); // Process payment PaymentResult payment = paymentService .processPayment(customer.getPaymentMethod(), finalAmount); if (payment.isSuccessful()) { // Create order Order order = orderRepository.save( Order.builder() .customerId(customer.getId()) .amount(finalAmount) .status(OrderStatus.CONFIRMED) .build() ); // Send notifications notificationService.sendOrderConfirmation(order); return order; } throw new PaymentProcessingException(\u0026#34;Payment failed\u0026#34;); } } Chọn Node.js khi: ✅ Rapid prototyping - Cần develop nhanh\n✅ Real-time apps - Chat, live updates (Socket.io)\n✅ API-first approach - RESTful APIs đơn giản\n✅ Startup/Small team - Ít developers, cần flexibility\n✅ I/O intensive - Nhiều database calls, external APIs\n// Example: Real-time chat với Socket.io const io = require(\u0026#34;socket.io\u0026#34;)(server); io.on(\u0026#34;connection\u0026#34;, (socket) =\u0026gt; { console.log(\u0026#34;User connected:\u0026#34;, socket.id); socket.on(\u0026#34;join-room\u0026#34;, (roomId) =\u0026gt; { socket.join(roomId); socket.to(roomId).emit(\u0026#34;user-joined\u0026#34;, socket.id); }); socket.on(\u0026#34;message\u0026#34;, async (data) =\u0026gt; { // Save to database const message = await Message.create({ content: data.message, userId: data.userId, roomId: data.roomId, }); // Broadcast to room io.to(data.roomId).emit(\u0026#34;new-message\u0026#34;, message); }); socket.on(\u0026#34;disconnect\u0026#34;, () =\u0026gt; { console.log(\u0026#34;User disconnected:\u0026#34;, socket.id); }); }); Lessons Learned 1. Không có \u0026ldquo;silver bullet\u0026rdquo; Cả hai đều có ưu nhược điểm. Quan trọng là chọn tool phù hợp với requirements.\n2. Team skill matter Team giỏi Java → Spring Boot sẽ productive hơn Team frontend developers → Node.js dễ tiếp cận hơn 3. Maintenance is key Spring Boot có structure rõ ràng hơn cho long-term projects.\n4. Performance isn\u0026rsquo;t everything Developer productivity và time-to-market cũng quan trọng.\nKết luận Sau kinh nghiệm với cả hai, mình nhận ra:\nSpring Boot giống như một chiếc Mercedes - robust, reliable, powerful nhưng cần thời gian để master.\nNode.js giống như một chiếc motorbike - agile, fast, flexible nhưng cần cẩn thận khi handle complex scenarios.\nHiện tại mình đang sử dụng:\nSpring Boot cho enterprise projects, complex business logic Node.js cho prototypes, real-time features, simple APIs Các bạn có kinh nghiệm gì với hai platform này? Share ở comment nhé!\nChoose the right tool for the job! 🛠️\n","permalink":"http://localhost:1313/blog/springboot-vs-nodejs/","tags":["java","javascript","spring-boot","nodejs","backend"],"title":"Spring Boot vs Node.js: Trải nghiệm backend development của mình"},{"categories":["JavaScript"],"contents":"Chào mọi người! Khi mới học JavaScript, mình chỉ biết đến cú pháp cũ ES5. Nhưng khi tiếp xúc với ES6+ (ES2015 trở lên), thật sự mình cảm thấy như được \u0026ldquo;khai sáng\u0026rdquo;. Hôm nay mình muốn chia sẻ những tính năng ES6+ đã thay đổi hoàn toàn cách mình viết JavaScript.\n1. Let \u0026amp; Const - Tạm biệt var nhé! Cách cũ với var: // Vấn đề với var function oldWay() { for (var i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; { console.log(i); // In ra 3, 3, 3 (WTF???) }, 100); } console.log(i); // 3 - i vẫn tồn tại ngoài loop! } Cách mới với let \u0026amp; const: function newWay() { for (let i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; { console.log(i); // In ra 0, 1, 2 (chính xác!) }, 100); } // console.log(i); // ReferenceError - i không tồn tại ở đây const API_URL = \u0026#34;https://api.example.com\u0026#34;; // API_URL = \u0026#39;other-url\u0026#39;; // TypeError - không thể reassign const } Bài học: Luôn dùng const cho giá trị không thay đổi, let cho biến có thể thay đổi. Quên var đi!\n2. Arrow Functions - Code ngắn gọn hơn ES5 way: // Function expression cũ var users = [\u0026#34;Nam\u0026#34;, \u0026#34;Linh\u0026#34;, \u0026#34;Hoa\u0026#34;]; var uppercaseUsers = users.map(function (user) { return user.toUpperCase(); }); var button = document.getElementById(\u0026#34;btn\u0026#34;); button.addEventListener(\u0026#34;click\u0026#34;, function () { console.log(this); // \u0026#39;this\u0026#39; trỏ đến button }); ES6 way: // Arrow function - clean và concise const users = [\u0026#34;Nam\u0026#34;, \u0026#34;Linh\u0026#34;, \u0026#34;Hoa\u0026#34;]; const uppercaseUsers = users.map((user) =\u0026gt; user.toUpperCase()); // Với multiple parameters const add = (a, b) =\u0026gt; a + b; // Với function body const processUser = (user) =\u0026gt; { const processed = user.trim().toUpperCase(); return `Hello, ${processed}!`; }; // Lưu ý về \u0026#39;this\u0026#39; binding const obj = { name: \u0026#34;MyObject\u0026#34;, regularFunction() { console.log(this.name); // \u0026#39;MyObject\u0026#39; const arrowFunction = () =\u0026gt; { console.log(this.name); // \u0026#39;MyObject\u0026#39; - inherit từ parent scope }; arrowFunction(); }, }; Tip: Arrow function không có this binding riêng, nó inherit từ parent scope.\n3. Template Literals - Goodbye string concatenation! Cách cũ: var name = \u0026#34;Nam\u0026#34;; var age = 20; var city = \u0026#34;Ho Chi Minh\u0026#34;; var introduction = \u0026#34;Xin chào, tôi là \u0026#34; + name + \u0026#34;, \u0026#34; + age + \u0026#34; tuổi, \u0026#34; + \u0026#34;đến từ \u0026#34; + city + \u0026#34;.\u0026#34;; var htmlTemplate = \u0026#39;\u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt;\u0026#39; + \u0026#34;\u0026lt;h2\u0026gt;\u0026#34; + name + \u0026#34;\u0026lt;/h2\u0026gt;\u0026#34; + \u0026#34;\u0026lt;p\u0026gt;Age: \u0026#34; + age + \u0026#34;\u0026lt;/p\u0026gt;\u0026#34; + \u0026#34;\u0026lt;/div\u0026gt;\u0026#34;; Cách mới: const name = \u0026#34;Nam\u0026#34;; const age = 20; const city = \u0026#34;Ho Chi Minh\u0026#34;; // Template literals với backticks const introduction = `Xin chào, tôi là ${name}, ${age} tuổi, đến từ ${city}.`; // Multi-line strings dễ dàng const htmlTemplate = ` \u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;${name}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Age: ${age}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Status: ${age \u0026gt;= 18 ? \u0026#34;Adult\u0026#34; : \u0026#34;Minor\u0026#34;}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `; // Tagged template literals (advanced) function highlight(strings, ...values) { return strings.reduce((result, string, i) =\u0026gt; { const value = values[i] ? `\u0026lt;mark\u0026gt;${values[i]}\u0026lt;/mark\u0026gt;` : \u0026#34;\u0026#34;; return result + string + value; }, \u0026#34;\u0026#34;); } const highlighted = highlight`Tôi tên là ${name} và ${age} tuổi.`; 4. Destructuring - Unpack dữ liệu như ninja Array Destructuring: // Cách cũ var numbers = [1, 2, 3, 4, 5]; var first = numbers[0]; var second = numbers[1]; var rest = numbers.slice(2); // Cách mới const [first, second, ...rest] = [1, 2, 3, 4, 5]; console.log(first); // 1 console.log(second); // 2 console.log(rest); // [3, 4, 5] // Skip elements const [a, , c] = [1, 2, 3]; console.log(a, c); // 1, 3 // Default values const [x = 0, y = 0] = [1]; // x = 1, y = 0 Object Destructuring: // Cách cũ var user = { name: \u0026#34;Nam\u0026#34;, age: 20, email: \u0026#34;nam@example.com\u0026#34;, address: { city: \u0026#34;Ho Chi Minh\u0026#34;, district: \u0026#34;District 1\u0026#34;, }, }; var name = user.name; var age = user.age; var email = user.email; // Cách mới const { name, age, email } = user; // Rename variables const { name: userName, age: userAge } = user; // Nested destructuring const { address: { city, district }, } = user; // Default values const { phone = \u0026#34;N/A\u0026#34; } = user; // Function parameters destructuring function greetUser({ name, age = \u0026#34;unknown\u0026#34; }) { return `Hello ${name}, you are ${age} years old`; } greetUser({ name: \u0026#34;Nam\u0026#34;, age: 20 }); 5. Spread \u0026amp; Rest Operators - Ba chấm ma thuật Spread Operator (\u0026hellip;): // Array spreading const arr1 = [1, 2, 3]; const arr2 = [4, 5, 6]; const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6] // Object spreading const user = { name: \u0026#34;Nam\u0026#34;, age: 20 }; const updatedUser = { ...user, age: 21, city: \u0026#34;HCM\u0026#34; }; // { name: \u0026#39;Nam\u0026#39;, age: 21, city: \u0026#39;HCM\u0026#39; } // Function arguments function sum(a, b, c) { return a + b + c; } const numbers = [1, 2, 3]; console.log(sum(...numbers)); // 6 Rest Operator (\u0026hellip;): // Function parameters function logAll(first, ...others) { console.log(\u0026#34;First:\u0026#34;, first); console.log(\u0026#34;Others:\u0026#34;, others); } logAll(1, 2, 3, 4, 5); // First: 1, Others: [2, 3, 4, 5] // Array destructuring (đã thấy ở trên) const [head, ...tail] = [1, 2, 3, 4, 5]; 6. Enhanced Object Literals const name = \u0026#34;Nam\u0026#34;; const age = 20; // Cách cũ var user = { name: name, age: age, greet: function () { return \u0026#34;Hello!\u0026#34;; }, }; // Cách mới - shorthand properties const user = { name, // tương đương name: name age, // tương đương age: age // Method shorthand greet() { return \u0026#34;Hello!\u0026#34;; }, // Computed property names [`full${name}`]: `${name} Nguyen`, // Dynamic property [getPropertyName()]: \u0026#34;dynamic value\u0026#34;, }; 7. Promises \u0026amp; Async/Await - Tạm biệt Callback Hell Callback Hell: // Cách cũ - callback hell fetchUser(userId, function (user) { fetchUserPosts(user.id, function (posts) { fetchPostComments(posts[0].id, function (comments) { // Nested callbacks - khó đọc và maintain console.log(comments); }); }); }); Promises: // Promise chain fetchUser(userId) .then((user) =\u0026gt; fetchUserPosts(user.id)) .then((posts) =\u0026gt; fetchPostComments(posts[0].id)) .then((comments) =\u0026gt; console.log(comments)) .catch((error) =\u0026gt; console.error(error)); Async/Await: // Async/await - code như synchronous async function getUserData(userId) { try { const user = await fetchUser(userId); const posts = await fetchUserPosts(user.id); const comments = await fetchPostComments(posts[0].id); return comments; } catch (error) { console.error(\u0026#34;Error:\u0026#34;, error); throw error; } } // Sử dụng getUserData(123).then((data) =\u0026gt; console.log(data)); Kết luận ES6+ đã thực sự thay đổi cách mình viết JavaScript:\nCode ngắn gọn và dễ đọc hơn Ít bugs hơn nhờ let/const Xử lý async code dễ dàng hơn Destructuring giúp unpack data elegantly Tips cho người mới: Học từ từ - Đừng cố gắng học tất cả một lúc Practice daily - Viết code ES6+ mỗi ngày Use Babel - Để support browser cũ Read MDN docs - Tài liệu chính thức luôn tốt nhất Các bạn đã dùng feature nào trong số này chưa? Feature nào khiến các bạn ấn tượng nhất? Share ở comment nhé!\nModern JavaScript is beautiful! 🚀✨\n","permalink":"http://localhost:1313/blog/javascript-es6+/","tags":["javascript","es6","modern-js","kinh-nghiem"],"title":"JavaScript ES6+: Những tính năng đã thay đổi cách mình code"},{"categories":null,"contents":"Xin chào! Tôi là Tiết Thanh Minh Hiếu 👋 Câu chuyện của tôi Tôi là một sinh viên đang theo đuổi ước mơ trở thành chuyên viên An Ninh Mạng, với niềm đam mê bảo vệ thế giới số khỏi những mối đe dọa ngày càng phức tạp. Nhưng điều đặc biệt là tôi không chỉ muốn \u0026ldquo;làm\u0026rdquo; mà còn muốn \u0026ldquo;truyền cảm hứng\u0026rdquo; - mục tiêu của tôi là trở thành một giảng viên Security, người có thể biến những kiến thức phức tạp thành những bài học dễ hiểu và thú vị.\nTại sao tôi tạo blog này? Ban đầu, blog này được tạo ra để hoàn thành yêu cầu môn học về Java \u0026amp; JavaScript. Nhưng tôi nhận ra đây chính là cơ hội tuyệt vời để bắt đầu hành trình chia sẻ kiến thức mà tôi đã ấp ủ từ lâu.\nTôi tin rằng: Cách học tốt nhất là dạy lại cho người khác. Mỗi bài viết tôi chia sẻ không chỉ giúp các bạn đọc mà còn giúp tôi củng cố và mở rộng kiến thức của chính mình.\nNhững gì tôi đang làm 🔍 An Ninh Mạng Hiện tại tôi đang xây dựng nền tảng vững chắc với các chứng chỉ từ Google Cybersecurity và IBM. Kiến thức mạng cơ bản đã giúp tôi hiểu được \u0026ldquo;bức tranh lớn\u0026rdquo; của bảo mật.\n🤖 AI \u0026amp; Machine Learning Tôi có kinh nghiệm training model, đặc biệt là BERT. Dự án gần nhất của tôi là \u0026ldquo;Phát hiện mã độc Android bằng Transformer Networks (BERT)\u0026rdquo; - một project thú vị kết hợp giữa AI và Cybersecurity.\n💻 Lập trình Java và JavaScript là những ngôn ngữ tôi đang tập trung, nhưng hành trình coding của tôi không dừng lại ở đó!\nĐiều gì khiến blog này khác biệt? Không chỉ là lý thuyết khô khan. Tôi sẽ chia sẻ:\n✨ Kinh nghiệm thực tế từ các project đã làm 🎯 Cách tiếp cận thực tế thay vì chỉ đọc sách vở 🔧 Tips \u0026amp; tricks mà tôi học được qua quá trình \u0026ldquo;vấp ngã\u0026rdquo; 📚 Kiến thức được \u0026ldquo;dịch\u0026rdquo; sang ngôn ngữ dễ hiểu Mục tiêu của tôi là biến những khái niệm phức tạp thành những câu chuyện thú vị mà bất kỳ ai cũng có thể hiểu được.\nTầm nhìn tương lai Tôi mơ ước một ngày nào đó sẽ đứng trên bục giảng, truyền cảm hứng cho thế hệ các chuyên gia bảo mật tương lai. Blog này chính là bước đầu tiên trong hành trình rèn luyện kỹ năng truyền đạt của tôi.\nMỗi bài viết là một bài giảng nhỏ, mỗi chia sẻ là một lần thực hành để tôi có thể diễn đạt tốt hơn, rõ ràng hơn.\nLời kết Nếu bạn là người:\n🎓 Đang học về Cybersecurity, Java, JavaScript hoặc AI 🔍 Muốn hiểu cách áp dụng kiến thức vào thực tế 💡 Thích học thông qua kinh nghiệm thực tế hơn là lý thuyết suông Thì blog này dành cho bạn! Tôi hy vọng những chia sẻ của mình sẽ giúp ích cho hành trình học tập của các bạn, đồng thời cũng giúp tôi trở thành một người truyền đạt giỏi hơn.\nHãy cùng học, cùng phát triển và cùng tạo nên một cộng đồng tech Việt Nam mạnh mẽ! 🚀\n\u0026ldquo;The best way to learn is to teach others\u0026rdquo; - và đó chính là triết lý tôi theo đuổi trong mỗi bài viết.\n","permalink":"http://localhost:1313/about/","tags":null,"title":"Giới thiệu"},{"categories":null,"contents":"Trong lập trình mạng bằng Java, Socket là công cụ giúp kết nối giữa client và server.\nBằng cách sử dụng java.net.Socket và java.net.ServerSocket, ta có thể xây dựng các ứng dụng chat, truyền file hoặc HTTP server đơn giản.\nMô hình Client-Server cơ bản trong lập trình Socket Ở mức thấp hơn, kết nối TCP được thiết lập qua quá trình bắt tay 3 bước (TCP Handshake).\nĐiều này đảm bảo client và server đồng bộ trạng thái trước khi truyền dữ liệu.\nCơ chế bắt tay 3 bước TCP (Three-Way Handshake) ","permalink":"http://localhost:1313/blog/java-socket/","tags":["Java","Networking"],"title":"Kết nối Socket trong Java"},{"categories":["Programming"],"contents":"Chào các bạn! Hôm nay mình muốn chia sẻ về hành trình học lập trình của mình, từ Java đến JavaScript. Có lẽ nhiều bạn cũng đang băn khoăn giống mình: nên bắt đầu với ngôn ngữ nào? Học Java trước hay JavaScript trước?\nKhởi đầu với Java - Nền tảng vững chắc Mình bắt đầu với Java từ năm nhất đại học. Thật sự lúc đầu khá choáng với cú pháp dài dòng của Java:\npublic class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Hello, World!\u0026#34;); } } So với \u0026ldquo;Hello World\u0026rdquo; của JavaScript:\nconsole.log(\u0026#34;Hello, World!\u0026#34;); Wow, khác biệt quá phải không? Nhưng qua thời gian, mình nhận ra Java đã dạy mình những điều quan trọng:\n1. Tư duy hướng đối tượng (OOP) Java buộc mình phải hiểu về Class, Object, Inheritance\u0026hellip; Lúc đầu khó hiểu lắm, nhưng sau này khi làm dự án lớn mới thấy tầm quan trọng của nó.\n2. Tính nghiêm ngặt về kiểu dữ liệu int number = 10; // Phải khai báo kiểu rõ ràng String text = \u0026#34;Hello\u0026#34;; // Không thể gán số vào String 3. Cấu trúc dự án rõ ràng Package, import, access modifier\u0026hellip; tất cả đều có quy tắc rõ ràng.\nChuyển sang JavaScript - Tự do nhưng cần kỷ luật Khi bắt đầu học JavaScript, mình cảm thấy như được \u0026ldquo;giải phóng\u0026rdquo;:\nlet data = 10; // Kiểu number data = \u0026#34;Hello\u0026#34;; // Giờ thành string data = [1, 2, 3]; // Giờ thành array data = { name: \u0026#34;John\u0026#34; }; // Giờ thành object Tự do quá! Nhưng cũng dễ rối loạn không kém.\nNhững khác biệt chính mình nhận ra: Java:\nCompiled language (biên dịch trước) Strongly typed (kiểu dữ liệu nghiêm ngặt) Platform independent (chạy trên JVM) Chủ yếu cho backend JavaScript:\nInterpreted language (thông dịch) Dynamically typed (kiểu dữ liệu linh hoạt) Chạy trên browser/Node.js Full-stack (cả frontend và backend) Bài học rút ra 1. Java là nền tảng tốt để bắt đầu Nếu bạn chưa biết gì về lập trình, mình khuyên nên bắt đầu với Java. Tại sao?\nBuộc bạn phải viết code chuẩn Hiểu rõ về cấu trúc dữ liệu Tư duy logic tốt hơn 2. JavaScript cần kỷ luật bản thân Vì quá linh hoạt, JavaScript dễ làm cho code trở nên lộn xộn. Mình học được:\nĐặt tên biến có ý nghĩa Sử dụng const/let thay vì var Comment code đầy đủ 3. Cả hai đều có giá trị Java: Tốt cho hệ thống lớn, enterprise applications JavaScript: Linh hoạt, phát triển nhanh, cộng đồng active Lời kết Hành trình từ Java đến JavaScript đã dạy mình rằng không có ngôn ngữ nào là \u0026ldquo;tốt nhất\u0026rdquo;. Mỗi ngôn ngữ đều có ưu nhược điểm riêng. Quan trọng là hiểu rõ bản chất và áp dụng đúng context.\nCác bạn có kinh nghiệm gì thú vị khi học hai ngôn ngữ này không? Hãy chia sẻ trong comment nhé!\nHappy coding! 🚀\n","permalink":"http://localhost:1313/blog/java-to-javascript/","tags":["java","javascript","kinh-nghiem","hoc-tap"],"title":"Từ Java đến JavaScript: Hành trình học lập trình của mình"},{"categories":["Java"],"contents":"Xin chào các bạn! Hôm nay mình muốn chia sẻ về những sai lầm \u0026ldquo;kinh điển\u0026rdquo; mà hầu như ai học Java cũng mắc phải, bao gồm cả mình. Hy vọng qua bài viết này, các bạn newbie sẽ tránh được những \u0026ldquo;hố đen\u0026rdquo; mà mình đã rơi vào.\nSai lầm #1: Lạm dụng public static void main Mình từng làm thế này: public class Calculator { public static void main(String[] args) { // Viết tất cả logic trong main int a = 10, b = 5; int sum = a + b; int diff = a - b; int product = a * b; int quotient = a / b; System.out.println(\u0026#34;Sum: \u0026#34; + sum); System.out.println(\u0026#34;Difference: \u0026#34; + diff); // ... và còn 50 dòng code nữa } } Vấn đề: Code không thể tái sử dụng Khó debug và maintain Không theo nguyên tắc OOP Cách khắc phục: public class Calculator { public int add(int a, int b) { return a + b; } public int subtract(int a, int b) { return a - b; } public static void main(String[] args) { Calculator calc = new Calculator(); System.out.println(\u0026#34;Sum: \u0026#34; + calc.add(10, 5)); System.out.println(\u0026#34;Difference: \u0026#34; + calc.subtract(10, 5)); } } Sai lầm #2: Không hiểu về Reference vs Value Mình từng nghĩ: public class Student { String name; public static void main(String[] args) { Student s1 = new Student(); s1.name = \u0026#34;Nam\u0026#34;; Student s2 = s1; // Mình tưởng s2 là bản copy của s1 s2.name = \u0026#34;Linh\u0026#34;; System.out.println(s1.name); // Tại sao lại in ra \u0026#34;Linh\u0026#34;??? } } Bài học: Trong Java, object được truyền theo reference, không phải value. Khi gán s2 = s1, cả hai đều trỏ đến cùng một object trong memory.\nGiải pháp: public class Student implements Cloneable { String name; public Student(String name) { this.name = name; } // Constructor copy public Student(Student other) { this.name = other.name; } public static void main(String[] args) { Student s1 = new Student(\u0026#34;Nam\u0026#34;); Student s2 = new Student(s1); // Tạo object mới s2.name = \u0026#34;Linh\u0026#34;; System.out.println(s1.name); // \u0026#34;Nam\u0026#34; System.out.println(s2.name); // \u0026#34;Linh\u0026#34; } } Sai lầm #3: Không xử lý Exception đúng cách Code \u0026ldquo;tệ\u0026rdquo; của mình: public void readFile(String fileName) { try { FileReader file = new FileReader(fileName); BufferedReader reader = new BufferedReader(file); String line = reader.readLine(); System.out.println(line); } catch (Exception e) { // Im lặng, không làm gì cả - RỐT THẬM TỆ! } } Vấn đề: \u0026ldquo;Nuốt\u0026rdquo; exception mà không xử lý Sử dụng Exception quá general Không đóng resource Cách đúng: public void readFile(String fileName) { try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) { String line = reader.readLine(); if (line != null) { System.out.println(line); } } catch (FileNotFoundException e) { System.err.println(\u0026#34;Không tìm thấy file: \u0026#34; + fileName); // Log hoặc throw lại exception } catch (IOException e) { System.err.println(\u0026#34;Lỗi đọc file: \u0026#34; + e.getMessage()); } } Sai lầm #4: So sánh String bằng == Code sai: public class StringComparison { public static void main(String[] args) { String s1 = \u0026#34;Hello\u0026#34;; String s2 = new String(\u0026#34;Hello\u0026#34;); if (s1 == s2) { // SAAAIIII! System.out.println(\u0026#34;Equal\u0026#34;); } else { System.out.println(\u0026#34;Not equal\u0026#34;); // Sẽ in ra này } } } Giải thích: == so sánh reference, không phải content s1 trỏ đến String Pool s2 trỏ đến object mới trong heap Cách đúng: public class StringComparison { public static void main(String[] args) { String s1 = \u0026#34;Hello\u0026#34;; String s2 = new String(\u0026#34;Hello\u0026#34;); if (s1.equals(s2)) { // So sánh content System.out.println(\u0026#34;Equal\u0026#34;); } // Hoặc an toàn hơn với null check if (Objects.equals(s1, s2)) { System.out.println(\u0026#34;Equal and null-safe\u0026#34;); } } } Sai lầm #5: Không hiểu về Access Modifier Code của mình lúc trước: public class BankAccount { public double balance; // Ai cũng có thể truy cập! public BankAccount(double initialBalance) { balance = initialBalance; } } // Ở nơi khác BankAccount account = new BankAccount(1000); account.balance = -500; // Oops! Balance âm??? Vấn đề: Dữ liệu quan trọng không được bảo vệ Vi phạm nguyên tắc Encapsulation Cách khắc phục: public class BankAccount { private double balance; // Chỉ class này truy cập được public BankAccount(double initialBalance) { if (initialBalance \u0026gt;= 0) { this.balance = initialBalance; } else { throw new IllegalArgumentException(\u0026#34;Balance không thể âm\u0026#34;); } } public double getBalance() { return balance; } public void deposit(double amount) { if (amount \u0026gt; 0) { balance += amount; } } public boolean withdraw(double amount) { if (amount \u0026gt; 0 \u0026amp;\u0026amp; amount \u0026lt;= balance) { balance -= amount; return true; } return false; } } Tổng kết Những sai lầm này đã giúp mình hiểu sâu hơn về Java. Đừng sợ mắc lỗi, quan trọng là học hỏi từ chúng!\nTips để tránh sai lầm: Practice coding every day - Luyện tập thường xuyên Read other people\u0026rsquo;s code - Đọc code của người khác Use IDE effectively - Tận dụng IDE để catch lỗi sớm Code review - Nhờ bạn bè review code Read documentation - Đọc docs chính thức của Java Các bạn đã mắc phải sai lầm nào trong danh sách này chưa? Hoặc có sai lầm nào khác muốn chia sẻ? Comment bên dưới nhé!\nKeep learning, keep coding! ☕\n","permalink":"http://localhost:1313/blog/5-wrong-errors/","tags":["java","sai-lam","kinh-nghiem","hoc-tap"],"title":"5 Sai lầm phổ biến khi học Java mà mình đã mắc phải"},{"categories":["Backend Development"],"contents":"Xin chào các bạn! Sau khi học cả Java và JavaScript, mình có cơ hội làm việc với cả Spring Boot và Node.js trong các dự án thực tế. Hôm nay mình muốn chia sẻ trải nghiệm của mình khi develop backend với hai platform này.\nDự án đầu tiên với Spring Boot 🍃 Setup ban đầu Khi mới bắt đầu với Spring Boot, mình cảm thấy hơi choáng với số lượng config:\n// Application.java @SpringBootApplication public class BlogApplication { public static void main(String[] args) { SpringApplication.run(BlogApplication.class, args); } } // User.java - JPA Entity @Entity @Table(name = \u0026#34;users\u0026#34;) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, unique = true) private String email; @Column(nullable = false) private String password; // Constructor, getters, setters... } // UserRepository.java @Repository public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt; { Optional\u0026lt;User\u0026gt; findByEmail(String email); } // UserController.java @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) public class UserController { @Autowired private UserService userService; @PostMapping public ResponseEntity\u0026lt;User\u0026gt; createUser(@Valid @RequestBody UserDTO userDTO) { User user = userService.createUser(userDTO); return ResponseEntity.status(HttpStatus.CREATED).body(user); } } Những điều mình thích ở Spring Boot: Convention over Configuration - Ít config hơn Spring truyền thống Dependency Injection - Auto-wiring cực kỳ mạnh mẽ JPA/Hibernate - ORM mạnh mẽ, query phức tạp dễ dàng Security - Spring Security handle authentication/authorization tốt Testing - Test infrastructure rất complete Những khó khăn: Learning curve - Cần hiểu về Spring ecosystem Memory usage - JVM khá \u0026ldquo;nặng\u0026rdquo; Startup time - Khởi động chậm hơn Node.js Annotation hell - Quá nhiều annotation có thể confusing Chuyển sang Node.js - Một thế giới khác 🚀 Express.js setup // app.js const express = require(\u0026#34;express\u0026#34;); const mongoose = require(\u0026#34;mongoose\u0026#34;); const bcrypt = require(\u0026#34;bcryptjs\u0026#34;); const jwt = require(\u0026#34;jsonwebtoken\u0026#34;); const app = express(); app.use(express.json()); // User Model với Mongoose const userSchema = new mongoose.Schema({ email: { type: String, required: true, unique: true }, password: { type: String, required: true }, createdAt: { type: Date, default: Date.now }, }); const User = mongoose.model(\u0026#34;User\u0026#34;, userSchema); // User Routes app.post(\u0026#34;/api/users\u0026#34;, async (req, res) =\u0026gt; { try { const { email, password } = req.body; const existingUser = await User.findOne({ email }); if (existingUser) { return res.status(400).json({ message: \u0026#34;User already exists\u0026#34; }); } const hashedPassword = await bcrypt.hash(password, 10); const user = new User({ email, password: hashedPassword }); await user.save(); res.status(201).json({ id: user._id, email: user.email }); } catch (error) { res.status(500).json({ message: error.message }); } }); // Connect to MongoDB mongoose .connect(\u0026#34;mongodb://localhost:27017/myapp\u0026#34;) .then(() =\u0026gt; console.log(\u0026#34;Connected to MongoDB\u0026#34;)) .catch((err) =\u0026gt; console.error(\u0026#34;MongoDB connection error:\u0026#34;, err)); app.listen(3000, () =\u0026gt; { console.log(\u0026#34;Server running on port 3000\u0026#34;); }); Những điều mình thích ở Node.js: Fast development - Viết code nhanh, setup đơn giản JavaScript everywhere - Same language frontend/backend NPM ecosystem - Package có sẵn cho mọi thứ Lightweight - Memory footprint nhỏ hơn JVM Fast startup - Server khởi động trong giây lát Những thách thức: Callback/Promise hell - Nếu không handle tốt async code Single-threaded - CPU-intensive tasks có thể block Type safety - JavaScript dynamic typing đôi khi gây bugs Package management - Dependency hell với npm So sánh thực tế qua dự án Dự án E-commerce Platform Mình đã implement cùng một API cho hệ thống e-commerce với cả hai technologies:\nPerformance Test Results: Concurrent Users: 1000\rTest Duration: 5 minutes\rSpring Boot (Java 17 + PostgreSQL):\r- Average Response Time: 45ms\r- Throughput: 2,200 req/sec\r- Memory Usage: 512MB\r- CPU Usage: 35%\rNode.js (Express + MongoDB):\r- Average Response Time: 38ms\r- Throughput: 2,800 req/sec\r- Memory Usage: 128MB\r- CPU Usage: 28% Development Speed: Spring Boot:\nSetup time: 30 phút (config database, dependencies) CRUD operations: 2 giờ Authentication: 1 giờ (Spring Security) Unit tests: 1.5 giờ Total: ~5 giờ Node.js:\nSetup time: 10 phút CRUD operations: 1 giờ Authentication: 1.5 giờ (custom JWT) Unit tests: 1 giờ Total: ~3.5 giờ Khi nào dùng gì? Chọn Spring Boot khi: ✅ Enterprise applications - Cần security, scalability cao\n✅ Complex business logic - Nhiều rules phức tạp\n✅ Team lớn - Structure rõ ràng, maintainable\n✅ Legacy systems - Integration với Java ecosystem\n✅ Microservices - Spring Cloud ecosystem mạnh\n// Example: Complex business logic dễ handle với Java @Service @Transactional public class OrderService { public Order processOrder(OrderRequest request) { // Validate inventory inventoryService.checkAvailability(request.getItems()); // Apply discounts BigDecimal finalAmount = pricingService .calculateDiscount(request, customer.getTier()); // Process payment PaymentResult payment = paymentService .processPayment(customer.getPaymentMethod(), finalAmount); if (payment.isSuccessful()) { // Create order Order order = orderRepository.save( Order.builder() .customerId(customer.getId()) .amount(finalAmount) .status(OrderStatus.CONFIRMED) .build() ); // Send notifications notificationService.sendOrderConfirmation(order); return order; } throw new PaymentProcessingException(\u0026#34;Payment failed\u0026#34;); } } Chọn Node.js khi: ✅ Rapid prototyping - Cần develop nhanh\n✅ Real-time apps - Chat, live updates (Socket.io)\n✅ API-first approach - RESTful APIs đơn giản\n✅ Startup/Small team - Ít developers, cần flexibility\n✅ I/O intensive - Nhiều database calls, external APIs\n// Example: Real-time chat với Socket.io const io = require(\u0026#34;socket.io\u0026#34;)(server); io.on(\u0026#34;connection\u0026#34;, (socket) =\u0026gt; { console.log(\u0026#34;User connected:\u0026#34;, socket.id); socket.on(\u0026#34;join-room\u0026#34;, (roomId) =\u0026gt; { socket.join(roomId); socket.to(roomId).emit(\u0026#34;user-joined\u0026#34;, socket.id); }); socket.on(\u0026#34;message\u0026#34;, async (data) =\u0026gt; { // Save to database const message = await Message.create({ content: data.message, userId: data.userId, roomId: data.roomId, }); // Broadcast to room io.to(data.roomId).emit(\u0026#34;new-message\u0026#34;, message); }); socket.on(\u0026#34;disconnect\u0026#34;, () =\u0026gt; { console.log(\u0026#34;User disconnected:\u0026#34;, socket.id); }); }); Lessons Learned 1. Không có \u0026ldquo;silver bullet\u0026rdquo; Cả hai đều có ưu nhược điểm. Quan trọng là chọn tool phù hợp với requirements.\n2. Team skill matter Team giỏi Java → Spring Boot sẽ productive hơn Team frontend developers → Node.js dễ tiếp cận hơn 3. Maintenance is key Spring Boot có structure rõ ràng hơn cho long-term projects.\n4. Performance isn\u0026rsquo;t everything Developer productivity và time-to-market cũng quan trọng.\nKết luận Sau kinh nghiệm với cả hai, mình nhận ra:\nSpring Boot giống như một chiếc Mercedes - robust, reliable, powerful nhưng cần thời gian để master.\nNode.js giống như một chiếc motorbike - agile, fast, flexible nhưng cần cẩn thận khi handle complex scenarios.\nHiện tại mình đang sử dụng:\nSpring Boot cho enterprise projects, complex business logic Node.js cho prototypes, real-time features, simple APIs Các bạn có kinh nghiệm gì với hai platform này? Share ở comment nhé!\nChoose the right tool for the job! 🛠️\n","permalink":"http://localhost:1313/blog/springboot-vs-nodejs/","tags":["java","javascript","spring-boot","nodejs","backend"],"title":"Spring Boot vs Node.js: Trải nghiệm backend development của mình"},{"categories":["JavaScript"],"contents":"Chào mọi người! Khi mới học JavaScript, mình chỉ biết đến cú pháp cũ ES5. Nhưng khi tiếp xúc với ES6+ (ES2015 trở lên), thật sự mình cảm thấy như được \u0026ldquo;khai sáng\u0026rdquo;. Hôm nay mình muốn chia sẻ những tính năng ES6+ đã thay đổi hoàn toàn cách mình viết JavaScript.\n1. Let \u0026amp; Const - Tạm biệt var nhé! Cách cũ với var: // Vấn đề với var function oldWay() { for (var i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; { console.log(i); // In ra 3, 3, 3 (WTF???) }, 100); } console.log(i); // 3 - i vẫn tồn tại ngoài loop! } Cách mới với let \u0026amp; const: function newWay() { for (let i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; { console.log(i); // In ra 0, 1, 2 (chính xác!) }, 100); } // console.log(i); // ReferenceError - i không tồn tại ở đây const API_URL = \u0026#34;https://api.example.com\u0026#34;; // API_URL = \u0026#39;other-url\u0026#39;; // TypeError - không thể reassign const } Bài học: Luôn dùng const cho giá trị không thay đổi, let cho biến có thể thay đổi. Quên var đi!\n2. Arrow Functions - Code ngắn gọn hơn ES5 way: // Function expression cũ var users = [\u0026#34;Nam\u0026#34;, \u0026#34;Linh\u0026#34;, \u0026#34;Hoa\u0026#34;]; var uppercaseUsers = users.map(function (user) { return user.toUpperCase(); }); var button = document.getElementById(\u0026#34;btn\u0026#34;); button.addEventListener(\u0026#34;click\u0026#34;, function () { console.log(this); // \u0026#39;this\u0026#39; trỏ đến button }); ES6 way: // Arrow function - clean và concise const users = [\u0026#34;Nam\u0026#34;, \u0026#34;Linh\u0026#34;, \u0026#34;Hoa\u0026#34;]; const uppercaseUsers = users.map((user) =\u0026gt; user.toUpperCase()); // Với multiple parameters const add = (a, b) =\u0026gt; a + b; // Với function body const processUser = (user) =\u0026gt; { const processed = user.trim().toUpperCase(); return `Hello, ${processed}!`; }; // Lưu ý về \u0026#39;this\u0026#39; binding const obj = { name: \u0026#34;MyObject\u0026#34;, regularFunction() { console.log(this.name); // \u0026#39;MyObject\u0026#39; const arrowFunction = () =\u0026gt; { console.log(this.name); // \u0026#39;MyObject\u0026#39; - inherit từ parent scope }; arrowFunction(); }, }; Tip: Arrow function không có this binding riêng, nó inherit từ parent scope.\n3. Template Literals - Goodbye string concatenation! Cách cũ: var name = \u0026#34;Nam\u0026#34;; var age = 20; var city = \u0026#34;Ho Chi Minh\u0026#34;; var introduction = \u0026#34;Xin chào, tôi là \u0026#34; + name + \u0026#34;, \u0026#34; + age + \u0026#34; tuổi, \u0026#34; + \u0026#34;đến từ \u0026#34; + city + \u0026#34;.\u0026#34;; var htmlTemplate = \u0026#39;\u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt;\u0026#39; + \u0026#34;\u0026lt;h2\u0026gt;\u0026#34; + name + \u0026#34;\u0026lt;/h2\u0026gt;\u0026#34; + \u0026#34;\u0026lt;p\u0026gt;Age: \u0026#34; + age + \u0026#34;\u0026lt;/p\u0026gt;\u0026#34; + \u0026#34;\u0026lt;/div\u0026gt;\u0026#34;; Cách mới: const name = \u0026#34;Nam\u0026#34;; const age = 20; const city = \u0026#34;Ho Chi Minh\u0026#34;; // Template literals với backticks const introduction = `Xin chào, tôi là ${name}, ${age} tuổi, đến từ ${city}.`; // Multi-line strings dễ dàng const htmlTemplate = ` \u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;${name}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Age: ${age}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Status: ${age \u0026gt;= 18 ? \u0026#34;Adult\u0026#34; : \u0026#34;Minor\u0026#34;}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `; // Tagged template literals (advanced) function highlight(strings, ...values) { return strings.reduce((result, string, i) =\u0026gt; { const value = values[i] ? `\u0026lt;mark\u0026gt;${values[i]}\u0026lt;/mark\u0026gt;` : \u0026#34;\u0026#34;; return result + string + value; }, \u0026#34;\u0026#34;); } const highlighted = highlight`Tôi tên là ${name} và ${age} tuổi.`; 4. Destructuring - Unpack dữ liệu như ninja Array Destructuring: // Cách cũ var numbers = [1, 2, 3, 4, 5]; var first = numbers[0]; var second = numbers[1]; var rest = numbers.slice(2); // Cách mới const [first, second, ...rest] = [1, 2, 3, 4, 5]; console.log(first); // 1 console.log(second); // 2 console.log(rest); // [3, 4, 5] // Skip elements const [a, , c] = [1, 2, 3]; console.log(a, c); // 1, 3 // Default values const [x = 0, y = 0] = [1]; // x = 1, y = 0 Object Destructuring: // Cách cũ var user = { name: \u0026#34;Nam\u0026#34;, age: 20, email: \u0026#34;nam@example.com\u0026#34;, address: { city: \u0026#34;Ho Chi Minh\u0026#34;, district: \u0026#34;District 1\u0026#34;, }, }; var name = user.name; var age = user.age; var email = user.email; // Cách mới const { name, age, email } = user; // Rename variables const { name: userName, age: userAge } = user; // Nested destructuring const { address: { city, district }, } = user; // Default values const { phone = \u0026#34;N/A\u0026#34; } = user; // Function parameters destructuring function greetUser({ name, age = \u0026#34;unknown\u0026#34; }) { return `Hello ${name}, you are ${age} years old`; } greetUser({ name: \u0026#34;Nam\u0026#34;, age: 20 }); 5. Spread \u0026amp; Rest Operators - Ba chấm ma thuật Spread Operator (\u0026hellip;): // Array spreading const arr1 = [1, 2, 3]; const arr2 = [4, 5, 6]; const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6] // Object spreading const user = { name: \u0026#34;Nam\u0026#34;, age: 20 }; const updatedUser = { ...user, age: 21, city: \u0026#34;HCM\u0026#34; }; // { name: \u0026#39;Nam\u0026#39;, age: 21, city: \u0026#39;HCM\u0026#39; } // Function arguments function sum(a, b, c) { return a + b + c; } const numbers = [1, 2, 3]; console.log(sum(...numbers)); // 6 Rest Operator (\u0026hellip;): // Function parameters function logAll(first, ...others) { console.log(\u0026#34;First:\u0026#34;, first); console.log(\u0026#34;Others:\u0026#34;, others); } logAll(1, 2, 3, 4, 5); // First: 1, Others: [2, 3, 4, 5] // Array destructuring (đã thấy ở trên) const [head, ...tail] = [1, 2, 3, 4, 5]; 6. Enhanced Object Literals const name = \u0026#34;Nam\u0026#34;; const age = 20; // Cách cũ var user = { name: name, age: age, greet: function () { return \u0026#34;Hello!\u0026#34;; }, }; // Cách mới - shorthand properties const user = { name, // tương đương name: name age, // tương đương age: age // Method shorthand greet() { return \u0026#34;Hello!\u0026#34;; }, // Computed property names [`full${name}`]: `${name} Nguyen`, // Dynamic property [getPropertyName()]: \u0026#34;dynamic value\u0026#34;, }; 7. Promises \u0026amp; Async/Await - Tạm biệt Callback Hell Callback Hell: // Cách cũ - callback hell fetchUser(userId, function (user) { fetchUserPosts(user.id, function (posts) { fetchPostComments(posts[0].id, function (comments) { // Nested callbacks - khó đọc và maintain console.log(comments); }); }); }); Promises: // Promise chain fetchUser(userId) .then((user) =\u0026gt; fetchUserPosts(user.id)) .then((posts) =\u0026gt; fetchPostComments(posts[0].id)) .then((comments) =\u0026gt; console.log(comments)) .catch((error) =\u0026gt; console.error(error)); Async/Await: // Async/await - code như synchronous async function getUserData(userId) { try { const user = await fetchUser(userId); const posts = await fetchUserPosts(user.id); const comments = await fetchPostComments(posts[0].id); return comments; } catch (error) { console.error(\u0026#34;Error:\u0026#34;, error); throw error; } } // Sử dụng getUserData(123).then((data) =\u0026gt; console.log(data)); Kết luận ES6+ đã thực sự thay đổi cách mình viết JavaScript:\nCode ngắn gọn và dễ đọc hơn Ít bugs hơn nhờ let/const Xử lý async code dễ dàng hơn Destructuring giúp unpack data elegantly Tips cho người mới: Học từ từ - Đừng cố gắng học tất cả một lúc Practice daily - Viết code ES6+ mỗi ngày Use Babel - Để support browser cũ Read MDN docs - Tài liệu chính thức luôn tốt nhất Các bạn đã dùng feature nào trong số này chưa? Feature nào khiến các bạn ấn tượng nhất? Share ở comment nhé!\nModern JavaScript is beautiful! 🚀✨\n","permalink":"http://localhost:1313/blog/javascript-es6+/","tags":["javascript","es6","modern-js","kinh-nghiem"],"title":"JavaScript ES6+: Những tính năng đã thay đổi cách mình code"},{"categories":null,"contents":"","permalink":"http://localhost:1313/blog/promise-vs-completablefuture/intex/","tags":null,"title":""},{"categories":null,"contents":"Xin chào! Tôi là Tiết Thanh Minh Hiếu 👋 Câu chuyện của tôi Tôi là một sinh viên đang theo đuổi ước mơ trở thành chuyên viên An Ninh Mạng, với niềm đam mê bảo vệ thế giới số khỏi những mối đe dọa ngày càng phức tạp. Nhưng điều đặc biệt là tôi không chỉ muốn \u0026ldquo;làm\u0026rdquo; mà còn muốn \u0026ldquo;truyền cảm hứng\u0026rdquo; - mục tiêu của tôi là trở thành một giảng viên Security, người có thể biến những kiến thức phức tạp thành những bài học dễ hiểu và thú vị.\nTại sao tôi tạo blog này? Ban đầu, blog này được tạo ra để hoàn thành yêu cầu môn học về Java \u0026amp; JavaScript. Nhưng tôi nhận ra đây chính là cơ hội tuyệt vời để bắt đầu hành trình chia sẻ kiến thức mà tôi đã ấp ủ từ lâu.\nTôi tin rằng: Cách học tốt nhất là dạy lại cho người khác. Mỗi bài viết tôi chia sẻ không chỉ giúp các bạn đọc mà còn giúp tôi củng cố và mở rộng kiến thức của chính mình.\nNhững gì tôi đang làm 🔍 An Ninh Mạng Hiện tại tôi đang xây dựng nền tảng vững chắc với các chứng chỉ từ Google Cybersecurity và IBM. Kiến thức mạng cơ bản đã giúp tôi hiểu được \u0026ldquo;bức tranh lớn\u0026rdquo; của bảo mật.\n🤖 AI \u0026amp; Machine Learning Tôi có kinh nghiệm training model, đặc biệt là BERT. Dự án gần nhất của tôi là \u0026ldquo;Phát hiện mã độc Android bằng Transformer Networks (BERT)\u0026rdquo; - một project thú vị kết hợp giữa AI và Cybersecurity.\n💻 Lập trình Java và JavaScript là những ngôn ngữ tôi đang tập trung, nhưng hành trình coding của tôi không dừng lại ở đó!\nĐiều gì khiến blog này khác biệt? Không chỉ là lý thuyết khô khan. Tôi sẽ chia sẻ:\n✨ Kinh nghiệm thực tế từ các project đã làm 🎯 Cách tiếp cận thực tế thay vì chỉ đọc sách vở 🔧 Tips \u0026amp; tricks mà tôi học được qua quá trình \u0026ldquo;vấp ngã\u0026rdquo; 📚 Kiến thức được \u0026ldquo;dịch\u0026rdquo; sang ngôn ngữ dễ hiểu Mục tiêu của tôi là biến những khái niệm phức tạp thành những câu chuyện thú vị mà bất kỳ ai cũng có thể hiểu được.\nTầm nhìn tương lai Tôi mơ ước một ngày nào đó sẽ đứng trên bục giảng, truyền cảm hứng cho thế hệ các chuyên gia bảo mật tương lai. Blog này chính là bước đầu tiên trong hành trình rèn luyện kỹ năng truyền đạt của tôi.\nMỗi bài viết là một bài giảng nhỏ, mỗi chia sẻ là một lần thực hành để tôi có thể diễn đạt tốt hơn, rõ ràng hơn.\nLời kết Nếu bạn là người:\n🎓 Đang học về Cybersecurity, Java, JavaScript hoặc AI 🔍 Muốn hiểu cách áp dụng kiến thức vào thực tế 💡 Thích học thông qua kinh nghiệm thực tế hơn là lý thuyết suông Thì blog này dành cho bạn! Tôi hy vọng những chia sẻ của mình sẽ giúp ích cho hành trình học tập của các bạn, đồng thời cũng giúp tôi trở thành một người truyền đạt giỏi hơn.\nHãy cùng học, cùng phát triển và cùng tạo nên một cộng đồng tech Việt Nam mạnh mẽ! 🚀\n\u0026ldquo;The best way to learn is to teach others\u0026rdquo; - và đó chính là triết lý tôi theo đuổi trong mỗi bài viết.\n","permalink":"http://localhost:1313/about/","tags":null,"title":"Giới thiệu"},{"categories":null,"contents":"Trong lập trình mạng bằng Java, Socket là công cụ giúp kết nối giữa client và server.\nBằng cách sử dụng java.net.Socket và java.net.ServerSocket, ta có thể xây dựng các ứng dụng chat, truyền file hoặc HTTP server đơn giản.\nMô hình Client-Server cơ bản trong lập trình Socket Ở mức thấp hơn, kết nối TCP được thiết lập qua quá trình bắt tay 3 bước (TCP Handshake).\nĐiều này đảm bảo client và server đồng bộ trạng thái trước khi truyền dữ liệu.\nCơ chế bắt tay 3 bước TCP (Three-Way Handshake) ","permalink":"http://localhost:1313/blog/java-socket/","tags":["Java","Networking"],"title":"Kết nối Socket trong Java"},{"categories":["Programming"],"contents":"Chào các bạn! Hôm nay mình muốn chia sẻ về hành trình học lập trình của mình, từ Java đến JavaScript. Có lẽ nhiều bạn cũng đang băn khoăn giống mình: nên bắt đầu với ngôn ngữ nào? Học Java trước hay JavaScript trước?\nKhởi đầu với Java - Nền tảng vững chắc Mình bắt đầu với Java từ năm nhất đại học. Thật sự lúc đầu khá choáng với cú pháp dài dòng của Java:\npublic class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Hello, World!\u0026#34;); } } So với \u0026ldquo;Hello World\u0026rdquo; của JavaScript:\nconsole.log(\u0026#34;Hello, World!\u0026#34;); Wow, khác biệt quá phải không? Nhưng qua thời gian, mình nhận ra Java đã dạy mình những điều quan trọng:\n1. Tư duy hướng đối tượng (OOP) Java buộc mình phải hiểu về Class, Object, Inheritance\u0026hellip; Lúc đầu khó hiểu lắm, nhưng sau này khi làm dự án lớn mới thấy tầm quan trọng của nó.\n2. Tính nghiêm ngặt về kiểu dữ liệu int number = 10; // Phải khai báo kiểu rõ ràng String text = \u0026#34;Hello\u0026#34;; // Không thể gán số vào String 3. Cấu trúc dự án rõ ràng Package, import, access modifier\u0026hellip; tất cả đều có quy tắc rõ ràng.\nChuyển sang JavaScript - Tự do nhưng cần kỷ luật Khi bắt đầu học JavaScript, mình cảm thấy như được \u0026ldquo;giải phóng\u0026rdquo;:\nlet data = 10; // Kiểu number data = \u0026#34;Hello\u0026#34;; // Giờ thành string data = [1, 2, 3]; // Giờ thành array data = { name: \u0026#34;John\u0026#34; }; // Giờ thành object Tự do quá! Nhưng cũng dễ rối loạn không kém.\nNhững khác biệt chính mình nhận ra: Java:\nCompiled language (biên dịch trước) Strongly typed (kiểu dữ liệu nghiêm ngặt) Platform independent (chạy trên JVM) Chủ yếu cho backend JavaScript:\nInterpreted language (thông dịch) Dynamically typed (kiểu dữ liệu linh hoạt) Chạy trên browser/Node.js Full-stack (cả frontend và backend) Bài học rút ra 1. Java là nền tảng tốt để bắt đầu Nếu bạn chưa biết gì về lập trình, mình khuyên nên bắt đầu với Java. Tại sao?\nBuộc bạn phải viết code chuẩn Hiểu rõ về cấu trúc dữ liệu Tư duy logic tốt hơn 2. JavaScript cần kỷ luật bản thân Vì quá linh hoạt, JavaScript dễ làm cho code trở nên lộn xộn. Mình học được:\nĐặt tên biến có ý nghĩa Sử dụng const/let thay vì var Comment code đầy đủ 3. Cả hai đều có giá trị Java: Tốt cho hệ thống lớn, enterprise applications JavaScript: Linh hoạt, phát triển nhanh, cộng đồng active Lời kết Hành trình từ Java đến JavaScript đã dạy mình rằng không có ngôn ngữ nào là \u0026ldquo;tốt nhất\u0026rdquo;. Mỗi ngôn ngữ đều có ưu nhược điểm riêng. Quan trọng là hiểu rõ bản chất và áp dụng đúng context.\nCác bạn có kinh nghiệm gì thú vị khi học hai ngôn ngữ này không? Hãy chia sẻ trong comment nhé!\nHappy coding! 🚀\n","permalink":"http://localhost:1313/blog/java-to-javascript/","tags":["java","javascript","kinh-nghiem","hoc-tap"],"title":"Từ Java đến JavaScript: Hành trình học lập trình của mình"},{"categories":["Java"],"contents":"Xin chào các bạn! Hôm nay mình muốn chia sẻ về những sai lầm \u0026ldquo;kinh điển\u0026rdquo; mà hầu như ai học Java cũng mắc phải, bao gồm cả mình. Hy vọng qua bài viết này, các bạn newbie sẽ tránh được những \u0026ldquo;hố đen\u0026rdquo; mà mình đã rơi vào.\nSai lầm #1: Lạm dụng public static void main Mình từng làm thế này: public class Calculator { public static void main(String[] args) { // Viết tất cả logic trong main int a = 10, b = 5; int sum = a + b; int diff = a - b; int product = a * b; int quotient = a / b; System.out.println(\u0026#34;Sum: \u0026#34; + sum); System.out.println(\u0026#34;Difference: \u0026#34; + diff); // ... và còn 50 dòng code nữa } } Vấn đề: Code không thể tái sử dụng Khó debug và maintain Không theo nguyên tắc OOP Cách khắc phục: public class Calculator { public int add(int a, int b) { return a + b; } public int subtract(int a, int b) { return a - b; } public static void main(String[] args) { Calculator calc = new Calculator(); System.out.println(\u0026#34;Sum: \u0026#34; + calc.add(10, 5)); System.out.println(\u0026#34;Difference: \u0026#34; + calc.subtract(10, 5)); } } Sai lầm #2: Không hiểu về Reference vs Value Mình từng nghĩ: public class Student { String name; public static void main(String[] args) { Student s1 = new Student(); s1.name = \u0026#34;Nam\u0026#34;; Student s2 = s1; // Mình tưởng s2 là bản copy của s1 s2.name = \u0026#34;Linh\u0026#34;; System.out.println(s1.name); // Tại sao lại in ra \u0026#34;Linh\u0026#34;??? } } Bài học: Trong Java, object được truyền theo reference, không phải value. Khi gán s2 = s1, cả hai đều trỏ đến cùng một object trong memory.\nGiải pháp: public class Student implements Cloneable { String name; public Student(String name) { this.name = name; } // Constructor copy public Student(Student other) { this.name = other.name; } public static void main(String[] args) { Student s1 = new Student(\u0026#34;Nam\u0026#34;); Student s2 = new Student(s1); // Tạo object mới s2.name = \u0026#34;Linh\u0026#34;; System.out.println(s1.name); // \u0026#34;Nam\u0026#34; System.out.println(s2.name); // \u0026#34;Linh\u0026#34; } } Sai lầm #3: Không xử lý Exception đúng cách Code \u0026ldquo;tệ\u0026rdquo; của mình: public void readFile(String fileName) { try { FileReader file = new FileReader(fileName); BufferedReader reader = new BufferedReader(file); String line = reader.readLine(); System.out.println(line); } catch (Exception e) { // Im lặng, không làm gì cả - RỐT THẬM TỆ! } } Vấn đề: \u0026ldquo;Nuốt\u0026rdquo; exception mà không xử lý Sử dụng Exception quá general Không đóng resource Cách đúng: public void readFile(String fileName) { try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) { String line = reader.readLine(); if (line != null) { System.out.println(line); } } catch (FileNotFoundException e) { System.err.println(\u0026#34;Không tìm thấy file: \u0026#34; + fileName); // Log hoặc throw lại exception } catch (IOException e) { System.err.println(\u0026#34;Lỗi đọc file: \u0026#34; + e.getMessage()); } } Sai lầm #4: So sánh String bằng == Code sai: public class StringComparison { public static void main(String[] args) { String s1 = \u0026#34;Hello\u0026#34;; String s2 = new String(\u0026#34;Hello\u0026#34;); if (s1 == s2) { // SAAAIIII! System.out.println(\u0026#34;Equal\u0026#34;); } else { System.out.println(\u0026#34;Not equal\u0026#34;); // Sẽ in ra này } } } Giải thích: == so sánh reference, không phải content s1 trỏ đến String Pool s2 trỏ đến object mới trong heap Cách đúng: public class StringComparison { public static void main(String[] args) { String s1 = \u0026#34;Hello\u0026#34;; String s2 = new String(\u0026#34;Hello\u0026#34;); if (s1.equals(s2)) { // So sánh content System.out.println(\u0026#34;Equal\u0026#34;); } // Hoặc an toàn hơn với null check if (Objects.equals(s1, s2)) { System.out.println(\u0026#34;Equal and null-safe\u0026#34;); } } } Sai lầm #5: Không hiểu về Access Modifier Code của mình lúc trước: public class BankAccount { public double balance; // Ai cũng có thể truy cập! public BankAccount(double initialBalance) { balance = initialBalance; } } // Ở nơi khác BankAccount account = new BankAccount(1000); account.balance = -500; // Oops! Balance âm??? Vấn đề: Dữ liệu quan trọng không được bảo vệ Vi phạm nguyên tắc Encapsulation Cách khắc phục: public class BankAccount { private double balance; // Chỉ class này truy cập được public BankAccount(double initialBalance) { if (initialBalance \u0026gt;= 0) { this.balance = initialBalance; } else { throw new IllegalArgumentException(\u0026#34;Balance không thể âm\u0026#34;); } } public double getBalance() { return balance; } public void deposit(double amount) { if (amount \u0026gt; 0) { balance += amount; } } public boolean withdraw(double amount) { if (amount \u0026gt; 0 \u0026amp;\u0026amp; amount \u0026lt;= balance) { balance -= amount; return true; } return false; } } Tổng kết Những sai lầm này đã giúp mình hiểu sâu hơn về Java. Đừng sợ mắc lỗi, quan trọng là học hỏi từ chúng!\nTips để tránh sai lầm: Practice coding every day - Luyện tập thường xuyên Read other people\u0026rsquo;s code - Đọc code của người khác Use IDE effectively - Tận dụng IDE để catch lỗi sớm Code review - Nhờ bạn bè review code Read documentation - Đọc docs chính thức của Java Các bạn đã mắc phải sai lầm nào trong danh sách này chưa? Hoặc có sai lầm nào khác muốn chia sẻ? Comment bên dưới nhé!\nKeep learning, keep coding! ☕\n","permalink":"http://localhost:1313/blog/5-wrong-errors/","tags":["java","sai-lam","kinh-nghiem","hoc-tap"],"title":"5 Sai lầm phổ biến khi học Java mà mình đã mắc phải"},{"categories":["Async Programming"],"contents":"Chào các bạn! Async programming là một trong những concepts khó nhất khi học lập trình. Mình đã struggle với nó khá lâu, từ callback hell của JavaScript đến thread complexity của Java. Hôm nay mình muốn chia sẻ cách hai ngôn ngữ này handle async operations - JavaScript với Promise và Java với CompletableFuture.\nCâu chuyện bắt đầu từ Synchronous Hell JavaScript - Callback Hell // Cách xưa - callback nightmare! function getUserData(userId, callback) { fetchUser(userId, (user) =\u0026gt; { if (user) { fetchUserProfile(user.id, (profile) =\u0026gt; { if (profile) { fetchUserPosts(user.id, (posts) =\u0026gt; { if (posts) { fetchPostComments(posts[0].id, (comments) =\u0026gt; { // 4 levels deep! Pyramid of doom 😱 callback({ user, profile, posts, comments }); }); } else { callback(null, \u0026#34;No posts found\u0026#34;); } }); } else { callback(null, \u0026#34;Profile not found\u0026#34;); } }); } else { callback(null, \u0026#34;User not found\u0026#34;); } }); } Java - Thread Complexity // Cách xưa với Thread public void getUserDataOldWay(String userId) { new Thread(() -\u0026gt; { try { User user = fetchUser(userId); if (user != null) { new Thread(() -\u0026gt; { try { Profile profile = fetchUserProfile(user.getId()); if (profile != null) { // Nested threads everywhere! 😫 // Error handling nightmare // No easy way to combine results } } catch (Exception e) { // Handle error } }).start(); } } catch (Exception e) { // Handle error } }).start(); } JavaScript Promise - Giải cứu từ Callback Hell Promise Basics // Tạo Promise đơn giản function fetchUser(userId) { return new Promise((resolve, reject) =\u0026gt; { // Simulate API call setTimeout(() =\u0026gt; { if (userId \u0026gt; 0) { resolve({ id: userId, name: `User ${userId}` }); } else { reject(new Error(\u0026#34;Invalid user ID\u0026#34;)); } }, 1000); }); } // Sử dụng Promise fetchUser(123) .then((user) =\u0026gt; { console.log(\u0026#34;User:\u0026#34;, user); return user; // Pass data to next .then() }) .then((user) =\u0026gt; { // Chain another async operation return fetchUserProfile(user.id); }) .then((profile) =\u0026gt; { console.log(\u0026#34;Profile:\u0026#34;, profile); }) .catch((error) =\u0026gt; { console.error(\u0026#34;Error:\u0026#34;, error); }) .finally(() =\u0026gt; { console.log(\u0026#34;Cleanup code here\u0026#34;); }); Promise.all() - Chạy song song // Thay vì chạy tuần tự async function getUserDataSequential(userId) { const user = await fetchUser(userId); // 1s const profile = await fetchUserProfile(userId); // 1s const posts = await fetchUserPosts(userId); // 1s // Total: 3s return { user, profile, posts }; } // Chạy song song với Promise.all() async function getUserDataParallel(userId) { const [user, profile, posts] = await Promise.all([ fetchUser(userId), // All run in parallel fetchUserProfile(userId), // Total: 1s (longest operation) fetchUserPosts(userId), ]); return { user, profile, posts }; } // Promise.allSettled() - Không fail nếu 1 promise reject async function getUserDataSafe(userId) { const results = await Promise.allSettled([ fetchUser(userId), fetchUserProfile(userId), fetchUserPosts(userId), ]); return results.map((result) =\u0026gt; { if (result.status === \u0026#34;fulfilled\u0026#34;) { return result.value; } else { console.error(\u0026#34;Failed:\u0026#34;, result.reason); return null; } }); } Async/Await - Promise syntax đường // Từ Promise chain function getUserData(userId) { return fetchUser(userId) .then((user) =\u0026gt; fetchUserProfile(user.id)) .then((profile) =\u0026gt; fetchUserPosts(profile.userId)) .then((posts) =\u0026gt; ({ user, profile, posts })) .catch((error) =\u0026gt; { console.error(\u0026#34;Error:\u0026#34;, error); throw error; }); } // Đến async/await - clean hơn nhiều! async function getUserData(userId) { try { const user = await fetchUser(userId); const profile = await fetchUserProfile(user.id); const posts = await fetchUserPosts(profile.userId); return { user, profile, posts }; } catch (error) { console.error(\u0026#34;Error:\u0026#34;, error); throw error; } } Java CompletableFuture - Modern Async Java CompletableFuture Basics import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class AsyncService { private ExecutorService executor = Executors.newFixedThreadPool(10); // Tạo CompletableFuture đơn giản public CompletableFuture\u0026lt;User\u0026gt; fetchUser(String userId) { return CompletableFuture.supplyAsync(() -\u0026gt; { // Simulate delay try { Thread.sleep(1000); if (Integer.parseInt(userId) \u0026gt; 0) { return new User(userId, \u0026#34;User \u0026#34; + userId); } else { throw new RuntimeException(\u0026#34;Invalid user ID\u0026#34;); } } catch (InterruptedException e) { throw new RuntimeException(e); } }, executor); } // Chain operations public CompletableFuture\u0026lt;UserData\u0026gt; getUserData(String userId) { return fetchUser(userId) .thenCompose(user -\u0026gt; fetchUserProfile(user.getId()) .thenApply(profile -\u0026gt; new UserData(user, profile)) ) .thenCompose(userData -\u0026gt; fetchUserPosts(userData.getUser().getId()) .thenApply(posts -\u0026gt; { userData.setPosts(posts); return userData; }) ) .exceptionally(throwable -\u0026gt; { System.err.println(\u0026#34;Error: \u0026#34; + throwable.getMessage()); return null; }); } } Parallel Execution với CompletableFuture public CompletableFuture\u0026lt;UserData\u0026gt; getUserDataParallel(String userId) { CompletableFuture\u0026lt;User\u0026gt; userFuture = fetchUser(userId); CompletableFuture\u0026lt;Profile\u0026gt; profileFuture = fetchUserProfile(userId); CompletableFuture\u0026lt;List\u0026lt;Post\u0026gt;\u0026gt; postsFuture = fetchUserPosts(userId); // Combine all results return userFuture.thenCombine(profileFuture, (user, profile) -\u0026gt; new UserData(user, profile) ).thenCombine(postsFuture, (userData, posts) -\u0026gt; { userData.setPosts(posts); return userData; }); } // allOf() - giống Promise.all() public CompletableFuture\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; fetchMultipleUsers(List\u0026lt;String\u0026gt; userIds) { List\u0026lt;CompletableFuture\u0026lt;User\u0026gt;\u0026gt; futures = userIds.stream() .map(this::fetchUser) .collect(Collectors.toList()); CompletableFuture\u0026lt;Void\u0026gt; allFutures = CompletableFuture.allOf( futures.toArray(new CompletableFuture[0]) ); return allFutures.thenApply(v -\u0026gt; futures.stream() .map(CompletableFuture::join) // Get results .map(User::getName) .collect(Collectors.toList()) ); } So sánh trực tiếp Promise vs CompletableFuture 1. Tạo async operation JavaScript:\nconst promise = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(\u0026#34;Done!\u0026#34;), 1000); }); // Hoặc với async function const asyncFunction = async () =\u0026gt; { return \u0026#34;Done!\u0026#34;; }; Java:\nCompletableFuture\u0026lt;String\u0026gt; future = CompletableFuture.supplyAsync(() -\u0026gt; { try { Thread.sleep(1000); } catch (InterruptedException e) {} return \u0026#34;Done!\u0026#34;; }); // Hoặc completed future CompletableFuture\u0026lt;String\u0026gt; completedFuture = CompletableFuture.completedFuture(\u0026#34;Done!\u0026#34;); 2. Chain operations JavaScript:\npromise .then((result) =\u0026gt; result.toUpperCase()) .then((upper) =\u0026gt; upper + \u0026#34; - FINISHED\u0026#34;) .catch((error) =\u0026gt; \u0026#34;Error: \u0026#34; + error); Java:\nfuture .thenApply(result -\u0026gt; result.toUpperCase()) .thenApply(upper -\u0026gt; upper + \u0026#34; - FINISHED\u0026#34;) .exceptionally(error -\u0026gt; \u0026#34;Error: \u0026#34; + error.getMessage()); 3. Combine multiple operations JavaScript:\nPromise.all([promise1, promise2, promise3]).then( ([result1, result2, result3]) =\u0026gt; { return { result1, result2, result3 }; } ); Java:\nfuture1.thenCombine(future2, (r1, r2) -\u0026gt; new Pair(r1, r2)) .thenCombine(future3, (pair, r3) -\u0026gt; new Result(pair.getFirst(), pair.getSecond(), r3) ); // Hoặc với allOf CompletableFuture.allOf(future1, future2, future3) .thenApply(v -\u0026gt; new Result( future1.join(), future2.join(), future3.join() )); Real-world Example: API Gateway JavaScript Implementation: class APIGateway { async handleRequest(request) { try { // Authenticate user const user = await this.authenticate(request.token); // Fetch data in parallel const [userData, permissions, preferences] = await Promise.all([ this.fetchUserData(user.id), this.fetchUserPermissions(user.id), this.fetchUserPreferences(user.id), ]); // Transform data const response = await this.transformResponse({ user: userData, permissions, preferences, }); return response; } catch (error) { return this.handleError(error); } } async fetchUserData(userId) { const response = await fetch(`/api/users/${userId}`); if (!response.ok) { throw new Error(`HTTP ${response.status}`); } return response.json(); } } Java Implementation: @Service public class APIGateway { private final ExecutorService executor = Executors.newFixedThreadPool(20); public CompletableFuture\u0026lt;APIResponse\u0026gt; handleRequest(APIRequest request) { return authenticate(request.getToken()) .thenCompose(user -\u0026gt; { // Fetch data in parallel CompletableFuture\u0026lt;UserData\u0026gt; userDataFuture = fetchUserData(user.getId()); CompletableFuture\u0026lt;List\u0026lt;Permission\u0026gt;\u0026gt; permissionsFuture = fetchUserPermissions(user.getId()); CompletableFuture\u0026lt;Preferences\u0026gt; preferencesFuture = fetchUserPreferences(user.getId()); return userDataFuture.thenCombine(permissionsFuture, (userData, permissions) -\u0026gt; new Pair\u0026lt;\u0026gt;(userData, permissions)) .thenCombine(preferencesFuture, (pair, preferences) -\u0026gt; new RequestData(pair.getFirst(), pair.getSecond(), preferences) ); }) .thenCompose(this::transformResponse) .exceptionally(this::handleError); } private CompletableFuture\u0026lt;UserData\u0026gt; fetchUserData(String userId) { return CompletableFuture.supplyAsync(() -\u0026gt; { // HTTP call implementation try { return restTemplate.getForObject(\u0026#34;/api/users/\u0026#34; + userId, UserData.class); } catch (Exception e) { throw new RuntimeException(\u0026#34;Failed to fetch user data\u0026#34;, e); } }, executor); } } Performance \u0026amp; Lessons Learned Performance Comparison: JavaScript Promise: Single-threaded event loop, excellent cho I/O operations Java CompletableFuture: Multi-threaded, tốt cho CPU-intensive tasks Best Practices: JavaScript:\nLuôn dùng async/await thay vì .then() chains Dùng Promise.all() cho parallel operations Handle errors với try/catch Avoid creating unnecessary Promises Java:\nSử dụng custom ExecutorService Handle exceptions với exceptionally() hoặc handle() Dùng thenCombine() cho parallel operations Remember to shutdown ExecutorService Kết luận Cả Promise và CompletableFuture đều là tools mạnh mẽ cho async programming:\nPromise: Đơn giản hơn, syntax clean với async/await CompletableFuture: Mạnh mẽ hơn, control tốt hơn threading Quan trọng là hiểu concept async programming, sau đó syntax chỉ là matter of practice!\nCác bạn đã dùng async programming chưa? Share kinh nghiệm ở comment nhé!\nAsync is the future! ⚡🚀\n","permalink":"http://localhost:1313/blog/promise-vs-completablefuture/intex/","tags":["javascript","java","async","promise","completablefuture"],"title":"Async Programming: Promise (JS) vs CompletableFuture (Java) - Battle of Asynchronous!"},{"categories":["Backend Development"],"contents":"Xin chào các bạn! Sau khi học cả Java và JavaScript, mình có cơ hội làm việc với cả Spring Boot và Node.js trong các dự án thực tế. Hôm nay mình muốn chia sẻ trải nghiệm của mình khi develop backend với hai platform này.\nDự án đầu tiên với Spring Boot 🍃 Setup ban đầu Khi mới bắt đầu với Spring Boot, mình cảm thấy hơi choáng với số lượng config:\n// Application.java @SpringBootApplication public class BlogApplication { public static void main(String[] args) { SpringApplication.run(BlogApplication.class, args); } } // User.java - JPA Entity @Entity @Table(name = \u0026#34;users\u0026#34;) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, unique = true) private String email; @Column(nullable = false) private String password; // Constructor, getters, setters... } // UserRepository.java @Repository public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt; { Optional\u0026lt;User\u0026gt; findByEmail(String email); } // UserController.java @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) public class UserController { @Autowired private UserService userService; @PostMapping public ResponseEntity\u0026lt;User\u0026gt; createUser(@Valid @RequestBody UserDTO userDTO) { User user = userService.createUser(userDTO); return ResponseEntity.status(HttpStatus.CREATED).body(user); } } Những điều mình thích ở Spring Boot: Convention over Configuration - Ít config hơn Spring truyền thống Dependency Injection - Auto-wiring cực kỳ mạnh mẽ JPA/Hibernate - ORM mạnh mẽ, query phức tạp dễ dàng Security - Spring Security handle authentication/authorization tốt Testing - Test infrastructure rất complete Những khó khăn: Learning curve - Cần hiểu về Spring ecosystem Memory usage - JVM khá \u0026ldquo;nặng\u0026rdquo; Startup time - Khởi động chậm hơn Node.js Annotation hell - Quá nhiều annotation có thể confusing Chuyển sang Node.js - Một thế giới khác 🚀 Express.js setup // app.js const express = require(\u0026#34;express\u0026#34;); const mongoose = require(\u0026#34;mongoose\u0026#34;); const bcrypt = require(\u0026#34;bcryptjs\u0026#34;); const jwt = require(\u0026#34;jsonwebtoken\u0026#34;); const app = express(); app.use(express.json()); // User Model với Mongoose const userSchema = new mongoose.Schema({ email: { type: String, required: true, unique: true }, password: { type: String, required: true }, createdAt: { type: Date, default: Date.now }, }); const User = mongoose.model(\u0026#34;User\u0026#34;, userSchema); // User Routes app.post(\u0026#34;/api/users\u0026#34;, async (req, res) =\u0026gt; { try { const { email, password } = req.body; const existingUser = await User.findOne({ email }); if (existingUser) { return res.status(400).json({ message: \u0026#34;User already exists\u0026#34; }); } const hashedPassword = await bcrypt.hash(password, 10); const user = new User({ email, password: hashedPassword }); await user.save(); res.status(201).json({ id: user._id, email: user.email }); } catch (error) { res.status(500).json({ message: error.message }); } }); // Connect to MongoDB mongoose .connect(\u0026#34;mongodb://localhost:27017/myapp\u0026#34;) .then(() =\u0026gt; console.log(\u0026#34;Connected to MongoDB\u0026#34;)) .catch((err) =\u0026gt; console.error(\u0026#34;MongoDB connection error:\u0026#34;, err)); app.listen(3000, () =\u0026gt; { console.log(\u0026#34;Server running on port 3000\u0026#34;); }); Những điều mình thích ở Node.js: Fast development - Viết code nhanh, setup đơn giản JavaScript everywhere - Same language frontend/backend NPM ecosystem - Package có sẵn cho mọi thứ Lightweight - Memory footprint nhỏ hơn JVM Fast startup - Server khởi động trong giây lát Những thách thức: Callback/Promise hell - Nếu không handle tốt async code Single-threaded - CPU-intensive tasks có thể block Type safety - JavaScript dynamic typing đôi khi gây bugs Package management - Dependency hell với npm So sánh thực tế qua dự án Dự án E-commerce Platform Mình đã implement cùng một API cho hệ thống e-commerce với cả hai technologies:\nPerformance Test Results: Concurrent Users: 1000\rTest Duration: 5 minutes\rSpring Boot (Java 17 + PostgreSQL):\r- Average Response Time: 45ms\r- Throughput: 2,200 req/sec\r- Memory Usage: 512MB\r- CPU Usage: 35%\rNode.js (Express + MongoDB):\r- Average Response Time: 38ms\r- Throughput: 2,800 req/sec\r- Memory Usage: 128MB\r- CPU Usage: 28% Development Speed: Spring Boot:\nSetup time: 30 phút (config database, dependencies) CRUD operations: 2 giờ Authentication: 1 giờ (Spring Security) Unit tests: 1.5 giờ Total: ~5 giờ Node.js:\nSetup time: 10 phút CRUD operations: 1 giờ Authentication: 1.5 giờ (custom JWT) Unit tests: 1 giờ Total: ~3.5 giờ Khi nào dùng gì? Chọn Spring Boot khi: ✅ Enterprise applications - Cần security, scalability cao\n✅ Complex business logic - Nhiều rules phức tạp\n✅ Team lớn - Structure rõ ràng, maintainable\n✅ Legacy systems - Integration với Java ecosystem\n✅ Microservices - Spring Cloud ecosystem mạnh\n// Example: Complex business logic dễ handle với Java @Service @Transactional public class OrderService { public Order processOrder(OrderRequest request) { // Validate inventory inventoryService.checkAvailability(request.getItems()); // Apply discounts BigDecimal finalAmount = pricingService .calculateDiscount(request, customer.getTier()); // Process payment PaymentResult payment = paymentService .processPayment(customer.getPaymentMethod(), finalAmount); if (payment.isSuccessful()) { // Create order Order order = orderRepository.save( Order.builder() .customerId(customer.getId()) .amount(finalAmount) .status(OrderStatus.CONFIRMED) .build() ); // Send notifications notificationService.sendOrderConfirmation(order); return order; } throw new PaymentProcessingException(\u0026#34;Payment failed\u0026#34;); } } Chọn Node.js khi: ✅ Rapid prototyping - Cần develop nhanh\n✅ Real-time apps - Chat, live updates (Socket.io)\n✅ API-first approach - RESTful APIs đơn giản\n✅ Startup/Small team - Ít developers, cần flexibility\n✅ I/O intensive - Nhiều database calls, external APIs\n// Example: Real-time chat với Socket.io const io = require(\u0026#34;socket.io\u0026#34;)(server); io.on(\u0026#34;connection\u0026#34;, (socket) =\u0026gt; { console.log(\u0026#34;User connected:\u0026#34;, socket.id); socket.on(\u0026#34;join-room\u0026#34;, (roomId) =\u0026gt; { socket.join(roomId); socket.to(roomId).emit(\u0026#34;user-joined\u0026#34;, socket.id); }); socket.on(\u0026#34;message\u0026#34;, async (data) =\u0026gt; { // Save to database const message = await Message.create({ content: data.message, userId: data.userId, roomId: data.roomId, }); // Broadcast to room io.to(data.roomId).emit(\u0026#34;new-message\u0026#34;, message); }); socket.on(\u0026#34;disconnect\u0026#34;, () =\u0026gt; { console.log(\u0026#34;User disconnected:\u0026#34;, socket.id); }); }); Lessons Learned 1. Không có \u0026ldquo;silver bullet\u0026rdquo; Cả hai đều có ưu nhược điểm. Quan trọng là chọn tool phù hợp với requirements.\n2. Team skill matter Team giỏi Java → Spring Boot sẽ productive hơn Team frontend developers → Node.js dễ tiếp cận hơn 3. Maintenance is key Spring Boot có structure rõ ràng hơn cho long-term projects.\n4. Performance isn\u0026rsquo;t everything Developer productivity và time-to-market cũng quan trọng.\nKết luận Sau kinh nghiệm với cả hai, mình nhận ra:\nSpring Boot giống như một chiếc Mercedes - robust, reliable, powerful nhưng cần thời gian để master.\nNode.js giống như một chiếc motorbike - agile, fast, flexible nhưng cần cẩn thận khi handle complex scenarios.\nHiện tại mình đang sử dụng:\nSpring Boot cho enterprise projects, complex business logic Node.js cho prototypes, real-time features, simple APIs Các bạn có kinh nghiệm gì với hai platform này? Share ở comment nhé!\nChoose the right tool for the job! 🛠️\n","permalink":"http://localhost:1313/blog/springboot-vs-nodejs/","tags":["java","javascript","spring-boot","nodejs","backend"],"title":"Spring Boot vs Node.js: Trải nghiệm backend development của mình"},{"categories":["JavaScript"],"contents":"Chào mọi người! Khi mới học JavaScript, mình chỉ biết đến cú pháp cũ ES5. Nhưng khi tiếp xúc với ES6+ (ES2015 trở lên), thật sự mình cảm thấy như được \u0026ldquo;khai sáng\u0026rdquo;. Hôm nay mình muốn chia sẻ những tính năng ES6+ đã thay đổi hoàn toàn cách mình viết JavaScript.\n1. Let \u0026amp; Const - Tạm biệt var nhé! Cách cũ với var: // Vấn đề với var function oldWay() { for (var i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; { console.log(i); // In ra 3, 3, 3 (WTF???) }, 100); } console.log(i); // 3 - i vẫn tồn tại ngoài loop! } Cách mới với let \u0026amp; const: function newWay() { for (let i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; { console.log(i); // In ra 0, 1, 2 (chính xác!) }, 100); } // console.log(i); // ReferenceError - i không tồn tại ở đây const API_URL = \u0026#34;https://api.example.com\u0026#34;; // API_URL = \u0026#39;other-url\u0026#39;; // TypeError - không thể reassign const } Bài học: Luôn dùng const cho giá trị không thay đổi, let cho biến có thể thay đổi. Quên var đi!\n2. Arrow Functions - Code ngắn gọn hơn ES5 way: // Function expression cũ var users = [\u0026#34;Nam\u0026#34;, \u0026#34;Linh\u0026#34;, \u0026#34;Hoa\u0026#34;]; var uppercaseUsers = users.map(function (user) { return user.toUpperCase(); }); var button = document.getElementById(\u0026#34;btn\u0026#34;); button.addEventListener(\u0026#34;click\u0026#34;, function () { console.log(this); // \u0026#39;this\u0026#39; trỏ đến button }); ES6 way: // Arrow function - clean và concise const users = [\u0026#34;Nam\u0026#34;, \u0026#34;Linh\u0026#34;, \u0026#34;Hoa\u0026#34;]; const uppercaseUsers = users.map((user) =\u0026gt; user.toUpperCase()); // Với multiple parameters const add = (a, b) =\u0026gt; a + b; // Với function body const processUser = (user) =\u0026gt; { const processed = user.trim().toUpperCase(); return `Hello, ${processed}!`; }; // Lưu ý về \u0026#39;this\u0026#39; binding const obj = { name: \u0026#34;MyObject\u0026#34;, regularFunction() { console.log(this.name); // \u0026#39;MyObject\u0026#39; const arrowFunction = () =\u0026gt; { console.log(this.name); // \u0026#39;MyObject\u0026#39; - inherit từ parent scope }; arrowFunction(); }, }; Tip: Arrow function không có this binding riêng, nó inherit từ parent scope.\n3. Template Literals - Goodbye string concatenation! Cách cũ: var name = \u0026#34;Nam\u0026#34;; var age = 20; var city = \u0026#34;Ho Chi Minh\u0026#34;; var introduction = \u0026#34;Xin chào, tôi là \u0026#34; + name + \u0026#34;, \u0026#34; + age + \u0026#34; tuổi, \u0026#34; + \u0026#34;đến từ \u0026#34; + city + \u0026#34;.\u0026#34;; var htmlTemplate = \u0026#39;\u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt;\u0026#39; + \u0026#34;\u0026lt;h2\u0026gt;\u0026#34; + name + \u0026#34;\u0026lt;/h2\u0026gt;\u0026#34; + \u0026#34;\u0026lt;p\u0026gt;Age: \u0026#34; + age + \u0026#34;\u0026lt;/p\u0026gt;\u0026#34; + \u0026#34;\u0026lt;/div\u0026gt;\u0026#34;; Cách mới: const name = \u0026#34;Nam\u0026#34;; const age = 20; const city = \u0026#34;Ho Chi Minh\u0026#34;; // Template literals với backticks const introduction = `Xin chào, tôi là ${name}, ${age} tuổi, đến từ ${city}.`; // Multi-line strings dễ dàng const htmlTemplate = ` \u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;${name}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Age: ${age}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Status: ${age \u0026gt;= 18 ? \u0026#34;Adult\u0026#34; : \u0026#34;Minor\u0026#34;}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `; // Tagged template literals (advanced) function highlight(strings, ...values) { return strings.reduce((result, string, i) =\u0026gt; { const value = values[i] ? `\u0026lt;mark\u0026gt;${values[i]}\u0026lt;/mark\u0026gt;` : \u0026#34;\u0026#34;; return result + string + value; }, \u0026#34;\u0026#34;); } const highlighted = highlight`Tôi tên là ${name} và ${age} tuổi.`; 4. Destructuring - Unpack dữ liệu như ninja Array Destructuring: // Cách cũ var numbers = [1, 2, 3, 4, 5]; var first = numbers[0]; var second = numbers[1]; var rest = numbers.slice(2); // Cách mới const [first, second, ...rest] = [1, 2, 3, 4, 5]; console.log(first); // 1 console.log(second); // 2 console.log(rest); // [3, 4, 5] // Skip elements const [a, , c] = [1, 2, 3]; console.log(a, c); // 1, 3 // Default values const [x = 0, y = 0] = [1]; // x = 1, y = 0 Object Destructuring: // Cách cũ var user = { name: \u0026#34;Nam\u0026#34;, age: 20, email: \u0026#34;nam@example.com\u0026#34;, address: { city: \u0026#34;Ho Chi Minh\u0026#34;, district: \u0026#34;District 1\u0026#34;, }, }; var name = user.name; var age = user.age; var email = user.email; // Cách mới const { name, age, email } = user; // Rename variables const { name: userName, age: userAge } = user; // Nested destructuring const { address: { city, district }, } = user; // Default values const { phone = \u0026#34;N/A\u0026#34; } = user; // Function parameters destructuring function greetUser({ name, age = \u0026#34;unknown\u0026#34; }) { return `Hello ${name}, you are ${age} years old`; } greetUser({ name: \u0026#34;Nam\u0026#34;, age: 20 }); 5. Spread \u0026amp; Rest Operators - Ba chấm ma thuật Spread Operator (\u0026hellip;): // Array spreading const arr1 = [1, 2, 3]; const arr2 = [4, 5, 6]; const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6] // Object spreading const user = { name: \u0026#34;Nam\u0026#34;, age: 20 }; const updatedUser = { ...user, age: 21, city: \u0026#34;HCM\u0026#34; }; // { name: \u0026#39;Nam\u0026#39;, age: 21, city: \u0026#39;HCM\u0026#39; } // Function arguments function sum(a, b, c) { return a + b + c; } const numbers = [1, 2, 3]; console.log(sum(...numbers)); // 6 Rest Operator (\u0026hellip;): // Function parameters function logAll(first, ...others) { console.log(\u0026#34;First:\u0026#34;, first); console.log(\u0026#34;Others:\u0026#34;, others); } logAll(1, 2, 3, 4, 5); // First: 1, Others: [2, 3, 4, 5] // Array destructuring (đã thấy ở trên) const [head, ...tail] = [1, 2, 3, 4, 5]; 6. Enhanced Object Literals const name = \u0026#34;Nam\u0026#34;; const age = 20; // Cách cũ var user = { name: name, age: age, greet: function () { return \u0026#34;Hello!\u0026#34;; }, }; // Cách mới - shorthand properties const user = { name, // tương đương name: name age, // tương đương age: age // Method shorthand greet() { return \u0026#34;Hello!\u0026#34;; }, // Computed property names [`full${name}`]: `${name} Nguyen`, // Dynamic property [getPropertyName()]: \u0026#34;dynamic value\u0026#34;, }; 7. Promises \u0026amp; Async/Await - Tạm biệt Callback Hell Callback Hell: // Cách cũ - callback hell fetchUser(userId, function (user) { fetchUserPosts(user.id, function (posts) { fetchPostComments(posts[0].id, function (comments) { // Nested callbacks - khó đọc và maintain console.log(comments); }); }); }); Promises: // Promise chain fetchUser(userId) .then((user) =\u0026gt; fetchUserPosts(user.id)) .then((posts) =\u0026gt; fetchPostComments(posts[0].id)) .then((comments) =\u0026gt; console.log(comments)) .catch((error) =\u0026gt; console.error(error)); Async/Await: // Async/await - code như synchronous async function getUserData(userId) { try { const user = await fetchUser(userId); const posts = await fetchUserPosts(user.id); const comments = await fetchPostComments(posts[0].id); return comments; } catch (error) { console.error(\u0026#34;Error:\u0026#34;, error); throw error; } } // Sử dụng getUserData(123).then((data) =\u0026gt; console.log(data)); Kết luận ES6+ đã thực sự thay đổi cách mình viết JavaScript:\nCode ngắn gọn và dễ đọc hơn Ít bugs hơn nhờ let/const Xử lý async code dễ dàng hơn Destructuring giúp unpack data elegantly Tips cho người mới: Học từ từ - Đừng cố gắng học tất cả một lúc Practice daily - Viết code ES6+ mỗi ngày Use Babel - Để support browser cũ Read MDN docs - Tài liệu chính thức luôn tốt nhất Các bạn đã dùng feature nào trong số này chưa? Feature nào khiến các bạn ấn tượng nhất? Share ở comment nhé!\nModern JavaScript is beautiful! 🚀✨\n","permalink":"http://localhost:1313/blog/javascript-es6+/","tags":["javascript","es6","modern-js","kinh-nghiem"],"title":"JavaScript ES6+: Những tính năng đã thay đổi cách mình code"},{"categories":null,"contents":"Xin chào! Tôi là Tiết Thanh Minh Hiếu 👋 Câu chuyện của tôi Tôi là một sinh viên đang theo đuổi ước mơ trở thành chuyên viên An Ninh Mạng, với niềm đam mê bảo vệ thế giới số khỏi những mối đe dọa ngày càng phức tạp. Nhưng điều đặc biệt là tôi không chỉ muốn \u0026ldquo;làm\u0026rdquo; mà còn muốn \u0026ldquo;truyền cảm hứng\u0026rdquo; - mục tiêu của tôi là trở thành một giảng viên Security, người có thể biến những kiến thức phức tạp thành những bài học dễ hiểu và thú vị.\nTại sao tôi tạo blog này? Ban đầu, blog này được tạo ra để hoàn thành yêu cầu môn học về Java \u0026amp; JavaScript. Nhưng tôi nhận ra đây chính là cơ hội tuyệt vời để bắt đầu hành trình chia sẻ kiến thức mà tôi đã ấp ủ từ lâu.\nTôi tin rằng: Cách học tốt nhất là dạy lại cho người khác. Mỗi bài viết tôi chia sẻ không chỉ giúp các bạn đọc mà còn giúp tôi củng cố và mở rộng kiến thức của chính mình.\nNhững gì tôi đang làm 🔍 An Ninh Mạng Hiện tại tôi đang xây dựng nền tảng vững chắc với các chứng chỉ từ Google Cybersecurity và IBM. Kiến thức mạng cơ bản đã giúp tôi hiểu được \u0026ldquo;bức tranh lớn\u0026rdquo; của bảo mật.\n🤖 AI \u0026amp; Machine Learning Tôi có kinh nghiệm training model, đặc biệt là BERT. Dự án gần nhất của tôi là \u0026ldquo;Phát hiện mã độc Android bằng Transformer Networks (BERT)\u0026rdquo; - một project thú vị kết hợp giữa AI và Cybersecurity.\n💻 Lập trình Java và JavaScript là những ngôn ngữ tôi đang tập trung, nhưng hành trình coding của tôi không dừng lại ở đó!\nĐiều gì khiến blog này khác biệt? Không chỉ là lý thuyết khô khan. Tôi sẽ chia sẻ:\n✨ Kinh nghiệm thực tế từ các project đã làm 🎯 Cách tiếp cận thực tế thay vì chỉ đọc sách vở 🔧 Tips \u0026amp; tricks mà tôi học được qua quá trình \u0026ldquo;vấp ngã\u0026rdquo; 📚 Kiến thức được \u0026ldquo;dịch\u0026rdquo; sang ngôn ngữ dễ hiểu Mục tiêu của tôi là biến những khái niệm phức tạp thành những câu chuyện thú vị mà bất kỳ ai cũng có thể hiểu được.\nTầm nhìn tương lai Tôi mơ ước một ngày nào đó sẽ đứng trên bục giảng, truyền cảm hứng cho thế hệ các chuyên gia bảo mật tương lai. Blog này chính là bước đầu tiên trong hành trình rèn luyện kỹ năng truyền đạt của tôi.\nMỗi bài viết là một bài giảng nhỏ, mỗi chia sẻ là một lần thực hành để tôi có thể diễn đạt tốt hơn, rõ ràng hơn.\nLời kết Nếu bạn là người:\n🎓 Đang học về Cybersecurity, Java, JavaScript hoặc AI 🔍 Muốn hiểu cách áp dụng kiến thức vào thực tế 💡 Thích học thông qua kinh nghiệm thực tế hơn là lý thuyết suông Thì blog này dành cho bạn! Tôi hy vọng những chia sẻ của mình sẽ giúp ích cho hành trình học tập của các bạn, đồng thời cũng giúp tôi trở thành một người truyền đạt giỏi hơn.\nHãy cùng học, cùng phát triển và cùng tạo nên một cộng đồng tech Việt Nam mạnh mẽ! 🚀\n\u0026ldquo;The best way to learn is to teach others\u0026rdquo; - và đó chính là triết lý tôi theo đuổi trong mỗi bài viết.\n","permalink":"http://localhost:1313/about/","tags":null,"title":"Giới thiệu"},{"categories":null,"contents":"Trong lập trình mạng bằng Java, Socket là công cụ giúp kết nối giữa client và server.\nBằng cách sử dụng java.net.Socket và java.net.ServerSocket, ta có thể xây dựng các ứng dụng chat, truyền file hoặc HTTP server đơn giản.\nMô hình Client-Server cơ bản trong lập trình Socket Ở mức thấp hơn, kết nối TCP được thiết lập qua quá trình bắt tay 3 bước (TCP Handshake).\nĐiều này đảm bảo client và server đồng bộ trạng thái trước khi truyền dữ liệu.\nCơ chế bắt tay 3 bước TCP (Three-Way Handshake) ","permalink":"http://localhost:1313/blog/java-socket/","tags":["Java","Networking"],"title":"Kết nối Socket trong Java"},{"categories":["Programming"],"contents":"Chào các bạn! Hôm nay mình muốn chia sẻ về hành trình học lập trình của mình, từ Java đến JavaScript. Có lẽ nhiều bạn cũng đang băn khoăn giống mình: nên bắt đầu với ngôn ngữ nào? Học Java trước hay JavaScript trước?\nKhởi đầu với Java - Nền tảng vững chắc Mình bắt đầu với Java từ năm nhất đại học. Thật sự lúc đầu khá choáng với cú pháp dài dòng của Java:\npublic class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Hello, World!\u0026#34;); } } So với \u0026ldquo;Hello World\u0026rdquo; của JavaScript:\nconsole.log(\u0026#34;Hello, World!\u0026#34;); Wow, khác biệt quá phải không? Nhưng qua thời gian, mình nhận ra Java đã dạy mình những điều quan trọng:\n1. Tư duy hướng đối tượng (OOP) Java buộc mình phải hiểu về Class, Object, Inheritance\u0026hellip; Lúc đầu khó hiểu lắm, nhưng sau này khi làm dự án lớn mới thấy tầm quan trọng của nó.\n2. Tính nghiêm ngặt về kiểu dữ liệu int number = 10; // Phải khai báo kiểu rõ ràng String text = \u0026#34;Hello\u0026#34;; // Không thể gán số vào String 3. Cấu trúc dự án rõ ràng Package, import, access modifier\u0026hellip; tất cả đều có quy tắc rõ ràng.\nChuyển sang JavaScript - Tự do nhưng cần kỷ luật Khi bắt đầu học JavaScript, mình cảm thấy như được \u0026ldquo;giải phóng\u0026rdquo;:\nlet data = 10; // Kiểu number data = \u0026#34;Hello\u0026#34;; // Giờ thành string data = [1, 2, 3]; // Giờ thành array data = { name: \u0026#34;John\u0026#34; }; // Giờ thành object Tự do quá! Nhưng cũng dễ rối loạn không kém.\nNhững khác biệt chính mình nhận ra: Java:\nCompiled language (biên dịch trước) Strongly typed (kiểu dữ liệu nghiêm ngặt) Platform independent (chạy trên JVM) Chủ yếu cho backend JavaScript:\nInterpreted language (thông dịch) Dynamically typed (kiểu dữ liệu linh hoạt) Chạy trên browser/Node.js Full-stack (cả frontend và backend) Bài học rút ra 1. Java là nền tảng tốt để bắt đầu Nếu bạn chưa biết gì về lập trình, mình khuyên nên bắt đầu với Java. Tại sao?\nBuộc bạn phải viết code chuẩn Hiểu rõ về cấu trúc dữ liệu Tư duy logic tốt hơn 2. JavaScript cần kỷ luật bản thân Vì quá linh hoạt, JavaScript dễ làm cho code trở nên lộn xộn. Mình học được:\nĐặt tên biến có ý nghĩa Sử dụng const/let thay vì var Comment code đầy đủ 3. Cả hai đều có giá trị Java: Tốt cho hệ thống lớn, enterprise applications JavaScript: Linh hoạt, phát triển nhanh, cộng đồng active Lời kết Hành trình từ Java đến JavaScript đã dạy mình rằng không có ngôn ngữ nào là \u0026ldquo;tốt nhất\u0026rdquo;. Mỗi ngôn ngữ đều có ưu nhược điểm riêng. Quan trọng là hiểu rõ bản chất và áp dụng đúng context.\nCác bạn có kinh nghiệm gì thú vị khi học hai ngôn ngữ này không? Hãy chia sẻ trong comment nhé!\nHappy coding! 🚀\n","permalink":"http://localhost:1313/blog/java-to-javascript/","tags":["java","javascript","kinh-nghiem","hoc-tap"],"title":"Từ Java đến JavaScript: Hành trình học lập trình của mình"},{"categories":["Java"],"contents":"Xin chào các bạn! Hôm nay mình muốn chia sẻ về những sai lầm \u0026ldquo;kinh điển\u0026rdquo; mà hầu như ai học Java cũng mắc phải, bao gồm cả mình. Hy vọng qua bài viết này, các bạn newbie sẽ tránh được những \u0026ldquo;hố đen\u0026rdquo; mà mình đã rơi vào.\nSai lầm #1: Lạm dụng public static void main Mình từng làm thế này: public class Calculator { public static void main(String[] args) { // Viết tất cả logic trong main int a = 10, b = 5; int sum = a + b; int diff = a - b; int product = a * b; int quotient = a / b; System.out.println(\u0026#34;Sum: \u0026#34; + sum); System.out.println(\u0026#34;Difference: \u0026#34; + diff); // ... và còn 50 dòng code nữa } } Vấn đề: Code không thể tái sử dụng Khó debug và maintain Không theo nguyên tắc OOP Cách khắc phục: public class Calculator { public int add(int a, int b) { return a + b; } public int subtract(int a, int b) { return a - b; } public static void main(String[] args) { Calculator calc = new Calculator(); System.out.println(\u0026#34;Sum: \u0026#34; + calc.add(10, 5)); System.out.println(\u0026#34;Difference: \u0026#34; + calc.subtract(10, 5)); } } Sai lầm #2: Không hiểu về Reference vs Value Mình từng nghĩ: public class Student { String name; public static void main(String[] args) { Student s1 = new Student(); s1.name = \u0026#34;Nam\u0026#34;; Student s2 = s1; // Mình tưởng s2 là bản copy của s1 s2.name = \u0026#34;Linh\u0026#34;; System.out.println(s1.name); // Tại sao lại in ra \u0026#34;Linh\u0026#34;??? } } Bài học: Trong Java, object được truyền theo reference, không phải value. Khi gán s2 = s1, cả hai đều trỏ đến cùng một object trong memory.\nGiải pháp: public class Student implements Cloneable { String name; public Student(String name) { this.name = name; } // Constructor copy public Student(Student other) { this.name = other.name; } public static void main(String[] args) { Student s1 = new Student(\u0026#34;Nam\u0026#34;); Student s2 = new Student(s1); // Tạo object mới s2.name = \u0026#34;Linh\u0026#34;; System.out.println(s1.name); // \u0026#34;Nam\u0026#34; System.out.println(s2.name); // \u0026#34;Linh\u0026#34; } } Sai lầm #3: Không xử lý Exception đúng cách Code \u0026ldquo;tệ\u0026rdquo; của mình: public void readFile(String fileName) { try { FileReader file = new FileReader(fileName); BufferedReader reader = new BufferedReader(file); String line = reader.readLine(); System.out.println(line); } catch (Exception e) { // Im lặng, không làm gì cả - RỐT THẬM TỆ! } } Vấn đề: \u0026ldquo;Nuốt\u0026rdquo; exception mà không xử lý Sử dụng Exception quá general Không đóng resource Cách đúng: public void readFile(String fileName) { try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) { String line = reader.readLine(); if (line != null) { System.out.println(line); } } catch (FileNotFoundException e) { System.err.println(\u0026#34;Không tìm thấy file: \u0026#34; + fileName); // Log hoặc throw lại exception } catch (IOException e) { System.err.println(\u0026#34;Lỗi đọc file: \u0026#34; + e.getMessage()); } } Sai lầm #4: So sánh String bằng == Code sai: public class StringComparison { public static void main(String[] args) { String s1 = \u0026#34;Hello\u0026#34;; String s2 = new String(\u0026#34;Hello\u0026#34;); if (s1 == s2) { // SAAAIIII! System.out.println(\u0026#34;Equal\u0026#34;); } else { System.out.println(\u0026#34;Not equal\u0026#34;); // Sẽ in ra này } } } Giải thích: == so sánh reference, không phải content s1 trỏ đến String Pool s2 trỏ đến object mới trong heap Cách đúng: public class StringComparison { public static void main(String[] args) { String s1 = \u0026#34;Hello\u0026#34;; String s2 = new String(\u0026#34;Hello\u0026#34;); if (s1.equals(s2)) { // So sánh content System.out.println(\u0026#34;Equal\u0026#34;); } // Hoặc an toàn hơn với null check if (Objects.equals(s1, s2)) { System.out.println(\u0026#34;Equal and null-safe\u0026#34;); } } } Sai lầm #5: Không hiểu về Access Modifier Code của mình lúc trước: public class BankAccount { public double balance; // Ai cũng có thể truy cập! public BankAccount(double initialBalance) { balance = initialBalance; } } // Ở nơi khác BankAccount account = new BankAccount(1000); account.balance = -500; // Oops! Balance âm??? Vấn đề: Dữ liệu quan trọng không được bảo vệ Vi phạm nguyên tắc Encapsulation Cách khắc phục: public class BankAccount { private double balance; // Chỉ class này truy cập được public BankAccount(double initialBalance) { if (initialBalance \u0026gt;= 0) { this.balance = initialBalance; } else { throw new IllegalArgumentException(\u0026#34;Balance không thể âm\u0026#34;); } } public double getBalance() { return balance; } public void deposit(double amount) { if (amount \u0026gt; 0) { balance += amount; } } public boolean withdraw(double amount) { if (amount \u0026gt; 0 \u0026amp;\u0026amp; amount \u0026lt;= balance) { balance -= amount; return true; } return false; } } Tổng kết Những sai lầm này đã giúp mình hiểu sâu hơn về Java. Đừng sợ mắc lỗi, quan trọng là học hỏi từ chúng!\nTips để tránh sai lầm: Practice coding every day - Luyện tập thường xuyên Read other people\u0026rsquo;s code - Đọc code của người khác Use IDE effectively - Tận dụng IDE để catch lỗi sớm Code review - Nhờ bạn bè review code Read documentation - Đọc docs chính thức của Java Các bạn đã mắc phải sai lầm nào trong danh sách này chưa? Hoặc có sai lầm nào khác muốn chia sẻ? Comment bên dưới nhé!\nKeep learning, keep coding! ☕\n","permalink":"http://localhost:1313/blog/5-wrong-errors/","tags":["java","sai-lam","kinh-nghiem","hoc-tap"],"title":"5 Sai lầm phổ biến khi học Java mà mình đã mắc phải"},{"categories":["Async Programming"],"contents":"Chào các bạn! Async programming là một trong những concepts khó nhất khi học lập trình. Mình đã struggle với nó khá lâu, từ callback hell của JavaScript đến thread complexity của Java. Hôm nay mình muốn chia sẻ cách hai ngôn ngữ này handle async operations - JavaScript với Promise và Java với CompletableFuture.\nCâu chuyện bắt đầu từ Synchronous Hell JavaScript - Callback Hell // Cách xưa - callback nightmare! function getUserData(userId, callback) { fetchUser(userId, (user) =\u0026gt; { if (user) { fetchUserProfile(user.id, (profile) =\u0026gt; { if (profile) { fetchUserPosts(user.id, (posts) =\u0026gt; { if (posts) { fetchPostComments(posts[0].id, (comments) =\u0026gt; { // 4 levels deep! Pyramid of doom 😱 callback({ user, profile, posts, comments }); }); } else { callback(null, \u0026#34;No posts found\u0026#34;); } }); } else { callback(null, \u0026#34;Profile not found\u0026#34;); } }); } else { callback(null, \u0026#34;User not found\u0026#34;); } }); } Java - Thread Complexity // Cách xưa với Thread public void getUserDataOldWay(String userId) { new Thread(() -\u0026gt; { try { User user = fetchUser(userId); if (user != null) { new Thread(() -\u0026gt; { try { Profile profile = fetchUserProfile(user.getId()); if (profile != null) { // Nested threads everywhere! 😫 // Error handling nightmare // No easy way to combine results } } catch (Exception e) { // Handle error } }).start(); } } catch (Exception e) { // Handle error } }).start(); } JavaScript Promise - Giải cứu từ Callback Hell Promise Basics // Tạo Promise đơn giản function fetchUser(userId) { return new Promise((resolve, reject) =\u0026gt; { // Simulate API call setTimeout(() =\u0026gt; { if (userId \u0026gt; 0) { resolve({ id: userId, name: `User ${userId}` }); } else { reject(new Error(\u0026#34;Invalid user ID\u0026#34;)); } }, 1000); }); } // Sử dụng Promise fetchUser(123) .then((user) =\u0026gt; { console.log(\u0026#34;User:\u0026#34;, user); return user; // Pass data to next .then() }) .then((user) =\u0026gt; { // Chain another async operation return fetchUserProfile(user.id); }) .then((profile) =\u0026gt; { console.log(\u0026#34;Profile:\u0026#34;, profile); }) .catch((error) =\u0026gt; { console.error(\u0026#34;Error:\u0026#34;, error); }) .finally(() =\u0026gt; { console.log(\u0026#34;Cleanup code here\u0026#34;); }); Promise.all() - Chạy song song // Thay vì chạy tuần tự async function getUserDataSequential(userId) { const user = await fetchUser(userId); // 1s const profile = await fetchUserProfile(userId); // 1s const posts = await fetchUserPosts(userId); // 1s // Total: 3s return { user, profile, posts }; } // Chạy song song với Promise.all() async function getUserDataParallel(userId) { const [user, profile, posts] = await Promise.all([ fetchUser(userId), // All run in parallel fetchUserProfile(userId), // Total: 1s (longest operation) fetchUserPosts(userId), ]); return { user, profile, posts }; } // Promise.allSettled() - Không fail nếu 1 promise reject async function getUserDataSafe(userId) { const results = await Promise.allSettled([ fetchUser(userId), fetchUserProfile(userId), fetchUserPosts(userId), ]); return results.map((result) =\u0026gt; { if (result.status === \u0026#34;fulfilled\u0026#34;) { return result.value; } else { console.error(\u0026#34;Failed:\u0026#34;, result.reason); return null; } }); } Async/Await - Promise syntax đường // Từ Promise chain function getUserData(userId) { return fetchUser(userId) .then((user) =\u0026gt; fetchUserProfile(user.id)) .then((profile) =\u0026gt; fetchUserPosts(profile.userId)) .then((posts) =\u0026gt; ({ user, profile, posts })) .catch((error) =\u0026gt; { console.error(\u0026#34;Error:\u0026#34;, error); throw error; }); } // Đến async/await - clean hơn nhiều! async function getUserData(userId) { try { const user = await fetchUser(userId); const profile = await fetchUserProfile(user.id); const posts = await fetchUserPosts(profile.userId); return { user, profile, posts }; } catch (error) { console.error(\u0026#34;Error:\u0026#34;, error); throw error; } } Java CompletableFuture - Modern Async Java CompletableFuture Basics import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class AsyncService { private ExecutorService executor = Executors.newFixedThreadPool(10); // Tạo CompletableFuture đơn giản public CompletableFuture\u0026lt;User\u0026gt; fetchUser(String userId) { return CompletableFuture.supplyAsync(() -\u0026gt; { // Simulate delay try { Thread.sleep(1000); if (Integer.parseInt(userId) \u0026gt; 0) { return new User(userId, \u0026#34;User \u0026#34; + userId); } else { throw new RuntimeException(\u0026#34;Invalid user ID\u0026#34;); } } catch (InterruptedException e) { throw new RuntimeException(e); } }, executor); } // Chain operations public CompletableFuture\u0026lt;UserData\u0026gt; getUserData(String userId) { return fetchUser(userId) .thenCompose(user -\u0026gt; fetchUserProfile(user.getId()) .thenApply(profile -\u0026gt; new UserData(user, profile)) ) .thenCompose(userData -\u0026gt; fetchUserPosts(userData.getUser().getId()) .thenApply(posts -\u0026gt; { userData.setPosts(posts); return userData; }) ) .exceptionally(throwable -\u0026gt; { System.err.println(\u0026#34;Error: \u0026#34; + throwable.getMessage()); return null; }); } } Parallel Execution với CompletableFuture public CompletableFuture\u0026lt;UserData\u0026gt; getUserDataParallel(String userId) { CompletableFuture\u0026lt;User\u0026gt; userFuture = fetchUser(userId); CompletableFuture\u0026lt;Profile\u0026gt; profileFuture = fetchUserProfile(userId); CompletableFuture\u0026lt;List\u0026lt;Post\u0026gt;\u0026gt; postsFuture = fetchUserPosts(userId); // Combine all results return userFuture.thenCombine(profileFuture, (user, profile) -\u0026gt; new UserData(user, profile) ).thenCombine(postsFuture, (userData, posts) -\u0026gt; { userData.setPosts(posts); return userData; }); } // allOf() - giống Promise.all() public CompletableFuture\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; fetchMultipleUsers(List\u0026lt;String\u0026gt; userIds) { List\u0026lt;CompletableFuture\u0026lt;User\u0026gt;\u0026gt; futures = userIds.stream() .map(this::fetchUser) .collect(Collectors.toList()); CompletableFuture\u0026lt;Void\u0026gt; allFutures = CompletableFuture.allOf( futures.toArray(new CompletableFuture[0]) ); return allFutures.thenApply(v -\u0026gt; futures.stream() .map(CompletableFuture::join) // Get results .map(User::getName) .collect(Collectors.toList()) ); } So sánh trực tiếp Promise vs CompletableFuture 1. Tạo async operation JavaScript:\nconst promise = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(\u0026#34;Done!\u0026#34;), 1000); }); // Hoặc với async function const asyncFunction = async () =\u0026gt; { return \u0026#34;Done!\u0026#34;; }; Java:\nCompletableFuture\u0026lt;String\u0026gt; future = CompletableFuture.supplyAsync(() -\u0026gt; { try { Thread.sleep(1000); } catch (InterruptedException e) {} return \u0026#34;Done!\u0026#34;; }); // Hoặc completed future CompletableFuture\u0026lt;String\u0026gt; completedFuture = CompletableFuture.completedFuture(\u0026#34;Done!\u0026#34;); 2. Chain operations JavaScript:\npromise .then((result) =\u0026gt; result.toUpperCase()) .then((upper) =\u0026gt; upper + \u0026#34; - FINISHED\u0026#34;) .catch((error) =\u0026gt; \u0026#34;Error: \u0026#34; + error); Java:\nfuture .thenApply(result -\u0026gt; result.toUpperCase()) .thenApply(upper -\u0026gt; upper + \u0026#34; - FINISHED\u0026#34;) .exceptionally(error -\u0026gt; \u0026#34;Error: \u0026#34; + error.getMessage()); 3. Combine multiple operations JavaScript:\nPromise.all([promise1, promise2, promise3]).then( ([result1, result2, result3]) =\u0026gt; { return { result1, result2, result3 }; } ); Java:\nfuture1.thenCombine(future2, (r1, r2) -\u0026gt; new Pair(r1, r2)) .thenCombine(future3, (pair, r3) -\u0026gt; new Result(pair.getFirst(), pair.getSecond(), r3) ); // Hoặc với allOf CompletableFuture.allOf(future1, future2, future3) .thenApply(v -\u0026gt; new Result( future1.join(), future2.join(), future3.join() )); Real-world Example: API Gateway JavaScript Implementation: class APIGateway { async handleRequest(request) { try { // Authenticate user const user = await this.authenticate(request.token); // Fetch data in parallel const [userData, permissions, preferences] = await Promise.all([ this.fetchUserData(user.id), this.fetchUserPermissions(user.id), this.fetchUserPreferences(user.id), ]); // Transform data const response = await this.transformResponse({ user: userData, permissions, preferences, }); return response; } catch (error) { return this.handleError(error); } } async fetchUserData(userId) { const response = await fetch(`/api/users/${userId}`); if (!response.ok) { throw new Error(`HTTP ${response.status}`); } return response.json(); } } Java Implementation: @Service public class APIGateway { private final ExecutorService executor = Executors.newFixedThreadPool(20); public CompletableFuture\u0026lt;APIResponse\u0026gt; handleRequest(APIRequest request) { return authenticate(request.getToken()) .thenCompose(user -\u0026gt; { // Fetch data in parallel CompletableFuture\u0026lt;UserData\u0026gt; userDataFuture = fetchUserData(user.getId()); CompletableFuture\u0026lt;List\u0026lt;Permission\u0026gt;\u0026gt; permissionsFuture = fetchUserPermissions(user.getId()); CompletableFuture\u0026lt;Preferences\u0026gt; preferencesFuture = fetchUserPreferences(user.getId()); return userDataFuture.thenCombine(permissionsFuture, (userData, permissions) -\u0026gt; new Pair\u0026lt;\u0026gt;(userData, permissions)) .thenCombine(preferencesFuture, (pair, preferences) -\u0026gt; new RequestData(pair.getFirst(), pair.getSecond(), preferences) ); }) .thenCompose(this::transformResponse) .exceptionally(this::handleError); } private CompletableFuture\u0026lt;UserData\u0026gt; fetchUserData(String userId) { return CompletableFuture.supplyAsync(() -\u0026gt; { // HTTP call implementation try { return restTemplate.getForObject(\u0026#34;/api/users/\u0026#34; + userId, UserData.class); } catch (Exception e) { throw new RuntimeException(\u0026#34;Failed to fetch user data\u0026#34;, e); } }, executor); } } Performance \u0026amp; Lessons Learned Performance Comparison: JavaScript Promise: Single-threaded event loop, excellent cho I/O operations Java CompletableFuture: Multi-threaded, tốt cho CPU-intensive tasks Best Practices: JavaScript:\nLuôn dùng async/await thay vì .then() chains Dùng Promise.all() cho parallel operations Handle errors với try/catch Avoid creating unnecessary Promises Java:\nSử dụng custom ExecutorService Handle exceptions với exceptionally() hoặc handle() Dùng thenCombine() cho parallel operations Remember to shutdown ExecutorService Kết luận Cả Promise và CompletableFuture đều là tools mạnh mẽ cho async programming:\nPromise: Đơn giản hơn, syntax clean với async/await CompletableFuture: Mạnh mẽ hơn, control tốt hơn threading Quan trọng là hiểu concept async programming, sau đó syntax chỉ là matter of practice!\nCác bạn đã dùng async programming chưa? Share kinh nghiệm ở comment nhé!\nAsync is the future! ⚡🚀\n","permalink":"http://localhost:1313/blog/promise-vs-completablefuture/intex/","tags":["javascript","java","async","promise","completablefuture"],"title":"Async Programming: Promise (JS) vs CompletableFuture (Java) - Battle of Asynchronous!"},{"categories":["Backend Development"],"contents":"Xin chào các bạn! Sau khi học cả Java và JavaScript, mình có cơ hội làm việc với cả Spring Boot và Node.js trong các dự án thực tế. Hôm nay mình muốn chia sẻ trải nghiệm của mình khi develop backend với hai platform này.\nDự án đầu tiên với Spring Boot 🍃 Setup ban đầu Khi mới bắt đầu với Spring Boot, mình cảm thấy hơi choáng với số lượng config:\n// Application.java @SpringBootApplication public class BlogApplication { public static void main(String[] args) { SpringApplication.run(BlogApplication.class, args); } } // User.java - JPA Entity @Entity @Table(name = \u0026#34;users\u0026#34;) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, unique = true) private String email; @Column(nullable = false) private String password; // Constructor, getters, setters... } // UserRepository.java @Repository public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt; { Optional\u0026lt;User\u0026gt; findByEmail(String email); } // UserController.java @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) public class UserController { @Autowired private UserService userService; @PostMapping public ResponseEntity\u0026lt;User\u0026gt; createUser(@Valid @RequestBody UserDTO userDTO) { User user = userService.createUser(userDTO); return ResponseEntity.status(HttpStatus.CREATED).body(user); } } Những điều mình thích ở Spring Boot: Convention over Configuration - Ít config hơn Spring truyền thống Dependency Injection - Auto-wiring cực kỳ mạnh mẽ JPA/Hibernate - ORM mạnh mẽ, query phức tạp dễ dàng Security - Spring Security handle authentication/authorization tốt Testing - Test infrastructure rất complete Những khó khăn: Learning curve - Cần hiểu về Spring ecosystem Memory usage - JVM khá \u0026ldquo;nặng\u0026rdquo; Startup time - Khởi động chậm hơn Node.js Annotation hell - Quá nhiều annotation có thể confusing Chuyển sang Node.js - Một thế giới khác 🚀 Express.js setup // app.js const express = require(\u0026#34;express\u0026#34;); const mongoose = require(\u0026#34;mongoose\u0026#34;); const bcrypt = require(\u0026#34;bcryptjs\u0026#34;); const jwt = require(\u0026#34;jsonwebtoken\u0026#34;); const app = express(); app.use(express.json()); // User Model với Mongoose const userSchema = new mongoose.Schema({ email: { type: String, required: true, unique: true }, password: { type: String, required: true }, createdAt: { type: Date, default: Date.now }, }); const User = mongoose.model(\u0026#34;User\u0026#34;, userSchema); // User Routes app.post(\u0026#34;/api/users\u0026#34;, async (req, res) =\u0026gt; { try { const { email, password } = req.body; const existingUser = await User.findOne({ email }); if (existingUser) { return res.status(400).json({ message: \u0026#34;User already exists\u0026#34; }); } const hashedPassword = await bcrypt.hash(password, 10); const user = new User({ email, password: hashedPassword }); await user.save(); res.status(201).json({ id: user._id, email: user.email }); } catch (error) { res.status(500).json({ message: error.message }); } }); // Connect to MongoDB mongoose .connect(\u0026#34;mongodb://localhost:27017/myapp\u0026#34;) .then(() =\u0026gt; console.log(\u0026#34;Connected to MongoDB\u0026#34;)) .catch((err) =\u0026gt; console.error(\u0026#34;MongoDB connection error:\u0026#34;, err)); app.listen(3000, () =\u0026gt; { console.log(\u0026#34;Server running on port 3000\u0026#34;); }); Những điều mình thích ở Node.js: Fast development - Viết code nhanh, setup đơn giản JavaScript everywhere - Same language frontend/backend NPM ecosystem - Package có sẵn cho mọi thứ Lightweight - Memory footprint nhỏ hơn JVM Fast startup - Server khởi động trong giây lát Những thách thức: Callback/Promise hell - Nếu không handle tốt async code Single-threaded - CPU-intensive tasks có thể block Type safety - JavaScript dynamic typing đôi khi gây bugs Package management - Dependency hell với npm So sánh thực tế qua dự án Dự án E-commerce Platform Mình đã implement cùng một API cho hệ thống e-commerce với cả hai technologies:\nPerformance Test Results: Concurrent Users: 1000\rTest Duration: 5 minutes\rSpring Boot (Java 17 + PostgreSQL):\r- Average Response Time: 45ms\r- Throughput: 2,200 req/sec\r- Memory Usage: 512MB\r- CPU Usage: 35%\rNode.js (Express + MongoDB):\r- Average Response Time: 38ms\r- Throughput: 2,800 req/sec\r- Memory Usage: 128MB\r- CPU Usage: 28% Development Speed: Spring Boot:\nSetup time: 30 phút (config database, dependencies) CRUD operations: 2 giờ Authentication: 1 giờ (Spring Security) Unit tests: 1.5 giờ Total: ~5 giờ Node.js:\nSetup time: 10 phút CRUD operations: 1 giờ Authentication: 1.5 giờ (custom JWT) Unit tests: 1 giờ Total: ~3.5 giờ Khi nào dùng gì? Chọn Spring Boot khi: ✅ Enterprise applications - Cần security, scalability cao\n✅ Complex business logic - Nhiều rules phức tạp\n✅ Team lớn - Structure rõ ràng, maintainable\n✅ Legacy systems - Integration với Java ecosystem\n✅ Microservices - Spring Cloud ecosystem mạnh\n// Example: Complex business logic dễ handle với Java @Service @Transactional public class OrderService { public Order processOrder(OrderRequest request) { // Validate inventory inventoryService.checkAvailability(request.getItems()); // Apply discounts BigDecimal finalAmount = pricingService .calculateDiscount(request, customer.getTier()); // Process payment PaymentResult payment = paymentService .processPayment(customer.getPaymentMethod(), finalAmount); if (payment.isSuccessful()) { // Create order Order order = orderRepository.save( Order.builder() .customerId(customer.getId()) .amount(finalAmount) .status(OrderStatus.CONFIRMED) .build() ); // Send notifications notificationService.sendOrderConfirmation(order); return order; } throw new PaymentProcessingException(\u0026#34;Payment failed\u0026#34;); } } Chọn Node.js khi: ✅ Rapid prototyping - Cần develop nhanh\n✅ Real-time apps - Chat, live updates (Socket.io)\n✅ API-first approach - RESTful APIs đơn giản\n✅ Startup/Small team - Ít developers, cần flexibility\n✅ I/O intensive - Nhiều database calls, external APIs\n// Example: Real-time chat với Socket.io const io = require(\u0026#34;socket.io\u0026#34;)(server); io.on(\u0026#34;connection\u0026#34;, (socket) =\u0026gt; { console.log(\u0026#34;User connected:\u0026#34;, socket.id); socket.on(\u0026#34;join-room\u0026#34;, (roomId) =\u0026gt; { socket.join(roomId); socket.to(roomId).emit(\u0026#34;user-joined\u0026#34;, socket.id); }); socket.on(\u0026#34;message\u0026#34;, async (data) =\u0026gt; { // Save to database const message = await Message.create({ content: data.message, userId: data.userId, roomId: data.roomId, }); // Broadcast to room io.to(data.roomId).emit(\u0026#34;new-message\u0026#34;, message); }); socket.on(\u0026#34;disconnect\u0026#34;, () =\u0026gt; { console.log(\u0026#34;User disconnected:\u0026#34;, socket.id); }); }); Lessons Learned 1. Không có \u0026ldquo;silver bullet\u0026rdquo; Cả hai đều có ưu nhược điểm. Quan trọng là chọn tool phù hợp với requirements.\n2. Team skill matter Team giỏi Java → Spring Boot sẽ productive hơn Team frontend developers → Node.js dễ tiếp cận hơn 3. Maintenance is key Spring Boot có structure rõ ràng hơn cho long-term projects.\n4. Performance isn\u0026rsquo;t everything Developer productivity và time-to-market cũng quan trọng.\nKết luận Sau kinh nghiệm với cả hai, mình nhận ra:\nSpring Boot giống như một chiếc Mercedes - robust, reliable, powerful nhưng cần thời gian để master.\nNode.js giống như một chiếc motorbike - agile, fast, flexible nhưng cần cẩn thận khi handle complex scenarios.\nHiện tại mình đang sử dụng:\nSpring Boot cho enterprise projects, complex business logic Node.js cho prototypes, real-time features, simple APIs Các bạn có kinh nghiệm gì với hai platform này? Share ở comment nhé!\nChoose the right tool for the job! 🛠️\n","permalink":"http://localhost:1313/blog/springboot-vs-nodejs/","tags":["java","javascript","spring-boot","nodejs","backend"],"title":"Spring Boot vs Node.js: Trải nghiệm backend development của mình"},{"categories":["JavaScript"],"contents":"Chào mọi người! Khi mới học JavaScript, mình chỉ biết đến cú pháp cũ ES5. Nhưng khi tiếp xúc với ES6+ (ES2015 trở lên), thật sự mình cảm thấy như được \u0026ldquo;khai sáng\u0026rdquo;. Hôm nay mình muốn chia sẻ những tính năng ES6+ đã thay đổi hoàn toàn cách mình viết JavaScript.\n1. Let \u0026amp; Const - Tạm biệt var nhé! Cách cũ với var: // Vấn đề với var function oldWay() { for (var i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; { console.log(i); // In ra 3, 3, 3 (WTF???) }, 100); } console.log(i); // 3 - i vẫn tồn tại ngoài loop! } Cách mới với let \u0026amp; const: function newWay() { for (let i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; { console.log(i); // In ra 0, 1, 2 (chính xác!) }, 100); } // console.log(i); // ReferenceError - i không tồn tại ở đây const API_URL = \u0026#34;https://api.example.com\u0026#34;; // API_URL = \u0026#39;other-url\u0026#39;; // TypeError - không thể reassign const } Bài học: Luôn dùng const cho giá trị không thay đổi, let cho biến có thể thay đổi. Quên var đi!\n2. Arrow Functions - Code ngắn gọn hơn ES5 way: // Function expression cũ var users = [\u0026#34;Nam\u0026#34;, \u0026#34;Linh\u0026#34;, \u0026#34;Hoa\u0026#34;]; var uppercaseUsers = users.map(function (user) { return user.toUpperCase(); }); var button = document.getElementById(\u0026#34;btn\u0026#34;); button.addEventListener(\u0026#34;click\u0026#34;, function () { console.log(this); // \u0026#39;this\u0026#39; trỏ đến button }); ES6 way: // Arrow function - clean và concise const users = [\u0026#34;Nam\u0026#34;, \u0026#34;Linh\u0026#34;, \u0026#34;Hoa\u0026#34;]; const uppercaseUsers = users.map((user) =\u0026gt; user.toUpperCase()); // Với multiple parameters const add = (a, b) =\u0026gt; a + b; // Với function body const processUser = (user) =\u0026gt; { const processed = user.trim().toUpperCase(); return `Hello, ${processed}!`; }; // Lưu ý về \u0026#39;this\u0026#39; binding const obj = { name: \u0026#34;MyObject\u0026#34;, regularFunction() { console.log(this.name); // \u0026#39;MyObject\u0026#39; const arrowFunction = () =\u0026gt; { console.log(this.name); // \u0026#39;MyObject\u0026#39; - inherit từ parent scope }; arrowFunction(); }, }; Tip: Arrow function không có this binding riêng, nó inherit từ parent scope.\n3. Template Literals - Goodbye string concatenation! Cách cũ: var name = \u0026#34;Nam\u0026#34;; var age = 20; var city = \u0026#34;Ho Chi Minh\u0026#34;; var introduction = \u0026#34;Xin chào, tôi là \u0026#34; + name + \u0026#34;, \u0026#34; + age + \u0026#34; tuổi, \u0026#34; + \u0026#34;đến từ \u0026#34; + city + \u0026#34;.\u0026#34;; var htmlTemplate = \u0026#39;\u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt;\u0026#39; + \u0026#34;\u0026lt;h2\u0026gt;\u0026#34; + name + \u0026#34;\u0026lt;/h2\u0026gt;\u0026#34; + \u0026#34;\u0026lt;p\u0026gt;Age: \u0026#34; + age + \u0026#34;\u0026lt;/p\u0026gt;\u0026#34; + \u0026#34;\u0026lt;/div\u0026gt;\u0026#34;; Cách mới: const name = \u0026#34;Nam\u0026#34;; const age = 20; const city = \u0026#34;Ho Chi Minh\u0026#34;; // Template literals với backticks const introduction = `Xin chào, tôi là ${name}, ${age} tuổi, đến từ ${city}.`; // Multi-line strings dễ dàng const htmlTemplate = ` \u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;${name}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Age: ${age}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Status: ${age \u0026gt;= 18 ? \u0026#34;Adult\u0026#34; : \u0026#34;Minor\u0026#34;}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `; // Tagged template literals (advanced) function highlight(strings, ...values) { return strings.reduce((result, string, i) =\u0026gt; { const value = values[i] ? `\u0026lt;mark\u0026gt;${values[i]}\u0026lt;/mark\u0026gt;` : \u0026#34;\u0026#34;; return result + string + value; }, \u0026#34;\u0026#34;); } const highlighted = highlight`Tôi tên là ${name} và ${age} tuổi.`; 4. Destructuring - Unpack dữ liệu như ninja Array Destructuring: // Cách cũ var numbers = [1, 2, 3, 4, 5]; var first = numbers[0]; var second = numbers[1]; var rest = numbers.slice(2); // Cách mới const [first, second, ...rest] = [1, 2, 3, 4, 5]; console.log(first); // 1 console.log(second); // 2 console.log(rest); // [3, 4, 5] // Skip elements const [a, , c] = [1, 2, 3]; console.log(a, c); // 1, 3 // Default values const [x = 0, y = 0] = [1]; // x = 1, y = 0 Object Destructuring: // Cách cũ var user = { name: \u0026#34;Nam\u0026#34;, age: 20, email: \u0026#34;nam@example.com\u0026#34;, address: { city: \u0026#34;Ho Chi Minh\u0026#34;, district: \u0026#34;District 1\u0026#34;, }, }; var name = user.name; var age = user.age; var email = user.email; // Cách mới const { name, age, email } = user; // Rename variables const { name: userName, age: userAge } = user; // Nested destructuring const { address: { city, district }, } = user; // Default values const { phone = \u0026#34;N/A\u0026#34; } = user; // Function parameters destructuring function greetUser({ name, age = \u0026#34;unknown\u0026#34; }) { return `Hello ${name}, you are ${age} years old`; } greetUser({ name: \u0026#34;Nam\u0026#34;, age: 20 }); 5. Spread \u0026amp; Rest Operators - Ba chấm ma thuật Spread Operator (\u0026hellip;): // Array spreading const arr1 = [1, 2, 3]; const arr2 = [4, 5, 6]; const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6] // Object spreading const user = { name: \u0026#34;Nam\u0026#34;, age: 20 }; const updatedUser = { ...user, age: 21, city: \u0026#34;HCM\u0026#34; }; // { name: \u0026#39;Nam\u0026#39;, age: 21, city: \u0026#39;HCM\u0026#39; } // Function arguments function sum(a, b, c) { return a + b + c; } const numbers = [1, 2, 3]; console.log(sum(...numbers)); // 6 Rest Operator (\u0026hellip;): // Function parameters function logAll(first, ...others) { console.log(\u0026#34;First:\u0026#34;, first); console.log(\u0026#34;Others:\u0026#34;, others); } logAll(1, 2, 3, 4, 5); // First: 1, Others: [2, 3, 4, 5] // Array destructuring (đã thấy ở trên) const [head, ...tail] = [1, 2, 3, 4, 5]; 6. Enhanced Object Literals const name = \u0026#34;Nam\u0026#34;; const age = 20; // Cách cũ var user = { name: name, age: age, greet: function () { return \u0026#34;Hello!\u0026#34;; }, }; // Cách mới - shorthand properties const user = { name, // tương đương name: name age, // tương đương age: age // Method shorthand greet() { return \u0026#34;Hello!\u0026#34;; }, // Computed property names [`full${name}`]: `${name} Nguyen`, // Dynamic property [getPropertyName()]: \u0026#34;dynamic value\u0026#34;, }; 7. Promises \u0026amp; Async/Await - Tạm biệt Callback Hell Callback Hell: // Cách cũ - callback hell fetchUser(userId, function (user) { fetchUserPosts(user.id, function (posts) { fetchPostComments(posts[0].id, function (comments) { // Nested callbacks - khó đọc và maintain console.log(comments); }); }); }); Promises: // Promise chain fetchUser(userId) .then((user) =\u0026gt; fetchUserPosts(user.id)) .then((posts) =\u0026gt; fetchPostComments(posts[0].id)) .then((comments) =\u0026gt; console.log(comments)) .catch((error) =\u0026gt; console.error(error)); Async/Await: // Async/await - code như synchronous async function getUserData(userId) { try { const user = await fetchUser(userId); const posts = await fetchUserPosts(user.id); const comments = await fetchPostComments(posts[0].id); return comments; } catch (error) { console.error(\u0026#34;Error:\u0026#34;, error); throw error; } } // Sử dụng getUserData(123).then((data) =\u0026gt; console.log(data)); Kết luận ES6+ đã thực sự thay đổi cách mình viết JavaScript:\nCode ngắn gọn và dễ đọc hơn Ít bugs hơn nhờ let/const Xử lý async code dễ dàng hơn Destructuring giúp unpack data elegantly Tips cho người mới: Học từ từ - Đừng cố gắng học tất cả một lúc Practice daily - Viết code ES6+ mỗi ngày Use Babel - Để support browser cũ Read MDN docs - Tài liệu chính thức luôn tốt nhất Các bạn đã dùng feature nào trong số này chưa? Feature nào khiến các bạn ấn tượng nhất? Share ở comment nhé!\nModern JavaScript is beautiful! 🚀✨\n","permalink":"http://localhost:1313/blog/javascript-es6+/","tags":["javascript","es6","modern-js","kinh-nghiem"],"title":"JavaScript ES6+: Những tính năng đã thay đổi cách mình code"},{"categories":null,"contents":"Xin chào! Tôi là Tiết Thanh Minh Hiếu 👋 Câu chuyện của tôi Tôi là một sinh viên đang theo đuổi ước mơ trở thành chuyên viên An Ninh Mạng, với niềm đam mê bảo vệ thế giới số khỏi những mối đe dọa ngày càng phức tạp. Nhưng điều đặc biệt là tôi không chỉ muốn \u0026ldquo;làm\u0026rdquo; mà còn muốn \u0026ldquo;truyền cảm hứng\u0026rdquo; - mục tiêu của tôi là trở thành một giảng viên Security, người có thể biến những kiến thức phức tạp thành những bài học dễ hiểu và thú vị.\nTại sao tôi tạo blog này? Ban đầu, blog này được tạo ra để hoàn thành yêu cầu môn học về Java \u0026amp; JavaScript. Nhưng tôi nhận ra đây chính là cơ hội tuyệt vời để bắt đầu hành trình chia sẻ kiến thức mà tôi đã ấp ủ từ lâu.\nTôi tin rằng: Cách học tốt nhất là dạy lại cho người khác. Mỗi bài viết tôi chia sẻ không chỉ giúp các bạn đọc mà còn giúp tôi củng cố và mở rộng kiến thức của chính mình.\nNhững gì tôi đang làm 🔍 An Ninh Mạng Hiện tại tôi đang xây dựng nền tảng vững chắc với các chứng chỉ từ Google Cybersecurity và IBM. Kiến thức mạng cơ bản đã giúp tôi hiểu được \u0026ldquo;bức tranh lớn\u0026rdquo; của bảo mật.\n🤖 AI \u0026amp; Machine Learning Tôi có kinh nghiệm training model, đặc biệt là BERT. Dự án gần nhất của tôi là \u0026ldquo;Phát hiện mã độc Android bằng Transformer Networks (BERT)\u0026rdquo; - một project thú vị kết hợp giữa AI và Cybersecurity.\n💻 Lập trình Java và JavaScript là những ngôn ngữ tôi đang tập trung, nhưng hành trình coding của tôi không dừng lại ở đó!\nĐiều gì khiến blog này khác biệt? Không chỉ là lý thuyết khô khan. Tôi sẽ chia sẻ:\n✨ Kinh nghiệm thực tế từ các project đã làm 🎯 Cách tiếp cận thực tế thay vì chỉ đọc sách vở 🔧 Tips \u0026amp; tricks mà tôi học được qua quá trình \u0026ldquo;vấp ngã\u0026rdquo; 📚 Kiến thức được \u0026ldquo;dịch\u0026rdquo; sang ngôn ngữ dễ hiểu Mục tiêu của tôi là biến những khái niệm phức tạp thành những câu chuyện thú vị mà bất kỳ ai cũng có thể hiểu được.\nTầm nhìn tương lai Tôi mơ ước một ngày nào đó sẽ đứng trên bục giảng, truyền cảm hứng cho thế hệ các chuyên gia bảo mật tương lai. Blog này chính là bước đầu tiên trong hành trình rèn luyện kỹ năng truyền đạt của tôi.\nMỗi bài viết là một bài giảng nhỏ, mỗi chia sẻ là một lần thực hành để tôi có thể diễn đạt tốt hơn, rõ ràng hơn.\nLời kết Nếu bạn là người:\n🎓 Đang học về Cybersecurity, Java, JavaScript hoặc AI 🔍 Muốn hiểu cách áp dụng kiến thức vào thực tế 💡 Thích học thông qua kinh nghiệm thực tế hơn là lý thuyết suông Thì blog này dành cho bạn! Tôi hy vọng những chia sẻ của mình sẽ giúp ích cho hành trình học tập của các bạn, đồng thời cũng giúp tôi trở thành một người truyền đạt giỏi hơn.\nHãy cùng học, cùng phát triển và cùng tạo nên một cộng đồng tech Việt Nam mạnh mẽ! 🚀\n\u0026ldquo;The best way to learn is to teach others\u0026rdquo; - và đó chính là triết lý tôi theo đuổi trong mỗi bài viết.\n","permalink":"http://localhost:1313/about/","tags":null,"title":"Giới thiệu"},{"categories":null,"contents":"Trong lập trình mạng bằng Java, Socket là công cụ giúp kết nối giữa client và server.\nBằng cách sử dụng java.net.Socket và java.net.ServerSocket, ta có thể xây dựng các ứng dụng chat, truyền file hoặc HTTP server đơn giản.\nMô hình Client-Server cơ bản trong lập trình Socket Ở mức thấp hơn, kết nối TCP được thiết lập qua quá trình bắt tay 3 bước (TCP Handshake).\nĐiều này đảm bảo client và server đồng bộ trạng thái trước khi truyền dữ liệu.\nCơ chế bắt tay 3 bước TCP (Three-Way Handshake) ","permalink":"http://localhost:1313/blog/java-socket/","tags":["Java","Networking"],"title":"Kết nối Socket trong Java"},{"categories":["Programming"],"contents":"Chào các bạn! Hôm nay mình muốn chia sẻ về hành trình học lập trình của mình, từ Java đến JavaScript. Có lẽ nhiều bạn cũng đang băn khoăn giống mình: nên bắt đầu với ngôn ngữ nào? Học Java trước hay JavaScript trước?\nKhởi đầu với Java - Nền tảng vững chắc Mình bắt đầu với Java từ năm nhất đại học. Thật sự lúc đầu khá choáng với cú pháp dài dòng của Java:\npublic class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Hello, World!\u0026#34;); } } So với \u0026ldquo;Hello World\u0026rdquo; của JavaScript:\nconsole.log(\u0026#34;Hello, World!\u0026#34;); Wow, khác biệt quá phải không? Nhưng qua thời gian, mình nhận ra Java đã dạy mình những điều quan trọng:\n1. Tư duy hướng đối tượng (OOP) Java buộc mình phải hiểu về Class, Object, Inheritance\u0026hellip; Lúc đầu khó hiểu lắm, nhưng sau này khi làm dự án lớn mới thấy tầm quan trọng của nó.\n2. Tính nghiêm ngặt về kiểu dữ liệu int number = 10; // Phải khai báo kiểu rõ ràng String text = \u0026#34;Hello\u0026#34;; // Không thể gán số vào String 3. Cấu trúc dự án rõ ràng Package, import, access modifier\u0026hellip; tất cả đều có quy tắc rõ ràng.\nChuyển sang JavaScript - Tự do nhưng cần kỷ luật Khi bắt đầu học JavaScript, mình cảm thấy như được \u0026ldquo;giải phóng\u0026rdquo;:\nlet data = 10; // Kiểu number data = \u0026#34;Hello\u0026#34;; // Giờ thành string data = [1, 2, 3]; // Giờ thành array data = { name: \u0026#34;John\u0026#34; }; // Giờ thành object Tự do quá! Nhưng cũng dễ rối loạn không kém.\nNhững khác biệt chính mình nhận ra: Java:\nCompiled language (biên dịch trước) Strongly typed (kiểu dữ liệu nghiêm ngặt) Platform independent (chạy trên JVM) Chủ yếu cho backend JavaScript:\nInterpreted language (thông dịch) Dynamically typed (kiểu dữ liệu linh hoạt) Chạy trên browser/Node.js Full-stack (cả frontend và backend) Bài học rút ra 1. Java là nền tảng tốt để bắt đầu Nếu bạn chưa biết gì về lập trình, mình khuyên nên bắt đầu với Java. Tại sao?\nBuộc bạn phải viết code chuẩn Hiểu rõ về cấu trúc dữ liệu Tư duy logic tốt hơn 2. JavaScript cần kỷ luật bản thân Vì quá linh hoạt, JavaScript dễ làm cho code trở nên lộn xộn. Mình học được:\nĐặt tên biến có ý nghĩa Sử dụng const/let thay vì var Comment code đầy đủ 3. Cả hai đều có giá trị Java: Tốt cho hệ thống lớn, enterprise applications JavaScript: Linh hoạt, phát triển nhanh, cộng đồng active Lời kết Hành trình từ Java đến JavaScript đã dạy mình rằng không có ngôn ngữ nào là \u0026ldquo;tốt nhất\u0026rdquo;. Mỗi ngôn ngữ đều có ưu nhược điểm riêng. Quan trọng là hiểu rõ bản chất và áp dụng đúng context.\nCác bạn có kinh nghiệm gì thú vị khi học hai ngôn ngữ này không? Hãy chia sẻ trong comment nhé!\nHappy coding! 🚀\n","permalink":"http://localhost:1313/blog/java-to-javascript/","tags":["java","javascript","kinh-nghiem","hoc-tap"],"title":"Từ Java đến JavaScript: Hành trình học lập trình của mình"},{"categories":["Java"],"contents":"Xin chào các bạn! Hôm nay mình muốn chia sẻ về những sai lầm \u0026ldquo;kinh điển\u0026rdquo; mà hầu như ai học Java cũng mắc phải, bao gồm cả mình. Hy vọng qua bài viết này, các bạn newbie sẽ tránh được những \u0026ldquo;hố đen\u0026rdquo; mà mình đã rơi vào.\nSai lầm #1: Lạm dụng public static void main Mình từng làm thế này: public class Calculator { public static void main(String[] args) { // Viết tất cả logic trong main int a = 10, b = 5; int sum = a + b; int diff = a - b; int product = a * b; int quotient = a / b; System.out.println(\u0026#34;Sum: \u0026#34; + sum); System.out.println(\u0026#34;Difference: \u0026#34; + diff); // ... và còn 50 dòng code nữa } } Vấn đề: Code không thể tái sử dụng Khó debug và maintain Không theo nguyên tắc OOP Cách khắc phục: public class Calculator { public int add(int a, int b) { return a + b; } public int subtract(int a, int b) { return a - b; } public static void main(String[] args) { Calculator calc = new Calculator(); System.out.println(\u0026#34;Sum: \u0026#34; + calc.add(10, 5)); System.out.println(\u0026#34;Difference: \u0026#34; + calc.subtract(10, 5)); } } Sai lầm #2: Không hiểu về Reference vs Value Mình từng nghĩ: public class Student { String name; public static void main(String[] args) { Student s1 = new Student(); s1.name = \u0026#34;Nam\u0026#34;; Student s2 = s1; // Mình tưởng s2 là bản copy của s1 s2.name = \u0026#34;Linh\u0026#34;; System.out.println(s1.name); // Tại sao lại in ra \u0026#34;Linh\u0026#34;??? } } Bài học: Trong Java, object được truyền theo reference, không phải value. Khi gán s2 = s1, cả hai đều trỏ đến cùng một object trong memory.\nGiải pháp: public class Student implements Cloneable { String name; public Student(String name) { this.name = name; } // Constructor copy public Student(Student other) { this.name = other.name; } public static void main(String[] args) { Student s1 = new Student(\u0026#34;Nam\u0026#34;); Student s2 = new Student(s1); // Tạo object mới s2.name = \u0026#34;Linh\u0026#34;; System.out.println(s1.name); // \u0026#34;Nam\u0026#34; System.out.println(s2.name); // \u0026#34;Linh\u0026#34; } } Sai lầm #3: Không xử lý Exception đúng cách Code \u0026ldquo;tệ\u0026rdquo; của mình: public void readFile(String fileName) { try { FileReader file = new FileReader(fileName); BufferedReader reader = new BufferedReader(file); String line = reader.readLine(); System.out.println(line); } catch (Exception e) { // Im lặng, không làm gì cả - RỐT THẬM TỆ! } } Vấn đề: \u0026ldquo;Nuốt\u0026rdquo; exception mà không xử lý Sử dụng Exception quá general Không đóng resource Cách đúng: public void readFile(String fileName) { try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) { String line = reader.readLine(); if (line != null) { System.out.println(line); } } catch (FileNotFoundException e) { System.err.println(\u0026#34;Không tìm thấy file: \u0026#34; + fileName); // Log hoặc throw lại exception } catch (IOException e) { System.err.println(\u0026#34;Lỗi đọc file: \u0026#34; + e.getMessage()); } } Sai lầm #4: So sánh String bằng == Code sai: public class StringComparison { public static void main(String[] args) { String s1 = \u0026#34;Hello\u0026#34;; String s2 = new String(\u0026#34;Hello\u0026#34;); if (s1 == s2) { // SAAAIIII! System.out.println(\u0026#34;Equal\u0026#34;); } else { System.out.println(\u0026#34;Not equal\u0026#34;); // Sẽ in ra này } } } Giải thích: == so sánh reference, không phải content s1 trỏ đến String Pool s2 trỏ đến object mới trong heap Cách đúng: public class StringComparison { public static void main(String[] args) { String s1 = \u0026#34;Hello\u0026#34;; String s2 = new String(\u0026#34;Hello\u0026#34;); if (s1.equals(s2)) { // So sánh content System.out.println(\u0026#34;Equal\u0026#34;); } // Hoặc an toàn hơn với null check if (Objects.equals(s1, s2)) { System.out.println(\u0026#34;Equal and null-safe\u0026#34;); } } } Sai lầm #5: Không hiểu về Access Modifier Code của mình lúc trước: public class BankAccount { public double balance; // Ai cũng có thể truy cập! public BankAccount(double initialBalance) { balance = initialBalance; } } // Ở nơi khác BankAccount account = new BankAccount(1000); account.balance = -500; // Oops! Balance âm??? Vấn đề: Dữ liệu quan trọng không được bảo vệ Vi phạm nguyên tắc Encapsulation Cách khắc phục: public class BankAccount { private double balance; // Chỉ class này truy cập được public BankAccount(double initialBalance) { if (initialBalance \u0026gt;= 0) { this.balance = initialBalance; } else { throw new IllegalArgumentException(\u0026#34;Balance không thể âm\u0026#34;); } } public double getBalance() { return balance; } public void deposit(double amount) { if (amount \u0026gt; 0) { balance += amount; } } public boolean withdraw(double amount) { if (amount \u0026gt; 0 \u0026amp;\u0026amp; amount \u0026lt;= balance) { balance -= amount; return true; } return false; } } Tổng kết Những sai lầm này đã giúp mình hiểu sâu hơn về Java. Đừng sợ mắc lỗi, quan trọng là học hỏi từ chúng!\nTips để tránh sai lầm: Practice coding every day - Luyện tập thường xuyên Read other people\u0026rsquo;s code - Đọc code của người khác Use IDE effectively - Tận dụng IDE để catch lỗi sớm Code review - Nhờ bạn bè review code Read documentation - Đọc docs chính thức của Java Các bạn đã mắc phải sai lầm nào trong danh sách này chưa? Hoặc có sai lầm nào khác muốn chia sẻ? Comment bên dưới nhé!\nKeep learning, keep coding! ☕\n","permalink":"http://localhost:1313/blog/5-wrong-errors/","tags":["java","sai-lam","kinh-nghiem","hoc-tap"],"title":"5 Sai lầm phổ biến khi học Java mà mình đã mắc phải"},{"categories":["Async Programming"],"contents":"Chào các bạn! Async programming là một trong những concepts khó nhất khi học lập trình. Mình đã struggle với nó khá lâu, từ callback hell của JavaScript đến thread complexity của Java. Hôm nay mình muốn chia sẻ cách hai ngôn ngữ này handle async operations - JavaScript với Promise và Java với CompletableFuture.\nCâu chuyện bắt đầu từ Synchronous Hell JavaScript - Callback Hell // Cách xưa - callback nightmare! function getUserData(userId, callback) { fetchUser(userId, (user) =\u0026gt; { if (user) { fetchUserProfile(user.id, (profile) =\u0026gt; { if (profile) { fetchUserPosts(user.id, (posts) =\u0026gt; { if (posts) { fetchPostComments(posts[0].id, (comments) =\u0026gt; { // 4 levels deep! Pyramid of doom 😱 callback({ user, profile, posts, comments }); }); } else { callback(null, \u0026#34;No posts found\u0026#34;); } }); } else { callback(null, \u0026#34;Profile not found\u0026#34;); } }); } else { callback(null, \u0026#34;User not found\u0026#34;); } }); } Java - Thread Complexity // Cách xưa với Thread public void getUserDataOldWay(String userId) { new Thread(() -\u0026gt; { try { User user = fetchUser(userId); if (user != null) { new Thread(() -\u0026gt; { try { Profile profile = fetchUserProfile(user.getId()); if (profile != null) { // Nested threads everywhere! 😫 // Error handling nightmare // No easy way to combine results } } catch (Exception e) { // Handle error } }).start(); } } catch (Exception e) { // Handle error } }).start(); } JavaScript Promise - Giải cứu từ Callback Hell Promise Basics // Tạo Promise đơn giản function fetchUser(userId) { return new Promise((resolve, reject) =\u0026gt; { // Simulate API call setTimeout(() =\u0026gt; { if (userId \u0026gt; 0) { resolve({ id: userId, name: `User ${userId}` }); } else { reject(new Error(\u0026#34;Invalid user ID\u0026#34;)); } }, 1000); }); } // Sử dụng Promise fetchUser(123) .then((user) =\u0026gt; { console.log(\u0026#34;User:\u0026#34;, user); return user; // Pass data to next .then() }) .then((user) =\u0026gt; { // Chain another async operation return fetchUserProfile(user.id); }) .then((profile) =\u0026gt; { console.log(\u0026#34;Profile:\u0026#34;, profile); }) .catch((error) =\u0026gt; { console.error(\u0026#34;Error:\u0026#34;, error); }) .finally(() =\u0026gt; { console.log(\u0026#34;Cleanup code here\u0026#34;); }); Promise.all() - Chạy song song // Thay vì chạy tuần tự async function getUserDataSequential(userId) { const user = await fetchUser(userId); // 1s const profile = await fetchUserProfile(userId); // 1s const posts = await fetchUserPosts(userId); // 1s // Total: 3s return { user, profile, posts }; } // Chạy song song với Promise.all() async function getUserDataParallel(userId) { const [user, profile, posts] = await Promise.all([ fetchUser(userId), // All run in parallel fetchUserProfile(userId), // Total: 1s (longest operation) fetchUserPosts(userId), ]); return { user, profile, posts }; } // Promise.allSettled() - Không fail nếu 1 promise reject async function getUserDataSafe(userId) { const results = await Promise.allSettled([ fetchUser(userId), fetchUserProfile(userId), fetchUserPosts(userId), ]); return results.map((result) =\u0026gt; { if (result.status === \u0026#34;fulfilled\u0026#34;) { return result.value; } else { console.error(\u0026#34;Failed:\u0026#34;, result.reason); return null; } }); } Async/Await - Promise syntax đường // Từ Promise chain function getUserData(userId) { return fetchUser(userId) .then((user) =\u0026gt; fetchUserProfile(user.id)) .then((profile) =\u0026gt; fetchUserPosts(profile.userId)) .then((posts) =\u0026gt; ({ user, profile, posts })) .catch((error) =\u0026gt; { console.error(\u0026#34;Error:\u0026#34;, error); throw error; }); } // Đến async/await - clean hơn nhiều! async function getUserData(userId) { try { const user = await fetchUser(userId); const profile = await fetchUserProfile(user.id); const posts = await fetchUserPosts(profile.userId); return { user, profile, posts }; } catch (error) { console.error(\u0026#34;Error:\u0026#34;, error); throw error; } } Java CompletableFuture - Modern Async Java CompletableFuture Basics import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class AsyncService { private ExecutorService executor = Executors.newFixedThreadPool(10); // Tạo CompletableFuture đơn giản public CompletableFuture\u0026lt;User\u0026gt; fetchUser(String userId) { return CompletableFuture.supplyAsync(() -\u0026gt; { // Simulate delay try { Thread.sleep(1000); if (Integer.parseInt(userId) \u0026gt; 0) { return new User(userId, \u0026#34;User \u0026#34; + userId); } else { throw new RuntimeException(\u0026#34;Invalid user ID\u0026#34;); } } catch (InterruptedException e) { throw new RuntimeException(e); } }, executor); } // Chain operations public CompletableFuture\u0026lt;UserData\u0026gt; getUserData(String userId) { return fetchUser(userId) .thenCompose(user -\u0026gt; fetchUserProfile(user.getId()) .thenApply(profile -\u0026gt; new UserData(user, profile)) ) .thenCompose(userData -\u0026gt; fetchUserPosts(userData.getUser().getId()) .thenApply(posts -\u0026gt; { userData.setPosts(posts); return userData; }) ) .exceptionally(throwable -\u0026gt; { System.err.println(\u0026#34;Error: \u0026#34; + throwable.getMessage()); return null; }); } } Parallel Execution với CompletableFuture public CompletableFuture\u0026lt;UserData\u0026gt; getUserDataParallel(String userId) { CompletableFuture\u0026lt;User\u0026gt; userFuture = fetchUser(userId); CompletableFuture\u0026lt;Profile\u0026gt; profileFuture = fetchUserProfile(userId); CompletableFuture\u0026lt;List\u0026lt;Post\u0026gt;\u0026gt; postsFuture = fetchUserPosts(userId); // Combine all results return userFuture.thenCombine(profileFuture, (user, profile) -\u0026gt; new UserData(user, profile) ).thenCombine(postsFuture, (userData, posts) -\u0026gt; { userData.setPosts(posts); return userData; }); } // allOf() - giống Promise.all() public CompletableFuture\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; fetchMultipleUsers(List\u0026lt;String\u0026gt; userIds) { List\u0026lt;CompletableFuture\u0026lt;User\u0026gt;\u0026gt; futures = userIds.stream() .map(this::fetchUser) .collect(Collectors.toList()); CompletableFuture\u0026lt;Void\u0026gt; allFutures = CompletableFuture.allOf( futures.toArray(new CompletableFuture[0]) ); return allFutures.thenApply(v -\u0026gt; futures.stream() .map(CompletableFuture::join) // Get results .map(User::getName) .collect(Collectors.toList()) ); } So sánh trực tiếp Promise vs CompletableFuture 1. Tạo async operation JavaScript:\nconst promise = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(\u0026#34;Done!\u0026#34;), 1000); }); // Hoặc với async function const asyncFunction = async () =\u0026gt; { return \u0026#34;Done!\u0026#34;; }; Java:\nCompletableFuture\u0026lt;String\u0026gt; future = CompletableFuture.supplyAsync(() -\u0026gt; { try { Thread.sleep(1000); } catch (InterruptedException e) {} return \u0026#34;Done!\u0026#34;; }); // Hoặc completed future CompletableFuture\u0026lt;String\u0026gt; completedFuture = CompletableFuture.completedFuture(\u0026#34;Done!\u0026#34;); 2. Chain operations JavaScript:\npromise .then((result) =\u0026gt; result.toUpperCase()) .then((upper) =\u0026gt; upper + \u0026#34; - FINISHED\u0026#34;) .catch((error) =\u0026gt; \u0026#34;Error: \u0026#34; + error); Java:\nfuture .thenApply(result -\u0026gt; result.toUpperCase()) .thenApply(upper -\u0026gt; upper + \u0026#34; - FINISHED\u0026#34;) .exceptionally(error -\u0026gt; \u0026#34;Error: \u0026#34; + error.getMessage()); 3. Combine multiple operations JavaScript:\nPromise.all([promise1, promise2, promise3]).then( ([result1, result2, result3]) =\u0026gt; { return { result1, result2, result3 }; } ); Java:\nfuture1.thenCombine(future2, (r1, r2) -\u0026gt; new Pair(r1, r2)) .thenCombine(future3, (pair, r3) -\u0026gt; new Result(pair.getFirst(), pair.getSecond(), r3) ); // Hoặc với allOf CompletableFuture.allOf(future1, future2, future3) .thenApply(v -\u0026gt; new Result( future1.join(), future2.join(), future3.join() )); Real-world Example: API Gateway JavaScript Implementation: class APIGateway { async handleRequest(request) { try { // Authenticate user const user = await this.authenticate(request.token); // Fetch data in parallel const [userData, permissions, preferences] = await Promise.all([ this.fetchUserData(user.id), this.fetchUserPermissions(user.id), this.fetchUserPreferences(user.id), ]); // Transform data const response = await this.transformResponse({ user: userData, permissions, preferences, }); return response; } catch (error) { return this.handleError(error); } } async fetchUserData(userId) { const response = await fetch(`/api/users/${userId}`); if (!response.ok) { throw new Error(`HTTP ${response.status}`); } return response.json(); } } Java Implementation: @Service public class APIGateway { private final ExecutorService executor = Executors.newFixedThreadPool(20); public CompletableFuture\u0026lt;APIResponse\u0026gt; handleRequest(APIRequest request) { return authenticate(request.getToken()) .thenCompose(user -\u0026gt; { // Fetch data in parallel CompletableFuture\u0026lt;UserData\u0026gt; userDataFuture = fetchUserData(user.getId()); CompletableFuture\u0026lt;List\u0026lt;Permission\u0026gt;\u0026gt; permissionsFuture = fetchUserPermissions(user.getId()); CompletableFuture\u0026lt;Preferences\u0026gt; preferencesFuture = fetchUserPreferences(user.getId()); return userDataFuture.thenCombine(permissionsFuture, (userData, permissions) -\u0026gt; new Pair\u0026lt;\u0026gt;(userData, permissions)) .thenCombine(preferencesFuture, (pair, preferences) -\u0026gt; new RequestData(pair.getFirst(), pair.getSecond(), preferences) ); }) .thenCompose(this::transformResponse) .exceptionally(this::handleError); } private CompletableFuture\u0026lt;UserData\u0026gt; fetchUserData(String userId) { return CompletableFuture.supplyAsync(() -\u0026gt; { // HTTP call implementation try { return restTemplate.getForObject(\u0026#34;/api/users/\u0026#34; + userId, UserData.class); } catch (Exception e) { throw new RuntimeException(\u0026#34;Failed to fetch user data\u0026#34;, e); } }, executor); } } Performance \u0026amp; Lessons Learned Performance Comparison: JavaScript Promise: Single-threaded event loop, excellent cho I/O operations Java CompletableFuture: Multi-threaded, tốt cho CPU-intensive tasks Best Practices: JavaScript:\nLuôn dùng async/await thay vì .then() chains Dùng Promise.all() cho parallel operations Handle errors với try/catch Avoid creating unnecessary Promises Java:\nSử dụng custom ExecutorService Handle exceptions với exceptionally() hoặc handle() Dùng thenCombine() cho parallel operations Remember to shutdown ExecutorService Kết luận Cả Promise và CompletableFuture đều là tools mạnh mẽ cho async programming:\nPromise: Đơn giản hơn, syntax clean với async/await CompletableFuture: Mạnh mẽ hơn, control tốt hơn threading Quan trọng là hiểu concept async programming, sau đó syntax chỉ là matter of practice!\nCác bạn đã dùng async programming chưa? Share kinh nghiệm ở comment nhé!\nAsync is the future! ⚡🚀\n","permalink":"http://localhost:1313/blog/promise-vs-completablefuture/intex/","tags":["javascript","java","async","promise","completablefuture"],"title":"Async Programming: Promise (JS) vs CompletableFuture (Java) - Battle of Asynchronous!"},{"categories":["Backend Development"],"contents":"Xin chào các bạn! Sau khi học cả Java và JavaScript, mình có cơ hội làm việc với cả Spring Boot và Node.js trong các dự án thực tế. Hôm nay mình muốn chia sẻ trải nghiệm của mình khi develop backend với hai platform này.\nDự án đầu tiên với Spring Boot 🍃 Setup ban đầu Khi mới bắt đầu với Spring Boot, mình cảm thấy hơi choáng với số lượng config:\n// Application.java @SpringBootApplication public class BlogApplication { public static void main(String[] args) { SpringApplication.run(BlogApplication.class, args); } } // User.java - JPA Entity @Entity @Table(name = \u0026#34;users\u0026#34;) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, unique = true) private String email; @Column(nullable = false) private String password; // Constructor, getters, setters... } // UserRepository.java @Repository public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt; { Optional\u0026lt;User\u0026gt; findByEmail(String email); } // UserController.java @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) public class UserController { @Autowired private UserService userService; @PostMapping public ResponseEntity\u0026lt;User\u0026gt; createUser(@Valid @RequestBody UserDTO userDTO) { User user = userService.createUser(userDTO); return ResponseEntity.status(HttpStatus.CREATED).body(user); } } Những điều mình thích ở Spring Boot: Convention over Configuration - Ít config hơn Spring truyền thống Dependency Injection - Auto-wiring cực kỳ mạnh mẽ JPA/Hibernate - ORM mạnh mẽ, query phức tạp dễ dàng Security - Spring Security handle authentication/authorization tốt Testing - Test infrastructure rất complete Những khó khăn: Learning curve - Cần hiểu về Spring ecosystem Memory usage - JVM khá \u0026ldquo;nặng\u0026rdquo; Startup time - Khởi động chậm hơn Node.js Annotation hell - Quá nhiều annotation có thể confusing Chuyển sang Node.js - Một thế giới khác 🚀 Express.js setup // app.js const express = require(\u0026#34;express\u0026#34;); const mongoose = require(\u0026#34;mongoose\u0026#34;); const bcrypt = require(\u0026#34;bcryptjs\u0026#34;); const jwt = require(\u0026#34;jsonwebtoken\u0026#34;); const app = express(); app.use(express.json()); // User Model với Mongoose const userSchema = new mongoose.Schema({ email: { type: String, required: true, unique: true }, password: { type: String, required: true }, createdAt: { type: Date, default: Date.now }, }); const User = mongoose.model(\u0026#34;User\u0026#34;, userSchema); // User Routes app.post(\u0026#34;/api/users\u0026#34;, async (req, res) =\u0026gt; { try { const { email, password } = req.body; const existingUser = await User.findOne({ email }); if (existingUser) { return res.status(400).json({ message: \u0026#34;User already exists\u0026#34; }); } const hashedPassword = await bcrypt.hash(password, 10); const user = new User({ email, password: hashedPassword }); await user.save(); res.status(201).json({ id: user._id, email: user.email }); } catch (error) { res.status(500).json({ message: error.message }); } }); // Connect to MongoDB mongoose .connect(\u0026#34;mongodb://localhost:27017/myapp\u0026#34;) .then(() =\u0026gt; console.log(\u0026#34;Connected to MongoDB\u0026#34;)) .catch((err) =\u0026gt; console.error(\u0026#34;MongoDB connection error:\u0026#34;, err)); app.listen(3000, () =\u0026gt; { console.log(\u0026#34;Server running on port 3000\u0026#34;); }); Những điều mình thích ở Node.js: Fast development - Viết code nhanh, setup đơn giản JavaScript everywhere - Same language frontend/backend NPM ecosystem - Package có sẵn cho mọi thứ Lightweight - Memory footprint nhỏ hơn JVM Fast startup - Server khởi động trong giây lát Những thách thức: Callback/Promise hell - Nếu không handle tốt async code Single-threaded - CPU-intensive tasks có thể block Type safety - JavaScript dynamic typing đôi khi gây bugs Package management - Dependency hell với npm So sánh thực tế qua dự án Dự án E-commerce Platform Mình đã implement cùng một API cho hệ thống e-commerce với cả hai technologies:\nPerformance Test Results: Concurrent Users: 1000\rTest Duration: 5 minutes\rSpring Boot (Java 17 + PostgreSQL):\r- Average Response Time: 45ms\r- Throughput: 2,200 req/sec\r- Memory Usage: 512MB\r- CPU Usage: 35%\rNode.js (Express + MongoDB):\r- Average Response Time: 38ms\r- Throughput: 2,800 req/sec\r- Memory Usage: 128MB\r- CPU Usage: 28% Development Speed: Spring Boot:\nSetup time: 30 phút (config database, dependencies) CRUD operations: 2 giờ Authentication: 1 giờ (Spring Security) Unit tests: 1.5 giờ Total: ~5 giờ Node.js:\nSetup time: 10 phút CRUD operations: 1 giờ Authentication: 1.5 giờ (custom JWT) Unit tests: 1 giờ Total: ~3.5 giờ Khi nào dùng gì? Chọn Spring Boot khi: ✅ Enterprise applications - Cần security, scalability cao\n✅ Complex business logic - Nhiều rules phức tạp\n✅ Team lớn - Structure rõ ràng, maintainable\n✅ Legacy systems - Integration với Java ecosystem\n✅ Microservices - Spring Cloud ecosystem mạnh\n// Example: Complex business logic dễ handle với Java @Service @Transactional public class OrderService { public Order processOrder(OrderRequest request) { // Validate inventory inventoryService.checkAvailability(request.getItems()); // Apply discounts BigDecimal finalAmount = pricingService .calculateDiscount(request, customer.getTier()); // Process payment PaymentResult payment = paymentService .processPayment(customer.getPaymentMethod(), finalAmount); if (payment.isSuccessful()) { // Create order Order order = orderRepository.save( Order.builder() .customerId(customer.getId()) .amount(finalAmount) .status(OrderStatus.CONFIRMED) .build() ); // Send notifications notificationService.sendOrderConfirmation(order); return order; } throw new PaymentProcessingException(\u0026#34;Payment failed\u0026#34;); } } Chọn Node.js khi: ✅ Rapid prototyping - Cần develop nhanh\n✅ Real-time apps - Chat, live updates (Socket.io)\n✅ API-first approach - RESTful APIs đơn giản\n✅ Startup/Small team - Ít developers, cần flexibility\n✅ I/O intensive - Nhiều database calls, external APIs\n// Example: Real-time chat với Socket.io const io = require(\u0026#34;socket.io\u0026#34;)(server); io.on(\u0026#34;connection\u0026#34;, (socket) =\u0026gt; { console.log(\u0026#34;User connected:\u0026#34;, socket.id); socket.on(\u0026#34;join-room\u0026#34;, (roomId) =\u0026gt; { socket.join(roomId); socket.to(roomId).emit(\u0026#34;user-joined\u0026#34;, socket.id); }); socket.on(\u0026#34;message\u0026#34;, async (data) =\u0026gt; { // Save to database const message = await Message.create({ content: data.message, userId: data.userId, roomId: data.roomId, }); // Broadcast to room io.to(data.roomId).emit(\u0026#34;new-message\u0026#34;, message); }); socket.on(\u0026#34;disconnect\u0026#34;, () =\u0026gt; { console.log(\u0026#34;User disconnected:\u0026#34;, socket.id); }); }); Lessons Learned 1. Không có \u0026ldquo;silver bullet\u0026rdquo; Cả hai đều có ưu nhược điểm. Quan trọng là chọn tool phù hợp với requirements.\n2. Team skill matter Team giỏi Java → Spring Boot sẽ productive hơn Team frontend developers → Node.js dễ tiếp cận hơn 3. Maintenance is key Spring Boot có structure rõ ràng hơn cho long-term projects.\n4. Performance isn\u0026rsquo;t everything Developer productivity và time-to-market cũng quan trọng.\nKết luận Sau kinh nghiệm với cả hai, mình nhận ra:\nSpring Boot giống như một chiếc Mercedes - robust, reliable, powerful nhưng cần thời gian để master.\nNode.js giống như một chiếc motorbike - agile, fast, flexible nhưng cần cẩn thận khi handle complex scenarios.\nHiện tại mình đang sử dụng:\nSpring Boot cho enterprise projects, complex business logic Node.js cho prototypes, real-time features, simple APIs Các bạn có kinh nghiệm gì với hai platform này? Share ở comment nhé!\nChoose the right tool for the job! 🛠️\n","permalink":"http://localhost:1313/blog/springboot-vs-nodejs/","tags":["java","javascript","spring-boot","nodejs","backend"],"title":"Spring Boot vs Node.js: Trải nghiệm backend development của mình"},{"categories":["JavaScript"],"contents":"Chào mọi người! Khi mới học JavaScript, mình chỉ biết đến cú pháp cũ ES5. Nhưng khi tiếp xúc với ES6+ (ES2015 trở lên), thật sự mình cảm thấy như được \u0026ldquo;khai sáng\u0026rdquo;. Hôm nay mình muốn chia sẻ những tính năng ES6+ đã thay đổi hoàn toàn cách mình viết JavaScript.\n1. Let \u0026amp; Const - Tạm biệt var nhé! Cách cũ với var: // Vấn đề với var function oldWay() { for (var i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; { console.log(i); // In ra 3, 3, 3 (WTF???) }, 100); } console.log(i); // 3 - i vẫn tồn tại ngoài loop! } Cách mới với let \u0026amp; const: function newWay() { for (let i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; { console.log(i); // In ra 0, 1, 2 (chính xác!) }, 100); } // console.log(i); // ReferenceError - i không tồn tại ở đây const API_URL = \u0026#34;https://api.example.com\u0026#34;; // API_URL = \u0026#39;other-url\u0026#39;; // TypeError - không thể reassign const } Bài học: Luôn dùng const cho giá trị không thay đổi, let cho biến có thể thay đổi. Quên var đi!\n2. Arrow Functions - Code ngắn gọn hơn ES5 way: // Function expression cũ var users = [\u0026#34;Nam\u0026#34;, \u0026#34;Linh\u0026#34;, \u0026#34;Hoa\u0026#34;]; var uppercaseUsers = users.map(function (user) { return user.toUpperCase(); }); var button = document.getElementById(\u0026#34;btn\u0026#34;); button.addEventListener(\u0026#34;click\u0026#34;, function () { console.log(this); // \u0026#39;this\u0026#39; trỏ đến button }); ES6 way: // Arrow function - clean và concise const users = [\u0026#34;Nam\u0026#34;, \u0026#34;Linh\u0026#34;, \u0026#34;Hoa\u0026#34;]; const uppercaseUsers = users.map((user) =\u0026gt; user.toUpperCase()); // Với multiple parameters const add = (a, b) =\u0026gt; a + b; // Với function body const processUser = (user) =\u0026gt; { const processed = user.trim().toUpperCase(); return `Hello, ${processed}!`; }; // Lưu ý về \u0026#39;this\u0026#39; binding const obj = { name: \u0026#34;MyObject\u0026#34;, regularFunction() { console.log(this.name); // \u0026#39;MyObject\u0026#39; const arrowFunction = () =\u0026gt; { console.log(this.name); // \u0026#39;MyObject\u0026#39; - inherit từ parent scope }; arrowFunction(); }, }; Tip: Arrow function không có this binding riêng, nó inherit từ parent scope.\n3. Template Literals - Goodbye string concatenation! Cách cũ: var name = \u0026#34;Nam\u0026#34;; var age = 20; var city = \u0026#34;Ho Chi Minh\u0026#34;; var introduction = \u0026#34;Xin chào, tôi là \u0026#34; + name + \u0026#34;, \u0026#34; + age + \u0026#34; tuổi, \u0026#34; + \u0026#34;đến từ \u0026#34; + city + \u0026#34;.\u0026#34;; var htmlTemplate = \u0026#39;\u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt;\u0026#39; + \u0026#34;\u0026lt;h2\u0026gt;\u0026#34; + name + \u0026#34;\u0026lt;/h2\u0026gt;\u0026#34; + \u0026#34;\u0026lt;p\u0026gt;Age: \u0026#34; + age + \u0026#34;\u0026lt;/p\u0026gt;\u0026#34; + \u0026#34;\u0026lt;/div\u0026gt;\u0026#34;; Cách mới: const name = \u0026#34;Nam\u0026#34;; const age = 20; const city = \u0026#34;Ho Chi Minh\u0026#34;; // Template literals với backticks const introduction = `Xin chào, tôi là ${name}, ${age} tuổi, đến từ ${city}.`; // Multi-line strings dễ dàng const htmlTemplate = ` \u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;${name}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Age: ${age}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Status: ${age \u0026gt;= 18 ? \u0026#34;Adult\u0026#34; : \u0026#34;Minor\u0026#34;}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `; // Tagged template literals (advanced) function highlight(strings, ...values) { return strings.reduce((result, string, i) =\u0026gt; { const value = values[i] ? `\u0026lt;mark\u0026gt;${values[i]}\u0026lt;/mark\u0026gt;` : \u0026#34;\u0026#34;; return result + string + value; }, \u0026#34;\u0026#34;); } const highlighted = highlight`Tôi tên là ${name} và ${age} tuổi.`; 4. Destructuring - Unpack dữ liệu như ninja Array Destructuring: // Cách cũ var numbers = [1, 2, 3, 4, 5]; var first = numbers[0]; var second = numbers[1]; var rest = numbers.slice(2); // Cách mới const [first, second, ...rest] = [1, 2, 3, 4, 5]; console.log(first); // 1 console.log(second); // 2 console.log(rest); // [3, 4, 5] // Skip elements const [a, , c] = [1, 2, 3]; console.log(a, c); // 1, 3 // Default values const [x = 0, y = 0] = [1]; // x = 1, y = 0 Object Destructuring: // Cách cũ var user = { name: \u0026#34;Nam\u0026#34;, age: 20, email: \u0026#34;nam@example.com\u0026#34;, address: { city: \u0026#34;Ho Chi Minh\u0026#34;, district: \u0026#34;District 1\u0026#34;, }, }; var name = user.name; var age = user.age; var email = user.email; // Cách mới const { name, age, email } = user; // Rename variables const { name: userName, age: userAge } = user; // Nested destructuring const { address: { city, district }, } = user; // Default values const { phone = \u0026#34;N/A\u0026#34; } = user; // Function parameters destructuring function greetUser({ name, age = \u0026#34;unknown\u0026#34; }) { return `Hello ${name}, you are ${age} years old`; } greetUser({ name: \u0026#34;Nam\u0026#34;, age: 20 }); 5. Spread \u0026amp; Rest Operators - Ba chấm ma thuật Spread Operator (\u0026hellip;): // Array spreading const arr1 = [1, 2, 3]; const arr2 = [4, 5, 6]; const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6] // Object spreading const user = { name: \u0026#34;Nam\u0026#34;, age: 20 }; const updatedUser = { ...user, age: 21, city: \u0026#34;HCM\u0026#34; }; // { name: \u0026#39;Nam\u0026#39;, age: 21, city: \u0026#39;HCM\u0026#39; } // Function arguments function sum(a, b, c) { return a + b + c; } const numbers = [1, 2, 3]; console.log(sum(...numbers)); // 6 Rest Operator (\u0026hellip;): // Function parameters function logAll(first, ...others) { console.log(\u0026#34;First:\u0026#34;, first); console.log(\u0026#34;Others:\u0026#34;, others); } logAll(1, 2, 3, 4, 5); // First: 1, Others: [2, 3, 4, 5] // Array destructuring (đã thấy ở trên) const [head, ...tail] = [1, 2, 3, 4, 5]; 6. Enhanced Object Literals const name = \u0026#34;Nam\u0026#34;; const age = 20; // Cách cũ var user = { name: name, age: age, greet: function () { return \u0026#34;Hello!\u0026#34;; }, }; // Cách mới - shorthand properties const user = { name, // tương đương name: name age, // tương đương age: age // Method shorthand greet() { return \u0026#34;Hello!\u0026#34;; }, // Computed property names [`full${name}`]: `${name} Nguyen`, // Dynamic property [getPropertyName()]: \u0026#34;dynamic value\u0026#34;, }; 7. Promises \u0026amp; Async/Await - Tạm biệt Callback Hell Callback Hell: // Cách cũ - callback hell fetchUser(userId, function (user) { fetchUserPosts(user.id, function (posts) { fetchPostComments(posts[0].id, function (comments) { // Nested callbacks - khó đọc và maintain console.log(comments); }); }); }); Promises: // Promise chain fetchUser(userId) .then((user) =\u0026gt; fetchUserPosts(user.id)) .then((posts) =\u0026gt; fetchPostComments(posts[0].id)) .then((comments) =\u0026gt; console.log(comments)) .catch((error) =\u0026gt; console.error(error)); Async/Await: // Async/await - code như synchronous async function getUserData(userId) { try { const user = await fetchUser(userId); const posts = await fetchUserPosts(user.id); const comments = await fetchPostComments(posts[0].id); return comments; } catch (error) { console.error(\u0026#34;Error:\u0026#34;, error); throw error; } } // Sử dụng getUserData(123).then((data) =\u0026gt; console.log(data)); Kết luận ES6+ đã thực sự thay đổi cách mình viết JavaScript:\nCode ngắn gọn và dễ đọc hơn Ít bugs hơn nhờ let/const Xử lý async code dễ dàng hơn Destructuring giúp unpack data elegantly Tips cho người mới: Học từ từ - Đừng cố gắng học tất cả một lúc Practice daily - Viết code ES6+ mỗi ngày Use Babel - Để support browser cũ Read MDN docs - Tài liệu chính thức luôn tốt nhất Các bạn đã dùng feature nào trong số này chưa? Feature nào khiến các bạn ấn tượng nhất? Share ở comment nhé!\nModern JavaScript is beautiful! 🚀✨\n","permalink":"http://localhost:1313/blog/javascript-es6+/","tags":["javascript","es6","modern-js","kinh-nghiem"],"title":"JavaScript ES6+: Những tính năng đã thay đổi cách mình code"},{"categories":null,"contents":"","permalink":"http://localhost:1313/blog/design-patterns/","tags":null,"title":""},{"categories":null,"contents":"Xin chào! Tôi là Tiết Thanh Minh Hiếu 👋 Câu chuyện của tôi Tôi là một sinh viên đang theo đuổi ước mơ trở thành chuyên viên An Ninh Mạng, với niềm đam mê bảo vệ thế giới số khỏi những mối đe dọa ngày càng phức tạp. Nhưng điều đặc biệt là tôi không chỉ muốn \u0026ldquo;làm\u0026rdquo; mà còn muốn \u0026ldquo;truyền cảm hứng\u0026rdquo; - mục tiêu của tôi là trở thành một giảng viên Security, người có thể biến những kiến thức phức tạp thành những bài học dễ hiểu và thú vị.\nTại sao tôi tạo blog này? Ban đầu, blog này được tạo ra để hoàn thành yêu cầu môn học về Java \u0026amp; JavaScript. Nhưng tôi nhận ra đây chính là cơ hội tuyệt vời để bắt đầu hành trình chia sẻ kiến thức mà tôi đã ấp ủ từ lâu.\nTôi tin rằng: Cách học tốt nhất là dạy lại cho người khác. Mỗi bài viết tôi chia sẻ không chỉ giúp các bạn đọc mà còn giúp tôi củng cố và mở rộng kiến thức của chính mình.\nNhững gì tôi đang làm 🔍 An Ninh Mạng Hiện tại tôi đang xây dựng nền tảng vững chắc với các chứng chỉ từ Google Cybersecurity và IBM. Kiến thức mạng cơ bản đã giúp tôi hiểu được \u0026ldquo;bức tranh lớn\u0026rdquo; của bảo mật.\n🤖 AI \u0026amp; Machine Learning Tôi có kinh nghiệm training model, đặc biệt là BERT. Dự án gần nhất của tôi là \u0026ldquo;Phát hiện mã độc Android bằng Transformer Networks (BERT)\u0026rdquo; - một project thú vị kết hợp giữa AI và Cybersecurity.\n💻 Lập trình Java và JavaScript là những ngôn ngữ tôi đang tập trung, nhưng hành trình coding của tôi không dừng lại ở đó!\nĐiều gì khiến blog này khác biệt? Không chỉ là lý thuyết khô khan. Tôi sẽ chia sẻ:\n✨ Kinh nghiệm thực tế từ các project đã làm 🎯 Cách tiếp cận thực tế thay vì chỉ đọc sách vở 🔧 Tips \u0026amp; tricks mà tôi học được qua quá trình \u0026ldquo;vấp ngã\u0026rdquo; 📚 Kiến thức được \u0026ldquo;dịch\u0026rdquo; sang ngôn ngữ dễ hiểu Mục tiêu của tôi là biến những khái niệm phức tạp thành những câu chuyện thú vị mà bất kỳ ai cũng có thể hiểu được.\nTầm nhìn tương lai Tôi mơ ước một ngày nào đó sẽ đứng trên bục giảng, truyền cảm hứng cho thế hệ các chuyên gia bảo mật tương lai. Blog này chính là bước đầu tiên trong hành trình rèn luyện kỹ năng truyền đạt của tôi.\nMỗi bài viết là một bài giảng nhỏ, mỗi chia sẻ là một lần thực hành để tôi có thể diễn đạt tốt hơn, rõ ràng hơn.\nLời kết Nếu bạn là người:\n🎓 Đang học về Cybersecurity, Java, JavaScript hoặc AI 🔍 Muốn hiểu cách áp dụng kiến thức vào thực tế 💡 Thích học thông qua kinh nghiệm thực tế hơn là lý thuyết suông Thì blog này dành cho bạn! Tôi hy vọng những chia sẻ của mình sẽ giúp ích cho hành trình học tập của các bạn, đồng thời cũng giúp tôi trở thành một người truyền đạt giỏi hơn.\nHãy cùng học, cùng phát triển và cùng tạo nên một cộng đồng tech Việt Nam mạnh mẽ! 🚀\n\u0026ldquo;The best way to learn is to teach others\u0026rdquo; - và đó chính là triết lý tôi theo đuổi trong mỗi bài viết.\n","permalink":"http://localhost:1313/about/","tags":null,"title":"Giới thiệu"},{"categories":null,"contents":"Trong lập trình mạng bằng Java, Socket là công cụ giúp kết nối giữa client và server.\nBằng cách sử dụng java.net.Socket và java.net.ServerSocket, ta có thể xây dựng các ứng dụng chat, truyền file hoặc HTTP server đơn giản.\nMô hình Client-Server cơ bản trong lập trình Socket Ở mức thấp hơn, kết nối TCP được thiết lập qua quá trình bắt tay 3 bước (TCP Handshake).\nĐiều này đảm bảo client và server đồng bộ trạng thái trước khi truyền dữ liệu.\nCơ chế bắt tay 3 bước TCP (Three-Way Handshake) ","permalink":"http://localhost:1313/blog/java-socket/","tags":["Java","Networking"],"title":"Kết nối Socket trong Java"},{"categories":["Programming"],"contents":"Chào các bạn! Hôm nay mình muốn chia sẻ về hành trình học lập trình của mình, từ Java đến JavaScript. Có lẽ nhiều bạn cũng đang băn khoăn giống mình: nên bắt đầu với ngôn ngữ nào? Học Java trước hay JavaScript trước?\nKhởi đầu với Java - Nền tảng vững chắc Mình bắt đầu với Java từ năm nhất đại học. Thật sự lúc đầu khá choáng với cú pháp dài dòng của Java:\npublic class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Hello, World!\u0026#34;); } } So với \u0026ldquo;Hello World\u0026rdquo; của JavaScript:\nconsole.log(\u0026#34;Hello, World!\u0026#34;); Wow, khác biệt quá phải không? Nhưng qua thời gian, mình nhận ra Java đã dạy mình những điều quan trọng:\n1. Tư duy hướng đối tượng (OOP) Java buộc mình phải hiểu về Class, Object, Inheritance\u0026hellip; Lúc đầu khó hiểu lắm, nhưng sau này khi làm dự án lớn mới thấy tầm quan trọng của nó.\n2. Tính nghiêm ngặt về kiểu dữ liệu int number = 10; // Phải khai báo kiểu rõ ràng String text = \u0026#34;Hello\u0026#34;; // Không thể gán số vào String 3. Cấu trúc dự án rõ ràng Package, import, access modifier\u0026hellip; tất cả đều có quy tắc rõ ràng.\nChuyển sang JavaScript - Tự do nhưng cần kỷ luật Khi bắt đầu học JavaScript, mình cảm thấy như được \u0026ldquo;giải phóng\u0026rdquo;:\nlet data = 10; // Kiểu number data = \u0026#34;Hello\u0026#34;; // Giờ thành string data = [1, 2, 3]; // Giờ thành array data = { name: \u0026#34;John\u0026#34; }; // Giờ thành object Tự do quá! Nhưng cũng dễ rối loạn không kém.\nNhững khác biệt chính mình nhận ra: Java:\nCompiled language (biên dịch trước) Strongly typed (kiểu dữ liệu nghiêm ngặt) Platform independent (chạy trên JVM) Chủ yếu cho backend JavaScript:\nInterpreted language (thông dịch) Dynamically typed (kiểu dữ liệu linh hoạt) Chạy trên browser/Node.js Full-stack (cả frontend và backend) Bài học rút ra 1. Java là nền tảng tốt để bắt đầu Nếu bạn chưa biết gì về lập trình, mình khuyên nên bắt đầu với Java. Tại sao?\nBuộc bạn phải viết code chuẩn Hiểu rõ về cấu trúc dữ liệu Tư duy logic tốt hơn 2. JavaScript cần kỷ luật bản thân Vì quá linh hoạt, JavaScript dễ làm cho code trở nên lộn xộn. Mình học được:\nĐặt tên biến có ý nghĩa Sử dụng const/let thay vì var Comment code đầy đủ 3. Cả hai đều có giá trị Java: Tốt cho hệ thống lớn, enterprise applications JavaScript: Linh hoạt, phát triển nhanh, cộng đồng active Lời kết Hành trình từ Java đến JavaScript đã dạy mình rằng không có ngôn ngữ nào là \u0026ldquo;tốt nhất\u0026rdquo;. Mỗi ngôn ngữ đều có ưu nhược điểm riêng. Quan trọng là hiểu rõ bản chất và áp dụng đúng context.\nCác bạn có kinh nghiệm gì thú vị khi học hai ngôn ngữ này không? Hãy chia sẻ trong comment nhé!\nHappy coding! 🚀\n","permalink":"http://localhost:1313/blog/java-to-javascript/","tags":["java","javascript","kinh-nghiem","hoc-tap"],"title":"Từ Java đến JavaScript: Hành trình học lập trình của mình"},{"categories":["Java"],"contents":"Xin chào các bạn! Hôm nay mình muốn chia sẻ về những sai lầm \u0026ldquo;kinh điển\u0026rdquo; mà hầu như ai học Java cũng mắc phải, bao gồm cả mình. Hy vọng qua bài viết này, các bạn newbie sẽ tránh được những \u0026ldquo;hố đen\u0026rdquo; mà mình đã rơi vào.\nSai lầm #1: Lạm dụng public static void main Mình từng làm thế này: public class Calculator { public static void main(String[] args) { // Viết tất cả logic trong main int a = 10, b = 5; int sum = a + b; int diff = a - b; int product = a * b; int quotient = a / b; System.out.println(\u0026#34;Sum: \u0026#34; + sum); System.out.println(\u0026#34;Difference: \u0026#34; + diff); // ... và còn 50 dòng code nữa } } Vấn đề: Code không thể tái sử dụng Khó debug và maintain Không theo nguyên tắc OOP Cách khắc phục: public class Calculator { public int add(int a, int b) { return a + b; } public int subtract(int a, int b) { return a - b; } public static void main(String[] args) { Calculator calc = new Calculator(); System.out.println(\u0026#34;Sum: \u0026#34; + calc.add(10, 5)); System.out.println(\u0026#34;Difference: \u0026#34; + calc.subtract(10, 5)); } } Sai lầm #2: Không hiểu về Reference vs Value Mình từng nghĩ: public class Student { String name; public static void main(String[] args) { Student s1 = new Student(); s1.name = \u0026#34;Nam\u0026#34;; Student s2 = s1; // Mình tưởng s2 là bản copy của s1 s2.name = \u0026#34;Linh\u0026#34;; System.out.println(s1.name); // Tại sao lại in ra \u0026#34;Linh\u0026#34;??? } } Bài học: Trong Java, object được truyền theo reference, không phải value. Khi gán s2 = s1, cả hai đều trỏ đến cùng một object trong memory.\nGiải pháp: public class Student implements Cloneable { String name; public Student(String name) { this.name = name; } // Constructor copy public Student(Student other) { this.name = other.name; } public static void main(String[] args) { Student s1 = new Student(\u0026#34;Nam\u0026#34;); Student s2 = new Student(s1); // Tạo object mới s2.name = \u0026#34;Linh\u0026#34;; System.out.println(s1.name); // \u0026#34;Nam\u0026#34; System.out.println(s2.name); // \u0026#34;Linh\u0026#34; } } Sai lầm #3: Không xử lý Exception đúng cách Code \u0026ldquo;tệ\u0026rdquo; của mình: public void readFile(String fileName) { try { FileReader file = new FileReader(fileName); BufferedReader reader = new BufferedReader(file); String line = reader.readLine(); System.out.println(line); } catch (Exception e) { // Im lặng, không làm gì cả - RỐT THẬM TỆ! } } Vấn đề: \u0026ldquo;Nuốt\u0026rdquo; exception mà không xử lý Sử dụng Exception quá general Không đóng resource Cách đúng: public void readFile(String fileName) { try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) { String line = reader.readLine(); if (line != null) { System.out.println(line); } } catch (FileNotFoundException e) { System.err.println(\u0026#34;Không tìm thấy file: \u0026#34; + fileName); // Log hoặc throw lại exception } catch (IOException e) { System.err.println(\u0026#34;Lỗi đọc file: \u0026#34; + e.getMessage()); } } Sai lầm #4: So sánh String bằng == Code sai: public class StringComparison { public static void main(String[] args) { String s1 = \u0026#34;Hello\u0026#34;; String s2 = new String(\u0026#34;Hello\u0026#34;); if (s1 == s2) { // SAAAIIII! System.out.println(\u0026#34;Equal\u0026#34;); } else { System.out.println(\u0026#34;Not equal\u0026#34;); // Sẽ in ra này } } } Giải thích: == so sánh reference, không phải content s1 trỏ đến String Pool s2 trỏ đến object mới trong heap Cách đúng: public class StringComparison { public static void main(String[] args) { String s1 = \u0026#34;Hello\u0026#34;; String s2 = new String(\u0026#34;Hello\u0026#34;); if (s1.equals(s2)) { // So sánh content System.out.println(\u0026#34;Equal\u0026#34;); } // Hoặc an toàn hơn với null check if (Objects.equals(s1, s2)) { System.out.println(\u0026#34;Equal and null-safe\u0026#34;); } } } Sai lầm #5: Không hiểu về Access Modifier Code của mình lúc trước: public class BankAccount { public double balance; // Ai cũng có thể truy cập! public BankAccount(double initialBalance) { balance = initialBalance; } } // Ở nơi khác BankAccount account = new BankAccount(1000); account.balance = -500; // Oops! Balance âm??? Vấn đề: Dữ liệu quan trọng không được bảo vệ Vi phạm nguyên tắc Encapsulation Cách khắc phục: public class BankAccount { private double balance; // Chỉ class này truy cập được public BankAccount(double initialBalance) { if (initialBalance \u0026gt;= 0) { this.balance = initialBalance; } else { throw new IllegalArgumentException(\u0026#34;Balance không thể âm\u0026#34;); } } public double getBalance() { return balance; } public void deposit(double amount) { if (amount \u0026gt; 0) { balance += amount; } } public boolean withdraw(double amount) { if (amount \u0026gt; 0 \u0026amp;\u0026amp; amount \u0026lt;= balance) { balance -= amount; return true; } return false; } } Tổng kết Những sai lầm này đã giúp mình hiểu sâu hơn về Java. Đừng sợ mắc lỗi, quan trọng là học hỏi từ chúng!\nTips để tránh sai lầm: Practice coding every day - Luyện tập thường xuyên Read other people\u0026rsquo;s code - Đọc code của người khác Use IDE effectively - Tận dụng IDE để catch lỗi sớm Code review - Nhờ bạn bè review code Read documentation - Đọc docs chính thức của Java Các bạn đã mắc phải sai lầm nào trong danh sách này chưa? Hoặc có sai lầm nào khác muốn chia sẻ? Comment bên dưới nhé!\nKeep learning, keep coding! ☕\n","permalink":"http://localhost:1313/blog/5-wrong-errors/","tags":["java","sai-lam","kinh-nghiem","hoc-tap"],"title":"5 Sai lầm phổ biến khi học Java mà mình đã mắc phải"},{"categories":["Async Programming"],"contents":"Chào các bạn! Async programming là một trong những concepts khó nhất khi học lập trình. Mình đã struggle với nó khá lâu, từ callback hell của JavaScript đến thread complexity của Java. Hôm nay mình muốn chia sẻ cách hai ngôn ngữ này handle async operations - JavaScript với Promise và Java với CompletableFuture.\nCâu chuyện bắt đầu từ Synchronous Hell JavaScript - Callback Hell // Cách xưa - callback nightmare! function getUserData(userId, callback) { fetchUser(userId, (user) =\u0026gt; { if (user) { fetchUserProfile(user.id, (profile) =\u0026gt; { if (profile) { fetchUserPosts(user.id, (posts) =\u0026gt; { if (posts) { fetchPostComments(posts[0].id, (comments) =\u0026gt; { // 4 levels deep! Pyramid of doom 😱 callback({ user, profile, posts, comments }); }); } else { callback(null, \u0026#34;No posts found\u0026#34;); } }); } else { callback(null, \u0026#34;Profile not found\u0026#34;); } }); } else { callback(null, \u0026#34;User not found\u0026#34;); } }); } Java - Thread Complexity // Cách xưa với Thread public void getUserDataOldWay(String userId) { new Thread(() -\u0026gt; { try { User user = fetchUser(userId); if (user != null) { new Thread(() -\u0026gt; { try { Profile profile = fetchUserProfile(user.getId()); if (profile != null) { // Nested threads everywhere! 😫 // Error handling nightmare // No easy way to combine results } } catch (Exception e) { // Handle error } }).start(); } } catch (Exception e) { // Handle error } }).start(); } JavaScript Promise - Giải cứu từ Callback Hell Promise Basics // Tạo Promise đơn giản function fetchUser(userId) { return new Promise((resolve, reject) =\u0026gt; { // Simulate API call setTimeout(() =\u0026gt; { if (userId \u0026gt; 0) { resolve({ id: userId, name: `User ${userId}` }); } else { reject(new Error(\u0026#34;Invalid user ID\u0026#34;)); } }, 1000); }); } // Sử dụng Promise fetchUser(123) .then((user) =\u0026gt; { console.log(\u0026#34;User:\u0026#34;, user); return user; // Pass data to next .then() }) .then((user) =\u0026gt; { // Chain another async operation return fetchUserProfile(user.id); }) .then((profile) =\u0026gt; { console.log(\u0026#34;Profile:\u0026#34;, profile); }) .catch((error) =\u0026gt; { console.error(\u0026#34;Error:\u0026#34;, error); }) .finally(() =\u0026gt; { console.log(\u0026#34;Cleanup code here\u0026#34;); }); Promise.all() - Chạy song song // Thay vì chạy tuần tự async function getUserDataSequential(userId) { const user = await fetchUser(userId); // 1s const profile = await fetchUserProfile(userId); // 1s const posts = await fetchUserPosts(userId); // 1s // Total: 3s return { user, profile, posts }; } // Chạy song song với Promise.all() async function getUserDataParallel(userId) { const [user, profile, posts] = await Promise.all([ fetchUser(userId), // All run in parallel fetchUserProfile(userId), // Total: 1s (longest operation) fetchUserPosts(userId), ]); return { user, profile, posts }; } // Promise.allSettled() - Không fail nếu 1 promise reject async function getUserDataSafe(userId) { const results = await Promise.allSettled([ fetchUser(userId), fetchUserProfile(userId), fetchUserPosts(userId), ]); return results.map((result) =\u0026gt; { if (result.status === \u0026#34;fulfilled\u0026#34;) { return result.value; } else { console.error(\u0026#34;Failed:\u0026#34;, result.reason); return null; } }); } Async/Await - Promise syntax đường // Từ Promise chain function getUserData(userId) { return fetchUser(userId) .then((user) =\u0026gt; fetchUserProfile(user.id)) .then((profile) =\u0026gt; fetchUserPosts(profile.userId)) .then((posts) =\u0026gt; ({ user, profile, posts })) .catch((error) =\u0026gt; { console.error(\u0026#34;Error:\u0026#34;, error); throw error; }); } // Đến async/await - clean hơn nhiều! async function getUserData(userId) { try { const user = await fetchUser(userId); const profile = await fetchUserProfile(user.id); const posts = await fetchUserPosts(profile.userId); return { user, profile, posts }; } catch (error) { console.error(\u0026#34;Error:\u0026#34;, error); throw error; } } Java CompletableFuture - Modern Async Java CompletableFuture Basics import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class AsyncService { private ExecutorService executor = Executors.newFixedThreadPool(10); // Tạo CompletableFuture đơn giản public CompletableFuture\u0026lt;User\u0026gt; fetchUser(String userId) { return CompletableFuture.supplyAsync(() -\u0026gt; { // Simulate delay try { Thread.sleep(1000); if (Integer.parseInt(userId) \u0026gt; 0) { return new User(userId, \u0026#34;User \u0026#34; + userId); } else { throw new RuntimeException(\u0026#34;Invalid user ID\u0026#34;); } } catch (InterruptedException e) { throw new RuntimeException(e); } }, executor); } // Chain operations public CompletableFuture\u0026lt;UserData\u0026gt; getUserData(String userId) { return fetchUser(userId) .thenCompose(user -\u0026gt; fetchUserProfile(user.getId()) .thenApply(profile -\u0026gt; new UserData(user, profile)) ) .thenCompose(userData -\u0026gt; fetchUserPosts(userData.getUser().getId()) .thenApply(posts -\u0026gt; { userData.setPosts(posts); return userData; }) ) .exceptionally(throwable -\u0026gt; { System.err.println(\u0026#34;Error: \u0026#34; + throwable.getMessage()); return null; }); } } Parallel Execution với CompletableFuture public CompletableFuture\u0026lt;UserData\u0026gt; getUserDataParallel(String userId) { CompletableFuture\u0026lt;User\u0026gt; userFuture = fetchUser(userId); CompletableFuture\u0026lt;Profile\u0026gt; profileFuture = fetchUserProfile(userId); CompletableFuture\u0026lt;List\u0026lt;Post\u0026gt;\u0026gt; postsFuture = fetchUserPosts(userId); // Combine all results return userFuture.thenCombine(profileFuture, (user, profile) -\u0026gt; new UserData(user, profile) ).thenCombine(postsFuture, (userData, posts) -\u0026gt; { userData.setPosts(posts); return userData; }); } // allOf() - giống Promise.all() public CompletableFuture\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; fetchMultipleUsers(List\u0026lt;String\u0026gt; userIds) { List\u0026lt;CompletableFuture\u0026lt;User\u0026gt;\u0026gt; futures = userIds.stream() .map(this::fetchUser) .collect(Collectors.toList()); CompletableFuture\u0026lt;Void\u0026gt; allFutures = CompletableFuture.allOf( futures.toArray(new CompletableFuture[0]) ); return allFutures.thenApply(v -\u0026gt; futures.stream() .map(CompletableFuture::join) // Get results .map(User::getName) .collect(Collectors.toList()) ); } So sánh trực tiếp Promise vs CompletableFuture 1. Tạo async operation JavaScript:\nconst promise = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(\u0026#34;Done!\u0026#34;), 1000); }); // Hoặc với async function const asyncFunction = async () =\u0026gt; { return \u0026#34;Done!\u0026#34;; }; Java:\nCompletableFuture\u0026lt;String\u0026gt; future = CompletableFuture.supplyAsync(() -\u0026gt; { try { Thread.sleep(1000); } catch (InterruptedException e) {} return \u0026#34;Done!\u0026#34;; }); // Hoặc completed future CompletableFuture\u0026lt;String\u0026gt; completedFuture = CompletableFuture.completedFuture(\u0026#34;Done!\u0026#34;); 2. Chain operations JavaScript:\npromise .then((result) =\u0026gt; result.toUpperCase()) .then((upper) =\u0026gt; upper + \u0026#34; - FINISHED\u0026#34;) .catch((error) =\u0026gt; \u0026#34;Error: \u0026#34; + error); Java:\nfuture .thenApply(result -\u0026gt; result.toUpperCase()) .thenApply(upper -\u0026gt; upper + \u0026#34; - FINISHED\u0026#34;) .exceptionally(error -\u0026gt; \u0026#34;Error: \u0026#34; + error.getMessage()); 3. Combine multiple operations JavaScript:\nPromise.all([promise1, promise2, promise3]).then( ([result1, result2, result3]) =\u0026gt; { return { result1, result2, result3 }; } ); Java:\nfuture1.thenCombine(future2, (r1, r2) -\u0026gt; new Pair(r1, r2)) .thenCombine(future3, (pair, r3) -\u0026gt; new Result(pair.getFirst(), pair.getSecond(), r3) ); // Hoặc với allOf CompletableFuture.allOf(future1, future2, future3) .thenApply(v -\u0026gt; new Result( future1.join(), future2.join(), future3.join() )); Real-world Example: API Gateway JavaScript Implementation: class APIGateway { async handleRequest(request) { try { // Authenticate user const user = await this.authenticate(request.token); // Fetch data in parallel const [userData, permissions, preferences] = await Promise.all([ this.fetchUserData(user.id), this.fetchUserPermissions(user.id), this.fetchUserPreferences(user.id), ]); // Transform data const response = await this.transformResponse({ user: userData, permissions, preferences, }); return response; } catch (error) { return this.handleError(error); } } async fetchUserData(userId) { const response = await fetch(`/api/users/${userId}`); if (!response.ok) { throw new Error(`HTTP ${response.status}`); } return response.json(); } } Java Implementation: @Service public class APIGateway { private final ExecutorService executor = Executors.newFixedThreadPool(20); public CompletableFuture\u0026lt;APIResponse\u0026gt; handleRequest(APIRequest request) { return authenticate(request.getToken()) .thenCompose(user -\u0026gt; { // Fetch data in parallel CompletableFuture\u0026lt;UserData\u0026gt; userDataFuture = fetchUserData(user.getId()); CompletableFuture\u0026lt;List\u0026lt;Permission\u0026gt;\u0026gt; permissionsFuture = fetchUserPermissions(user.getId()); CompletableFuture\u0026lt;Preferences\u0026gt; preferencesFuture = fetchUserPreferences(user.getId()); return userDataFuture.thenCombine(permissionsFuture, (userData, permissions) -\u0026gt; new Pair\u0026lt;\u0026gt;(userData, permissions)) .thenCombine(preferencesFuture, (pair, preferences) -\u0026gt; new RequestData(pair.getFirst(), pair.getSecond(), preferences) ); }) .thenCompose(this::transformResponse) .exceptionally(this::handleError); } private CompletableFuture\u0026lt;UserData\u0026gt; fetchUserData(String userId) { return CompletableFuture.supplyAsync(() -\u0026gt; { // HTTP call implementation try { return restTemplate.getForObject(\u0026#34;/api/users/\u0026#34; + userId, UserData.class); } catch (Exception e) { throw new RuntimeException(\u0026#34;Failed to fetch user data\u0026#34;, e); } }, executor); } } Performance \u0026amp; Lessons Learned Performance Comparison: JavaScript Promise: Single-threaded event loop, excellent cho I/O operations Java CompletableFuture: Multi-threaded, tốt cho CPU-intensive tasks Best Practices: JavaScript:\nLuôn dùng async/await thay vì .then() chains Dùng Promise.all() cho parallel operations Handle errors với try/catch Avoid creating unnecessary Promises Java:\nSử dụng custom ExecutorService Handle exceptions với exceptionally() hoặc handle() Dùng thenCombine() cho parallel operations Remember to shutdown ExecutorService Kết luận Cả Promise và CompletableFuture đều là tools mạnh mẽ cho async programming:\nPromise: Đơn giản hơn, syntax clean với async/await CompletableFuture: Mạnh mẽ hơn, control tốt hơn threading Quan trọng là hiểu concept async programming, sau đó syntax chỉ là matter of practice!\nCác bạn đã dùng async programming chưa? Share kinh nghiệm ở comment nhé!\nAsync is the future! ⚡🚀\n","permalink":"http://localhost:1313/blog/promise-vs-completablefuture/intex/","tags":["javascript","java","async","promise","completablefuture"],"title":"Async Programming: Promise (JS) vs CompletableFuture (Java) - Battle of Asynchronous!"},{"categories":["Backend Development"],"contents":"Xin chào các bạn! Sau khi học cả Java và JavaScript, mình có cơ hội làm việc với cả Spring Boot và Node.js trong các dự án thực tế. Hôm nay mình muốn chia sẻ trải nghiệm của mình khi develop backend với hai platform này.\nDự án đầu tiên với Spring Boot 🍃 Setup ban đầu Khi mới bắt đầu với Spring Boot, mình cảm thấy hơi choáng với số lượng config:\n// Application.java @SpringBootApplication public class BlogApplication { public static void main(String[] args) { SpringApplication.run(BlogApplication.class, args); } } // User.java - JPA Entity @Entity @Table(name = \u0026#34;users\u0026#34;) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, unique = true) private String email; @Column(nullable = false) private String password; // Constructor, getters, setters... } // UserRepository.java @Repository public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt; { Optional\u0026lt;User\u0026gt; findByEmail(String email); } // UserController.java @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) public class UserController { @Autowired private UserService userService; @PostMapping public ResponseEntity\u0026lt;User\u0026gt; createUser(@Valid @RequestBody UserDTO userDTO) { User user = userService.createUser(userDTO); return ResponseEntity.status(HttpStatus.CREATED).body(user); } } Những điều mình thích ở Spring Boot: Convention over Configuration - Ít config hơn Spring truyền thống Dependency Injection - Auto-wiring cực kỳ mạnh mẽ JPA/Hibernate - ORM mạnh mẽ, query phức tạp dễ dàng Security - Spring Security handle authentication/authorization tốt Testing - Test infrastructure rất complete Những khó khăn: Learning curve - Cần hiểu về Spring ecosystem Memory usage - JVM khá \u0026ldquo;nặng\u0026rdquo; Startup time - Khởi động chậm hơn Node.js Annotation hell - Quá nhiều annotation có thể confusing Chuyển sang Node.js - Một thế giới khác 🚀 Express.js setup // app.js const express = require(\u0026#34;express\u0026#34;); const mongoose = require(\u0026#34;mongoose\u0026#34;); const bcrypt = require(\u0026#34;bcryptjs\u0026#34;); const jwt = require(\u0026#34;jsonwebtoken\u0026#34;); const app = express(); app.use(express.json()); // User Model với Mongoose const userSchema = new mongoose.Schema({ email: { type: String, required: true, unique: true }, password: { type: String, required: true }, createdAt: { type: Date, default: Date.now }, }); const User = mongoose.model(\u0026#34;User\u0026#34;, userSchema); // User Routes app.post(\u0026#34;/api/users\u0026#34;, async (req, res) =\u0026gt; { try { const { email, password } = req.body; const existingUser = await User.findOne({ email }); if (existingUser) { return res.status(400).json({ message: \u0026#34;User already exists\u0026#34; }); } const hashedPassword = await bcrypt.hash(password, 10); const user = new User({ email, password: hashedPassword }); await user.save(); res.status(201).json({ id: user._id, email: user.email }); } catch (error) { res.status(500).json({ message: error.message }); } }); // Connect to MongoDB mongoose .connect(\u0026#34;mongodb://localhost:27017/myapp\u0026#34;) .then(() =\u0026gt; console.log(\u0026#34;Connected to MongoDB\u0026#34;)) .catch((err) =\u0026gt; console.error(\u0026#34;MongoDB connection error:\u0026#34;, err)); app.listen(3000, () =\u0026gt; { console.log(\u0026#34;Server running on port 3000\u0026#34;); }); Những điều mình thích ở Node.js: Fast development - Viết code nhanh, setup đơn giản JavaScript everywhere - Same language frontend/backend NPM ecosystem - Package có sẵn cho mọi thứ Lightweight - Memory footprint nhỏ hơn JVM Fast startup - Server khởi động trong giây lát Những thách thức: Callback/Promise hell - Nếu không handle tốt async code Single-threaded - CPU-intensive tasks có thể block Type safety - JavaScript dynamic typing đôi khi gây bugs Package management - Dependency hell với npm So sánh thực tế qua dự án Dự án E-commerce Platform Mình đã implement cùng một API cho hệ thống e-commerce với cả hai technologies:\nPerformance Test Results: Concurrent Users: 1000\rTest Duration: 5 minutes\rSpring Boot (Java 17 + PostgreSQL):\r- Average Response Time: 45ms\r- Throughput: 2,200 req/sec\r- Memory Usage: 512MB\r- CPU Usage: 35%\rNode.js (Express + MongoDB):\r- Average Response Time: 38ms\r- Throughput: 2,800 req/sec\r- Memory Usage: 128MB\r- CPU Usage: 28% Development Speed: Spring Boot:\nSetup time: 30 phút (config database, dependencies) CRUD operations: 2 giờ Authentication: 1 giờ (Spring Security) Unit tests: 1.5 giờ Total: ~5 giờ Node.js:\nSetup time: 10 phút CRUD operations: 1 giờ Authentication: 1.5 giờ (custom JWT) Unit tests: 1 giờ Total: ~3.5 giờ Khi nào dùng gì? Chọn Spring Boot khi: ✅ Enterprise applications - Cần security, scalability cao\n✅ Complex business logic - Nhiều rules phức tạp\n✅ Team lớn - Structure rõ ràng, maintainable\n✅ Legacy systems - Integration với Java ecosystem\n✅ Microservices - Spring Cloud ecosystem mạnh\n// Example: Complex business logic dễ handle với Java @Service @Transactional public class OrderService { public Order processOrder(OrderRequest request) { // Validate inventory inventoryService.checkAvailability(request.getItems()); // Apply discounts BigDecimal finalAmount = pricingService .calculateDiscount(request, customer.getTier()); // Process payment PaymentResult payment = paymentService .processPayment(customer.getPaymentMethod(), finalAmount); if (payment.isSuccessful()) { // Create order Order order = orderRepository.save( Order.builder() .customerId(customer.getId()) .amount(finalAmount) .status(OrderStatus.CONFIRMED) .build() ); // Send notifications notificationService.sendOrderConfirmation(order); return order; } throw new PaymentProcessingException(\u0026#34;Payment failed\u0026#34;); } } Chọn Node.js khi: ✅ Rapid prototyping - Cần develop nhanh\n✅ Real-time apps - Chat, live updates (Socket.io)\n✅ API-first approach - RESTful APIs đơn giản\n✅ Startup/Small team - Ít developers, cần flexibility\n✅ I/O intensive - Nhiều database calls, external APIs\n// Example: Real-time chat với Socket.io const io = require(\u0026#34;socket.io\u0026#34;)(server); io.on(\u0026#34;connection\u0026#34;, (socket) =\u0026gt; { console.log(\u0026#34;User connected:\u0026#34;, socket.id); socket.on(\u0026#34;join-room\u0026#34;, (roomId) =\u0026gt; { socket.join(roomId); socket.to(roomId).emit(\u0026#34;user-joined\u0026#34;, socket.id); }); socket.on(\u0026#34;message\u0026#34;, async (data) =\u0026gt; { // Save to database const message = await Message.create({ content: data.message, userId: data.userId, roomId: data.roomId, }); // Broadcast to room io.to(data.roomId).emit(\u0026#34;new-message\u0026#34;, message); }); socket.on(\u0026#34;disconnect\u0026#34;, () =\u0026gt; { console.log(\u0026#34;User disconnected:\u0026#34;, socket.id); }); }); Lessons Learned 1. Không có \u0026ldquo;silver bullet\u0026rdquo; Cả hai đều có ưu nhược điểm. Quan trọng là chọn tool phù hợp với requirements.\n2. Team skill matter Team giỏi Java → Spring Boot sẽ productive hơn Team frontend developers → Node.js dễ tiếp cận hơn 3. Maintenance is key Spring Boot có structure rõ ràng hơn cho long-term projects.\n4. Performance isn\u0026rsquo;t everything Developer productivity và time-to-market cũng quan trọng.\nKết luận Sau kinh nghiệm với cả hai, mình nhận ra:\nSpring Boot giống như một chiếc Mercedes - robust, reliable, powerful nhưng cần thời gian để master.\nNode.js giống như một chiếc motorbike - agile, fast, flexible nhưng cần cẩn thận khi handle complex scenarios.\nHiện tại mình đang sử dụng:\nSpring Boot cho enterprise projects, complex business logic Node.js cho prototypes, real-time features, simple APIs Các bạn có kinh nghiệm gì với hai platform này? Share ở comment nhé!\nChoose the right tool for the job! 🛠️\n","permalink":"http://localhost:1313/blog/springboot-vs-nodejs/","tags":["java","javascript","spring-boot","nodejs","backend"],"title":"Spring Boot vs Node.js: Trải nghiệm backend development của mình"},{"categories":["JavaScript"],"contents":"Chào mọi người! Khi mới học JavaScript, mình chỉ biết đến cú pháp cũ ES5. Nhưng khi tiếp xúc với ES6+ (ES2015 trở lên), thật sự mình cảm thấy như được \u0026ldquo;khai sáng\u0026rdquo;. Hôm nay mình muốn chia sẻ những tính năng ES6+ đã thay đổi hoàn toàn cách mình viết JavaScript.\n1. Let \u0026amp; Const - Tạm biệt var nhé! Cách cũ với var: // Vấn đề với var function oldWay() { for (var i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; { console.log(i); // In ra 3, 3, 3 (WTF???) }, 100); } console.log(i); // 3 - i vẫn tồn tại ngoài loop! } Cách mới với let \u0026amp; const: function newWay() { for (let i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; { console.log(i); // In ra 0, 1, 2 (chính xác!) }, 100); } // console.log(i); // ReferenceError - i không tồn tại ở đây const API_URL = \u0026#34;https://api.example.com\u0026#34;; // API_URL = \u0026#39;other-url\u0026#39;; // TypeError - không thể reassign const } Bài học: Luôn dùng const cho giá trị không thay đổi, let cho biến có thể thay đổi. Quên var đi!\n2. Arrow Functions - Code ngắn gọn hơn ES5 way: // Function expression cũ var users = [\u0026#34;Nam\u0026#34;, \u0026#34;Linh\u0026#34;, \u0026#34;Hoa\u0026#34;]; var uppercaseUsers = users.map(function (user) { return user.toUpperCase(); }); var button = document.getElementById(\u0026#34;btn\u0026#34;); button.addEventListener(\u0026#34;click\u0026#34;, function () { console.log(this); // \u0026#39;this\u0026#39; trỏ đến button }); ES6 way: // Arrow function - clean và concise const users = [\u0026#34;Nam\u0026#34;, \u0026#34;Linh\u0026#34;, \u0026#34;Hoa\u0026#34;]; const uppercaseUsers = users.map((user) =\u0026gt; user.toUpperCase()); // Với multiple parameters const add = (a, b) =\u0026gt; a + b; // Với function body const processUser = (user) =\u0026gt; { const processed = user.trim().toUpperCase(); return `Hello, ${processed}!`; }; // Lưu ý về \u0026#39;this\u0026#39; binding const obj = { name: \u0026#34;MyObject\u0026#34;, regularFunction() { console.log(this.name); // \u0026#39;MyObject\u0026#39; const arrowFunction = () =\u0026gt; { console.log(this.name); // \u0026#39;MyObject\u0026#39; - inherit từ parent scope }; arrowFunction(); }, }; Tip: Arrow function không có this binding riêng, nó inherit từ parent scope.\n3. Template Literals - Goodbye string concatenation! Cách cũ: var name = \u0026#34;Nam\u0026#34;; var age = 20; var city = \u0026#34;Ho Chi Minh\u0026#34;; var introduction = \u0026#34;Xin chào, tôi là \u0026#34; + name + \u0026#34;, \u0026#34; + age + \u0026#34; tuổi, \u0026#34; + \u0026#34;đến từ \u0026#34; + city + \u0026#34;.\u0026#34;; var htmlTemplate = \u0026#39;\u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt;\u0026#39; + \u0026#34;\u0026lt;h2\u0026gt;\u0026#34; + name + \u0026#34;\u0026lt;/h2\u0026gt;\u0026#34; + \u0026#34;\u0026lt;p\u0026gt;Age: \u0026#34; + age + \u0026#34;\u0026lt;/p\u0026gt;\u0026#34; + \u0026#34;\u0026lt;/div\u0026gt;\u0026#34;; Cách mới: const name = \u0026#34;Nam\u0026#34;; const age = 20; const city = \u0026#34;Ho Chi Minh\u0026#34;; // Template literals với backticks const introduction = `Xin chào, tôi là ${name}, ${age} tuổi, đến từ ${city}.`; // Multi-line strings dễ dàng const htmlTemplate = ` \u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;${name}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Age: ${age}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Status: ${age \u0026gt;= 18 ? \u0026#34;Adult\u0026#34; : \u0026#34;Minor\u0026#34;}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `; // Tagged template literals (advanced) function highlight(strings, ...values) { return strings.reduce((result, string, i) =\u0026gt; { const value = values[i] ? `\u0026lt;mark\u0026gt;${values[i]}\u0026lt;/mark\u0026gt;` : \u0026#34;\u0026#34;; return result + string + value; }, \u0026#34;\u0026#34;); } const highlighted = highlight`Tôi tên là ${name} và ${age} tuổi.`; 4. Destructuring - Unpack dữ liệu như ninja Array Destructuring: // Cách cũ var numbers = [1, 2, 3, 4, 5]; var first = numbers[0]; var second = numbers[1]; var rest = numbers.slice(2); // Cách mới const [first, second, ...rest] = [1, 2, 3, 4, 5]; console.log(first); // 1 console.log(second); // 2 console.log(rest); // [3, 4, 5] // Skip elements const [a, , c] = [1, 2, 3]; console.log(a, c); // 1, 3 // Default values const [x = 0, y = 0] = [1]; // x = 1, y = 0 Object Destructuring: // Cách cũ var user = { name: \u0026#34;Nam\u0026#34;, age: 20, email: \u0026#34;nam@example.com\u0026#34;, address: { city: \u0026#34;Ho Chi Minh\u0026#34;, district: \u0026#34;District 1\u0026#34;, }, }; var name = user.name; var age = user.age; var email = user.email; // Cách mới const { name, age, email } = user; // Rename variables const { name: userName, age: userAge } = user; // Nested destructuring const { address: { city, district }, } = user; // Default values const { phone = \u0026#34;N/A\u0026#34; } = user; // Function parameters destructuring function greetUser({ name, age = \u0026#34;unknown\u0026#34; }) { return `Hello ${name}, you are ${age} years old`; } greetUser({ name: \u0026#34;Nam\u0026#34;, age: 20 }); 5. Spread \u0026amp; Rest Operators - Ba chấm ma thuật Spread Operator (\u0026hellip;): // Array spreading const arr1 = [1, 2, 3]; const arr2 = [4, 5, 6]; const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6] // Object spreading const user = { name: \u0026#34;Nam\u0026#34;, age: 20 }; const updatedUser = { ...user, age: 21, city: \u0026#34;HCM\u0026#34; }; // { name: \u0026#39;Nam\u0026#39;, age: 21, city: \u0026#39;HCM\u0026#39; } // Function arguments function sum(a, b, c) { return a + b + c; } const numbers = [1, 2, 3]; console.log(sum(...numbers)); // 6 Rest Operator (\u0026hellip;): // Function parameters function logAll(first, ...others) { console.log(\u0026#34;First:\u0026#34;, first); console.log(\u0026#34;Others:\u0026#34;, others); } logAll(1, 2, 3, 4, 5); // First: 1, Others: [2, 3, 4, 5] // Array destructuring (đã thấy ở trên) const [head, ...tail] = [1, 2, 3, 4, 5]; 6. Enhanced Object Literals const name = \u0026#34;Nam\u0026#34;; const age = 20; // Cách cũ var user = { name: name, age: age, greet: function () { return \u0026#34;Hello!\u0026#34;; }, }; // Cách mới - shorthand properties const user = { name, // tương đương name: name age, // tương đương age: age // Method shorthand greet() { return \u0026#34;Hello!\u0026#34;; }, // Computed property names [`full${name}`]: `${name} Nguyen`, // Dynamic property [getPropertyName()]: \u0026#34;dynamic value\u0026#34;, }; 7. Promises \u0026amp; Async/Await - Tạm biệt Callback Hell Callback Hell: // Cách cũ - callback hell fetchUser(userId, function (user) { fetchUserPosts(user.id, function (posts) { fetchPostComments(posts[0].id, function (comments) { // Nested callbacks - khó đọc và maintain console.log(comments); }); }); }); Promises: // Promise chain fetchUser(userId) .then((user) =\u0026gt; fetchUserPosts(user.id)) .then((posts) =\u0026gt; fetchPostComments(posts[0].id)) .then((comments) =\u0026gt; console.log(comments)) .catch((error) =\u0026gt; console.error(error)); Async/Await: // Async/await - code như synchronous async function getUserData(userId) { try { const user = await fetchUser(userId); const posts = await fetchUserPosts(user.id); const comments = await fetchPostComments(posts[0].id); return comments; } catch (error) { console.error(\u0026#34;Error:\u0026#34;, error); throw error; } } // Sử dụng getUserData(123).then((data) =\u0026gt; console.log(data)); Kết luận ES6+ đã thực sự thay đổi cách mình viết JavaScript:\nCode ngắn gọn và dễ đọc hơn Ít bugs hơn nhờ let/const Xử lý async code dễ dàng hơn Destructuring giúp unpack data elegantly Tips cho người mới: Học từ từ - Đừng cố gắng học tất cả một lúc Practice daily - Viết code ES6+ mỗi ngày Use Babel - Để support browser cũ Read MDN docs - Tài liệu chính thức luôn tốt nhất Các bạn đã dùng feature nào trong số này chưa? Feature nào khiến các bạn ấn tượng nhất? Share ở comment nhé!\nModern JavaScript is beautiful! 🚀✨\n","permalink":"http://localhost:1313/blog/javascript-es6+/","tags":["javascript","es6","modern-js","kinh-nghiem"],"title":"JavaScript ES6+: Những tính năng đã thay đổi cách mình code"},{"categories":null,"contents":"","permalink":"http://localhost:1313/blog/design-patterns/","tags":null,"title":""},{"categories":null,"contents":"Xin chào! Tôi là Tiết Thanh Minh Hiếu 👋 Câu chuyện của tôi Tôi là một sinh viên đang theo đuổi ước mơ trở thành chuyên viên An Ninh Mạng, với niềm đam mê bảo vệ thế giới số khỏi những mối đe dọa ngày càng phức tạp. Nhưng điều đặc biệt là tôi không chỉ muốn \u0026ldquo;làm\u0026rdquo; mà còn muốn \u0026ldquo;truyền cảm hứng\u0026rdquo; - mục tiêu của tôi là trở thành một giảng viên Security, người có thể biến những kiến thức phức tạp thành những bài học dễ hiểu và thú vị.\nTại sao tôi tạo blog này? Ban đầu, blog này được tạo ra để hoàn thành yêu cầu môn học về Java \u0026amp; JavaScript. Nhưng tôi nhận ra đây chính là cơ hội tuyệt vời để bắt đầu hành trình chia sẻ kiến thức mà tôi đã ấp ủ từ lâu.\nTôi tin rằng: Cách học tốt nhất là dạy lại cho người khác. Mỗi bài viết tôi chia sẻ không chỉ giúp các bạn đọc mà còn giúp tôi củng cố và mở rộng kiến thức của chính mình.\nNhững gì tôi đang làm 🔍 An Ninh Mạng Hiện tại tôi đang xây dựng nền tảng vững chắc với các chứng chỉ từ Google Cybersecurity và IBM. Kiến thức mạng cơ bản đã giúp tôi hiểu được \u0026ldquo;bức tranh lớn\u0026rdquo; của bảo mật.\n🤖 AI \u0026amp; Machine Learning Tôi có kinh nghiệm training model, đặc biệt là BERT. Dự án gần nhất của tôi là \u0026ldquo;Phát hiện mã độc Android bằng Transformer Networks (BERT)\u0026rdquo; - một project thú vị kết hợp giữa AI và Cybersecurity.\n💻 Lập trình Java và JavaScript là những ngôn ngữ tôi đang tập trung, nhưng hành trình coding của tôi không dừng lại ở đó!\nĐiều gì khiến blog này khác biệt? Không chỉ là lý thuyết khô khan. Tôi sẽ chia sẻ:\n✨ Kinh nghiệm thực tế từ các project đã làm 🎯 Cách tiếp cận thực tế thay vì chỉ đọc sách vở 🔧 Tips \u0026amp; tricks mà tôi học được qua quá trình \u0026ldquo;vấp ngã\u0026rdquo; 📚 Kiến thức được \u0026ldquo;dịch\u0026rdquo; sang ngôn ngữ dễ hiểu Mục tiêu của tôi là biến những khái niệm phức tạp thành những câu chuyện thú vị mà bất kỳ ai cũng có thể hiểu được.\nTầm nhìn tương lai Tôi mơ ước một ngày nào đó sẽ đứng trên bục giảng, truyền cảm hứng cho thế hệ các chuyên gia bảo mật tương lai. Blog này chính là bước đầu tiên trong hành trình rèn luyện kỹ năng truyền đạt của tôi.\nMỗi bài viết là một bài giảng nhỏ, mỗi chia sẻ là một lần thực hành để tôi có thể diễn đạt tốt hơn, rõ ràng hơn.\nLời kết Nếu bạn là người:\n🎓 Đang học về Cybersecurity, Java, JavaScript hoặc AI 🔍 Muốn hiểu cách áp dụng kiến thức vào thực tế 💡 Thích học thông qua kinh nghiệm thực tế hơn là lý thuyết suông Thì blog này dành cho bạn! Tôi hy vọng những chia sẻ của mình sẽ giúp ích cho hành trình học tập của các bạn, đồng thời cũng giúp tôi trở thành một người truyền đạt giỏi hơn.\nHãy cùng học, cùng phát triển và cùng tạo nên một cộng đồng tech Việt Nam mạnh mẽ! 🚀\n\u0026ldquo;The best way to learn is to teach others\u0026rdquo; - và đó chính là triết lý tôi theo đuổi trong mỗi bài viết.\n","permalink":"http://localhost:1313/about/","tags":null,"title":"Giới thiệu"},{"categories":null,"contents":"Trong lập trình mạng bằng Java, Socket là công cụ giúp kết nối giữa client và server.\nBằng cách sử dụng java.net.Socket và java.net.ServerSocket, ta có thể xây dựng các ứng dụng chat, truyền file hoặc HTTP server đơn giản.\nMô hình Client-Server cơ bản trong lập trình Socket Ở mức thấp hơn, kết nối TCP được thiết lập qua quá trình bắt tay 3 bước (TCP Handshake).\nĐiều này đảm bảo client và server đồng bộ trạng thái trước khi truyền dữ liệu.\nCơ chế bắt tay 3 bước TCP (Three-Way Handshake) ","permalink":"http://localhost:1313/blog/java-socket/","tags":["Java","Networking"],"title":"Kết nối Socket trong Java"},{"categories":["Programming"],"contents":"Chào các bạn! Hôm nay mình muốn chia sẻ về hành trình học lập trình của mình, từ Java đến JavaScript. Có lẽ nhiều bạn cũng đang băn khoăn giống mình: nên bắt đầu với ngôn ngữ nào? Học Java trước hay JavaScript trước?\nKhởi đầu với Java - Nền tảng vững chắc Mình bắt đầu với Java từ năm nhất đại học. Thật sự lúc đầu khá choáng với cú pháp dài dòng của Java:\npublic class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Hello, World!\u0026#34;); } } So với \u0026ldquo;Hello World\u0026rdquo; của JavaScript:\nconsole.log(\u0026#34;Hello, World!\u0026#34;); Wow, khác biệt quá phải không? Nhưng qua thời gian, mình nhận ra Java đã dạy mình những điều quan trọng:\n1. Tư duy hướng đối tượng (OOP) Java buộc mình phải hiểu về Class, Object, Inheritance\u0026hellip; Lúc đầu khó hiểu lắm, nhưng sau này khi làm dự án lớn mới thấy tầm quan trọng của nó.\n2. Tính nghiêm ngặt về kiểu dữ liệu int number = 10; // Phải khai báo kiểu rõ ràng String text = \u0026#34;Hello\u0026#34;; // Không thể gán số vào String 3. Cấu trúc dự án rõ ràng Package, import, access modifier\u0026hellip; tất cả đều có quy tắc rõ ràng.\nChuyển sang JavaScript - Tự do nhưng cần kỷ luật Khi bắt đầu học JavaScript, mình cảm thấy như được \u0026ldquo;giải phóng\u0026rdquo;:\nlet data = 10; // Kiểu number data = \u0026#34;Hello\u0026#34;; // Giờ thành string data = [1, 2, 3]; // Giờ thành array data = { name: \u0026#34;John\u0026#34; }; // Giờ thành object Tự do quá! Nhưng cũng dễ rối loạn không kém.\nNhững khác biệt chính mình nhận ra: Java:\nCompiled language (biên dịch trước) Strongly typed (kiểu dữ liệu nghiêm ngặt) Platform independent (chạy trên JVM) Chủ yếu cho backend JavaScript:\nInterpreted language (thông dịch) Dynamically typed (kiểu dữ liệu linh hoạt) Chạy trên browser/Node.js Full-stack (cả frontend và backend) Bài học rút ra 1. Java là nền tảng tốt để bắt đầu Nếu bạn chưa biết gì về lập trình, mình khuyên nên bắt đầu với Java. Tại sao?\nBuộc bạn phải viết code chuẩn Hiểu rõ về cấu trúc dữ liệu Tư duy logic tốt hơn 2. JavaScript cần kỷ luật bản thân Vì quá linh hoạt, JavaScript dễ làm cho code trở nên lộn xộn. Mình học được:\nĐặt tên biến có ý nghĩa Sử dụng const/let thay vì var Comment code đầy đủ 3. Cả hai đều có giá trị Java: Tốt cho hệ thống lớn, enterprise applications JavaScript: Linh hoạt, phát triển nhanh, cộng đồng active Lời kết Hành trình từ Java đến JavaScript đã dạy mình rằng không có ngôn ngữ nào là \u0026ldquo;tốt nhất\u0026rdquo;. Mỗi ngôn ngữ đều có ưu nhược điểm riêng. Quan trọng là hiểu rõ bản chất và áp dụng đúng context.\nCác bạn có kinh nghiệm gì thú vị khi học hai ngôn ngữ này không? Hãy chia sẻ trong comment nhé!\nHappy coding! 🚀\n","permalink":"http://localhost:1313/blog/java-to-javascript/","tags":["java","javascript","kinh-nghiem","hoc-tap"],"title":"Từ Java đến JavaScript: Hành trình học lập trình của mình"},{"categories":["Java"],"contents":"Xin chào các bạn! Hôm nay mình muốn chia sẻ về những sai lầm \u0026ldquo;kinh điển\u0026rdquo; mà hầu như ai học Java cũng mắc phải, bao gồm cả mình. Hy vọng qua bài viết này, các bạn newbie sẽ tránh được những \u0026ldquo;hố đen\u0026rdquo; mà mình đã rơi vào.\nSai lầm #1: Lạm dụng public static void main Mình từng làm thế này: public class Calculator { public static void main(String[] args) { // Viết tất cả logic trong main int a = 10, b = 5; int sum = a + b; int diff = a - b; int product = a * b; int quotient = a / b; System.out.println(\u0026#34;Sum: \u0026#34; + sum); System.out.println(\u0026#34;Difference: \u0026#34; + diff); // ... và còn 50 dòng code nữa } } Vấn đề: Code không thể tái sử dụng Khó debug và maintain Không theo nguyên tắc OOP Cách khắc phục: public class Calculator { public int add(int a, int b) { return a + b; } public int subtract(int a, int b) { return a - b; } public static void main(String[] args) { Calculator calc = new Calculator(); System.out.println(\u0026#34;Sum: \u0026#34; + calc.add(10, 5)); System.out.println(\u0026#34;Difference: \u0026#34; + calc.subtract(10, 5)); } } Sai lầm #2: Không hiểu về Reference vs Value Mình từng nghĩ: public class Student { String name; public static void main(String[] args) { Student s1 = new Student(); s1.name = \u0026#34;Nam\u0026#34;; Student s2 = s1; // Mình tưởng s2 là bản copy của s1 s2.name = \u0026#34;Linh\u0026#34;; System.out.println(s1.name); // Tại sao lại in ra \u0026#34;Linh\u0026#34;??? } } Bài học: Trong Java, object được truyền theo reference, không phải value. Khi gán s2 = s1, cả hai đều trỏ đến cùng một object trong memory.\nGiải pháp: public class Student implements Cloneable { String name; public Student(String name) { this.name = name; } // Constructor copy public Student(Student other) { this.name = other.name; } public static void main(String[] args) { Student s1 = new Student(\u0026#34;Nam\u0026#34;); Student s2 = new Student(s1); // Tạo object mới s2.name = \u0026#34;Linh\u0026#34;; System.out.println(s1.name); // \u0026#34;Nam\u0026#34; System.out.println(s2.name); // \u0026#34;Linh\u0026#34; } } Sai lầm #3: Không xử lý Exception đúng cách Code \u0026ldquo;tệ\u0026rdquo; của mình: public void readFile(String fileName) { try { FileReader file = new FileReader(fileName); BufferedReader reader = new BufferedReader(file); String line = reader.readLine(); System.out.println(line); } catch (Exception e) { // Im lặng, không làm gì cả - RỐT THẬM TỆ! } } Vấn đề: \u0026ldquo;Nuốt\u0026rdquo; exception mà không xử lý Sử dụng Exception quá general Không đóng resource Cách đúng: public void readFile(String fileName) { try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) { String line = reader.readLine(); if (line != null) { System.out.println(line); } } catch (FileNotFoundException e) { System.err.println(\u0026#34;Không tìm thấy file: \u0026#34; + fileName); // Log hoặc throw lại exception } catch (IOException e) { System.err.println(\u0026#34;Lỗi đọc file: \u0026#34; + e.getMessage()); } } Sai lầm #4: So sánh String bằng == Code sai: public class StringComparison { public static void main(String[] args) { String s1 = \u0026#34;Hello\u0026#34;; String s2 = new String(\u0026#34;Hello\u0026#34;); if (s1 == s2) { // SAAAIIII! System.out.println(\u0026#34;Equal\u0026#34;); } else { System.out.println(\u0026#34;Not equal\u0026#34;); // Sẽ in ra này } } } Giải thích: == so sánh reference, không phải content s1 trỏ đến String Pool s2 trỏ đến object mới trong heap Cách đúng: public class StringComparison { public static void main(String[] args) { String s1 = \u0026#34;Hello\u0026#34;; String s2 = new String(\u0026#34;Hello\u0026#34;); if (s1.equals(s2)) { // So sánh content System.out.println(\u0026#34;Equal\u0026#34;); } // Hoặc an toàn hơn với null check if (Objects.equals(s1, s2)) { System.out.println(\u0026#34;Equal and null-safe\u0026#34;); } } } Sai lầm #5: Không hiểu về Access Modifier Code của mình lúc trước: public class BankAccount { public double balance; // Ai cũng có thể truy cập! public BankAccount(double initialBalance) { balance = initialBalance; } } // Ở nơi khác BankAccount account = new BankAccount(1000); account.balance = -500; // Oops! Balance âm??? Vấn đề: Dữ liệu quan trọng không được bảo vệ Vi phạm nguyên tắc Encapsulation Cách khắc phục: public class BankAccount { private double balance; // Chỉ class này truy cập được public BankAccount(double initialBalance) { if (initialBalance \u0026gt;= 0) { this.balance = initialBalance; } else { throw new IllegalArgumentException(\u0026#34;Balance không thể âm\u0026#34;); } } public double getBalance() { return balance; } public void deposit(double amount) { if (amount \u0026gt; 0) { balance += amount; } } public boolean withdraw(double amount) { if (amount \u0026gt; 0 \u0026amp;\u0026amp; amount \u0026lt;= balance) { balance -= amount; return true; } return false; } } Tổng kết Những sai lầm này đã giúp mình hiểu sâu hơn về Java. Đừng sợ mắc lỗi, quan trọng là học hỏi từ chúng!\nTips để tránh sai lầm: Practice coding every day - Luyện tập thường xuyên Read other people\u0026rsquo;s code - Đọc code của người khác Use IDE effectively - Tận dụng IDE để catch lỗi sớm Code review - Nhờ bạn bè review code Read documentation - Đọc docs chính thức của Java Các bạn đã mắc phải sai lầm nào trong danh sách này chưa? Hoặc có sai lầm nào khác muốn chia sẻ? Comment bên dưới nhé!\nKeep learning, keep coding! ☕\n","permalink":"http://localhost:1313/blog/5-wrong-errors/","tags":["java","sai-lam","kinh-nghiem","hoc-tap"],"title":"5 Sai lầm phổ biến khi học Java mà mình đã mắc phải"},{"categories":["Async Programming"],"contents":"Chào các bạn! Async programming là một trong những concepts khó nhất khi học lập trình. Mình đã struggle với nó khá lâu, từ callback hell của JavaScript đến thread complexity của Java. Hôm nay mình muốn chia sẻ cách hai ngôn ngữ này handle async operations - JavaScript với Promise và Java với CompletableFuture.\nCâu chuyện bắt đầu từ Synchronous Hell JavaScript - Callback Hell // Cách xưa - callback nightmare! function getUserData(userId, callback) { fetchUser(userId, (user) =\u0026gt; { if (user) { fetchUserProfile(user.id, (profile) =\u0026gt; { if (profile) { fetchUserPosts(user.id, (posts) =\u0026gt; { if (posts) { fetchPostComments(posts[0].id, (comments) =\u0026gt; { // 4 levels deep! Pyramid of doom 😱 callback({ user, profile, posts, comments }); }); } else { callback(null, \u0026#34;No posts found\u0026#34;); } }); } else { callback(null, \u0026#34;Profile not found\u0026#34;); } }); } else { callback(null, \u0026#34;User not found\u0026#34;); } }); } Java - Thread Complexity // Cách xưa với Thread public void getUserDataOldWay(String userId) { new Thread(() -\u0026gt; { try { User user = fetchUser(userId); if (user != null) { new Thread(() -\u0026gt; { try { Profile profile = fetchUserProfile(user.getId()); if (profile != null) { // Nested threads everywhere! 😫 // Error handling nightmare // No easy way to combine results } } catch (Exception e) { // Handle error } }).start(); } } catch (Exception e) { // Handle error } }).start(); } JavaScript Promise - Giải cứu từ Callback Hell Promise Basics // Tạo Promise đơn giản function fetchUser(userId) { return new Promise((resolve, reject) =\u0026gt; { // Simulate API call setTimeout(() =\u0026gt; { if (userId \u0026gt; 0) { resolve({ id: userId, name: `User ${userId}` }); } else { reject(new Error(\u0026#34;Invalid user ID\u0026#34;)); } }, 1000); }); } // Sử dụng Promise fetchUser(123) .then((user) =\u0026gt; { console.log(\u0026#34;User:\u0026#34;, user); return user; // Pass data to next .then() }) .then((user) =\u0026gt; { // Chain another async operation return fetchUserProfile(user.id); }) .then((profile) =\u0026gt; { console.log(\u0026#34;Profile:\u0026#34;, profile); }) .catch((error) =\u0026gt; { console.error(\u0026#34;Error:\u0026#34;, error); }) .finally(() =\u0026gt; { console.log(\u0026#34;Cleanup code here\u0026#34;); }); Promise.all() - Chạy song song // Thay vì chạy tuần tự async function getUserDataSequential(userId) { const user = await fetchUser(userId); // 1s const profile = await fetchUserProfile(userId); // 1s const posts = await fetchUserPosts(userId); // 1s // Total: 3s return { user, profile, posts }; } // Chạy song song với Promise.all() async function getUserDataParallel(userId) { const [user, profile, posts] = await Promise.all([ fetchUser(userId), // All run in parallel fetchUserProfile(userId), // Total: 1s (longest operation) fetchUserPosts(userId), ]); return { user, profile, posts }; } // Promise.allSettled() - Không fail nếu 1 promise reject async function getUserDataSafe(userId) { const results = await Promise.allSettled([ fetchUser(userId), fetchUserProfile(userId), fetchUserPosts(userId), ]); return results.map((result) =\u0026gt; { if (result.status === \u0026#34;fulfilled\u0026#34;) { return result.value; } else { console.error(\u0026#34;Failed:\u0026#34;, result.reason); return null; } }); } Async/Await - Promise syntax đường // Từ Promise chain function getUserData(userId) { return fetchUser(userId) .then((user) =\u0026gt; fetchUserProfile(user.id)) .then((profile) =\u0026gt; fetchUserPosts(profile.userId)) .then((posts) =\u0026gt; ({ user, profile, posts })) .catch((error) =\u0026gt; { console.error(\u0026#34;Error:\u0026#34;, error); throw error; }); } // Đến async/await - clean hơn nhiều! async function getUserData(userId) { try { const user = await fetchUser(userId); const profile = await fetchUserProfile(user.id); const posts = await fetchUserPosts(profile.userId); return { user, profile, posts }; } catch (error) { console.error(\u0026#34;Error:\u0026#34;, error); throw error; } } Java CompletableFuture - Modern Async Java CompletableFuture Basics import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class AsyncService { private ExecutorService executor = Executors.newFixedThreadPool(10); // Tạo CompletableFuture đơn giản public CompletableFuture\u0026lt;User\u0026gt; fetchUser(String userId) { return CompletableFuture.supplyAsync(() -\u0026gt; { // Simulate delay try { Thread.sleep(1000); if (Integer.parseInt(userId) \u0026gt; 0) { return new User(userId, \u0026#34;User \u0026#34; + userId); } else { throw new RuntimeException(\u0026#34;Invalid user ID\u0026#34;); } } catch (InterruptedException e) { throw new RuntimeException(e); } }, executor); } // Chain operations public CompletableFuture\u0026lt;UserData\u0026gt; getUserData(String userId) { return fetchUser(userId) .thenCompose(user -\u0026gt; fetchUserProfile(user.getId()) .thenApply(profile -\u0026gt; new UserData(user, profile)) ) .thenCompose(userData -\u0026gt; fetchUserPosts(userData.getUser().getId()) .thenApply(posts -\u0026gt; { userData.setPosts(posts); return userData; }) ) .exceptionally(throwable -\u0026gt; { System.err.println(\u0026#34;Error: \u0026#34; + throwable.getMessage()); return null; }); } } Parallel Execution với CompletableFuture public CompletableFuture\u0026lt;UserData\u0026gt; getUserDataParallel(String userId) { CompletableFuture\u0026lt;User\u0026gt; userFuture = fetchUser(userId); CompletableFuture\u0026lt;Profile\u0026gt; profileFuture = fetchUserProfile(userId); CompletableFuture\u0026lt;List\u0026lt;Post\u0026gt;\u0026gt; postsFuture = fetchUserPosts(userId); // Combine all results return userFuture.thenCombine(profileFuture, (user, profile) -\u0026gt; new UserData(user, profile) ).thenCombine(postsFuture, (userData, posts) -\u0026gt; { userData.setPosts(posts); return userData; }); } // allOf() - giống Promise.all() public CompletableFuture\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; fetchMultipleUsers(List\u0026lt;String\u0026gt; userIds) { List\u0026lt;CompletableFuture\u0026lt;User\u0026gt;\u0026gt; futures = userIds.stream() .map(this::fetchUser) .collect(Collectors.toList()); CompletableFuture\u0026lt;Void\u0026gt; allFutures = CompletableFuture.allOf( futures.toArray(new CompletableFuture[0]) ); return allFutures.thenApply(v -\u0026gt; futures.stream() .map(CompletableFuture::join) // Get results .map(User::getName) .collect(Collectors.toList()) ); } So sánh trực tiếp Promise vs CompletableFuture 1. Tạo async operation JavaScript:\nconst promise = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(\u0026#34;Done!\u0026#34;), 1000); }); // Hoặc với async function const asyncFunction = async () =\u0026gt; { return \u0026#34;Done!\u0026#34;; }; Java:\nCompletableFuture\u0026lt;String\u0026gt; future = CompletableFuture.supplyAsync(() -\u0026gt; { try { Thread.sleep(1000); } catch (InterruptedException e) {} return \u0026#34;Done!\u0026#34;; }); // Hoặc completed future CompletableFuture\u0026lt;String\u0026gt; completedFuture = CompletableFuture.completedFuture(\u0026#34;Done!\u0026#34;); 2. Chain operations JavaScript:\npromise .then((result) =\u0026gt; result.toUpperCase()) .then((upper) =\u0026gt; upper + \u0026#34; - FINISHED\u0026#34;) .catch((error) =\u0026gt; \u0026#34;Error: \u0026#34; + error); Java:\nfuture .thenApply(result -\u0026gt; result.toUpperCase()) .thenApply(upper -\u0026gt; upper + \u0026#34; - FINISHED\u0026#34;) .exceptionally(error -\u0026gt; \u0026#34;Error: \u0026#34; + error.getMessage()); 3. Combine multiple operations JavaScript:\nPromise.all([promise1, promise2, promise3]).then( ([result1, result2, result3]) =\u0026gt; { return { result1, result2, result3 }; } ); Java:\nfuture1.thenCombine(future2, (r1, r2) -\u0026gt; new Pair(r1, r2)) .thenCombine(future3, (pair, r3) -\u0026gt; new Result(pair.getFirst(), pair.getSecond(), r3) ); // Hoặc với allOf CompletableFuture.allOf(future1, future2, future3) .thenApply(v -\u0026gt; new Result( future1.join(), future2.join(), future3.join() )); Real-world Example: API Gateway JavaScript Implementation: class APIGateway { async handleRequest(request) { try { // Authenticate user const user = await this.authenticate(request.token); // Fetch data in parallel const [userData, permissions, preferences] = await Promise.all([ this.fetchUserData(user.id), this.fetchUserPermissions(user.id), this.fetchUserPreferences(user.id), ]); // Transform data const response = await this.transformResponse({ user: userData, permissions, preferences, }); return response; } catch (error) { return this.handleError(error); } } async fetchUserData(userId) { const response = await fetch(`/api/users/${userId}`); if (!response.ok) { throw new Error(`HTTP ${response.status}`); } return response.json(); } } Java Implementation: @Service public class APIGateway { private final ExecutorService executor = Executors.newFixedThreadPool(20); public CompletableFuture\u0026lt;APIResponse\u0026gt; handleRequest(APIRequest request) { return authenticate(request.getToken()) .thenCompose(user -\u0026gt; { // Fetch data in parallel CompletableFuture\u0026lt;UserData\u0026gt; userDataFuture = fetchUserData(user.getId()); CompletableFuture\u0026lt;List\u0026lt;Permission\u0026gt;\u0026gt; permissionsFuture = fetchUserPermissions(user.getId()); CompletableFuture\u0026lt;Preferences\u0026gt; preferencesFuture = fetchUserPreferences(user.getId()); return userDataFuture.thenCombine(permissionsFuture, (userData, permissions) -\u0026gt; new Pair\u0026lt;\u0026gt;(userData, permissions)) .thenCombine(preferencesFuture, (pair, preferences) -\u0026gt; new RequestData(pair.getFirst(), pair.getSecond(), preferences) ); }) .thenCompose(this::transformResponse) .exceptionally(this::handleError); } private CompletableFuture\u0026lt;UserData\u0026gt; fetchUserData(String userId) { return CompletableFuture.supplyAsync(() -\u0026gt; { // HTTP call implementation try { return restTemplate.getForObject(\u0026#34;/api/users/\u0026#34; + userId, UserData.class); } catch (Exception e) { throw new RuntimeException(\u0026#34;Failed to fetch user data\u0026#34;, e); } }, executor); } } Performance \u0026amp; Lessons Learned Performance Comparison: JavaScript Promise: Single-threaded event loop, excellent cho I/O operations Java CompletableFuture: Multi-threaded, tốt cho CPU-intensive tasks Best Practices: JavaScript:\nLuôn dùng async/await thay vì .then() chains Dùng Promise.all() cho parallel operations Handle errors với try/catch Avoid creating unnecessary Promises Java:\nSử dụng custom ExecutorService Handle exceptions với exceptionally() hoặc handle() Dùng thenCombine() cho parallel operations Remember to shutdown ExecutorService Kết luận Cả Promise và CompletableFuture đều là tools mạnh mẽ cho async programming:\nPromise: Đơn giản hơn, syntax clean với async/await CompletableFuture: Mạnh mẽ hơn, control tốt hơn threading Quan trọng là hiểu concept async programming, sau đó syntax chỉ là matter of practice!\nCác bạn đã dùng async programming chưa? Share kinh nghiệm ở comment nhé!\nAsync is the future! ⚡🚀\n","permalink":"http://localhost:1313/blog/promise-vs-completablefuture/intex/","tags":["javascript","java","async","promise","completablefuture"],"title":"Async Programming: Promise (JS) vs CompletableFuture (Java) - Battle of Asynchronous!"},{"categories":["Backend Development"],"contents":"Xin chào các bạn! Sau khi học cả Java và JavaScript, mình có cơ hội làm việc với cả Spring Boot và Node.js trong các dự án thực tế. Hôm nay mình muốn chia sẻ trải nghiệm của mình khi develop backend với hai platform này.\nDự án đầu tiên với Spring Boot 🍃 Setup ban đầu Khi mới bắt đầu với Spring Boot, mình cảm thấy hơi choáng với số lượng config:\n// Application.java @SpringBootApplication public class BlogApplication { public static void main(String[] args) { SpringApplication.run(BlogApplication.class, args); } } // User.java - JPA Entity @Entity @Table(name = \u0026#34;users\u0026#34;) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, unique = true) private String email; @Column(nullable = false) private String password; // Constructor, getters, setters... } // UserRepository.java @Repository public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt; { Optional\u0026lt;User\u0026gt; findByEmail(String email); } // UserController.java @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) public class UserController { @Autowired private UserService userService; @PostMapping public ResponseEntity\u0026lt;User\u0026gt; createUser(@Valid @RequestBody UserDTO userDTO) { User user = userService.createUser(userDTO); return ResponseEntity.status(HttpStatus.CREATED).body(user); } } Những điều mình thích ở Spring Boot: Convention over Configuration - Ít config hơn Spring truyền thống Dependency Injection - Auto-wiring cực kỳ mạnh mẽ JPA/Hibernate - ORM mạnh mẽ, query phức tạp dễ dàng Security - Spring Security handle authentication/authorization tốt Testing - Test infrastructure rất complete Những khó khăn: Learning curve - Cần hiểu về Spring ecosystem Memory usage - JVM khá \u0026ldquo;nặng\u0026rdquo; Startup time - Khởi động chậm hơn Node.js Annotation hell - Quá nhiều annotation có thể confusing Chuyển sang Node.js - Một thế giới khác 🚀 Express.js setup // app.js const express = require(\u0026#34;express\u0026#34;); const mongoose = require(\u0026#34;mongoose\u0026#34;); const bcrypt = require(\u0026#34;bcryptjs\u0026#34;); const jwt = require(\u0026#34;jsonwebtoken\u0026#34;); const app = express(); app.use(express.json()); // User Model với Mongoose const userSchema = new mongoose.Schema({ email: { type: String, required: true, unique: true }, password: { type: String, required: true }, createdAt: { type: Date, default: Date.now }, }); const User = mongoose.model(\u0026#34;User\u0026#34;, userSchema); // User Routes app.post(\u0026#34;/api/users\u0026#34;, async (req, res) =\u0026gt; { try { const { email, password } = req.body; const existingUser = await User.findOne({ email }); if (existingUser) { return res.status(400).json({ message: \u0026#34;User already exists\u0026#34; }); } const hashedPassword = await bcrypt.hash(password, 10); const user = new User({ email, password: hashedPassword }); await user.save(); res.status(201).json({ id: user._id, email: user.email }); } catch (error) { res.status(500).json({ message: error.message }); } }); // Connect to MongoDB mongoose .connect(\u0026#34;mongodb://localhost:27017/myapp\u0026#34;) .then(() =\u0026gt; console.log(\u0026#34;Connected to MongoDB\u0026#34;)) .catch((err) =\u0026gt; console.error(\u0026#34;MongoDB connection error:\u0026#34;, err)); app.listen(3000, () =\u0026gt; { console.log(\u0026#34;Server running on port 3000\u0026#34;); }); Những điều mình thích ở Node.js: Fast development - Viết code nhanh, setup đơn giản JavaScript everywhere - Same language frontend/backend NPM ecosystem - Package có sẵn cho mọi thứ Lightweight - Memory footprint nhỏ hơn JVM Fast startup - Server khởi động trong giây lát Những thách thức: Callback/Promise hell - Nếu không handle tốt async code Single-threaded - CPU-intensive tasks có thể block Type safety - JavaScript dynamic typing đôi khi gây bugs Package management - Dependency hell với npm So sánh thực tế qua dự án Dự án E-commerce Platform Mình đã implement cùng một API cho hệ thống e-commerce với cả hai technologies:\nPerformance Test Results: Concurrent Users: 1000\rTest Duration: 5 minutes\rSpring Boot (Java 17 + PostgreSQL):\r- Average Response Time: 45ms\r- Throughput: 2,200 req/sec\r- Memory Usage: 512MB\r- CPU Usage: 35%\rNode.js (Express + MongoDB):\r- Average Response Time: 38ms\r- Throughput: 2,800 req/sec\r- Memory Usage: 128MB\r- CPU Usage: 28% Development Speed: Spring Boot:\nSetup time: 30 phút (config database, dependencies) CRUD operations: 2 giờ Authentication: 1 giờ (Spring Security) Unit tests: 1.5 giờ Total: ~5 giờ Node.js:\nSetup time: 10 phút CRUD operations: 1 giờ Authentication: 1.5 giờ (custom JWT) Unit tests: 1 giờ Total: ~3.5 giờ Khi nào dùng gì? Chọn Spring Boot khi: ✅ Enterprise applications - Cần security, scalability cao\n✅ Complex business logic - Nhiều rules phức tạp\n✅ Team lớn - Structure rõ ràng, maintainable\n✅ Legacy systems - Integration với Java ecosystem\n✅ Microservices - Spring Cloud ecosystem mạnh\n// Example: Complex business logic dễ handle với Java @Service @Transactional public class OrderService { public Order processOrder(OrderRequest request) { // Validate inventory inventoryService.checkAvailability(request.getItems()); // Apply discounts BigDecimal finalAmount = pricingService .calculateDiscount(request, customer.getTier()); // Process payment PaymentResult payment = paymentService .processPayment(customer.getPaymentMethod(), finalAmount); if (payment.isSuccessful()) { // Create order Order order = orderRepository.save( Order.builder() .customerId(customer.getId()) .amount(finalAmount) .status(OrderStatus.CONFIRMED) .build() ); // Send notifications notificationService.sendOrderConfirmation(order); return order; } throw new PaymentProcessingException(\u0026#34;Payment failed\u0026#34;); } } Chọn Node.js khi: ✅ Rapid prototyping - Cần develop nhanh\n✅ Real-time apps - Chat, live updates (Socket.io)\n✅ API-first approach - RESTful APIs đơn giản\n✅ Startup/Small team - Ít developers, cần flexibility\n✅ I/O intensive - Nhiều database calls, external APIs\n// Example: Real-time chat với Socket.io const io = require(\u0026#34;socket.io\u0026#34;)(server); io.on(\u0026#34;connection\u0026#34;, (socket) =\u0026gt; { console.log(\u0026#34;User connected:\u0026#34;, socket.id); socket.on(\u0026#34;join-room\u0026#34;, (roomId) =\u0026gt; { socket.join(roomId); socket.to(roomId).emit(\u0026#34;user-joined\u0026#34;, socket.id); }); socket.on(\u0026#34;message\u0026#34;, async (data) =\u0026gt; { // Save to database const message = await Message.create({ content: data.message, userId: data.userId, roomId: data.roomId, }); // Broadcast to room io.to(data.roomId).emit(\u0026#34;new-message\u0026#34;, message); }); socket.on(\u0026#34;disconnect\u0026#34;, () =\u0026gt; { console.log(\u0026#34;User disconnected:\u0026#34;, socket.id); }); }); Lessons Learned 1. Không có \u0026ldquo;silver bullet\u0026rdquo; Cả hai đều có ưu nhược điểm. Quan trọng là chọn tool phù hợp với requirements.\n2. Team skill matter Team giỏi Java → Spring Boot sẽ productive hơn Team frontend developers → Node.js dễ tiếp cận hơn 3. Maintenance is key Spring Boot có structure rõ ràng hơn cho long-term projects.\n4. Performance isn\u0026rsquo;t everything Developer productivity và time-to-market cũng quan trọng.\nKết luận Sau kinh nghiệm với cả hai, mình nhận ra:\nSpring Boot giống như một chiếc Mercedes - robust, reliable, powerful nhưng cần thời gian để master.\nNode.js giống như một chiếc motorbike - agile, fast, flexible nhưng cần cẩn thận khi handle complex scenarios.\nHiện tại mình đang sử dụng:\nSpring Boot cho enterprise projects, complex business logic Node.js cho prototypes, real-time features, simple APIs Các bạn có kinh nghiệm gì với hai platform này? Share ở comment nhé!\nChoose the right tool for the job! 🛠️\n","permalink":"http://localhost:1313/blog/springboot-vs-nodejs/","tags":["java","javascript","spring-boot","nodejs","backend"],"title":"Spring Boot vs Node.js: Trải nghiệm backend development của mình"},{"categories":["JavaScript"],"contents":"Chào mọi người! Khi mới học JavaScript, mình chỉ biết đến cú pháp cũ ES5. Nhưng khi tiếp xúc với ES6+ (ES2015 trở lên), thật sự mình cảm thấy như được \u0026ldquo;khai sáng\u0026rdquo;. Hôm nay mình muốn chia sẻ những tính năng ES6+ đã thay đổi hoàn toàn cách mình viết JavaScript.\n1. Let \u0026amp; Const - Tạm biệt var nhé! Cách cũ với var: // Vấn đề với var function oldWay() { for (var i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; { console.log(i); // In ra 3, 3, 3 (WTF???) }, 100); } console.log(i); // 3 - i vẫn tồn tại ngoài loop! } Cách mới với let \u0026amp; const: function newWay() { for (let i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; { console.log(i); // In ra 0, 1, 2 (chính xác!) }, 100); } // console.log(i); // ReferenceError - i không tồn tại ở đây const API_URL = \u0026#34;https://api.example.com\u0026#34;; // API_URL = \u0026#39;other-url\u0026#39;; // TypeError - không thể reassign const } Bài học: Luôn dùng const cho giá trị không thay đổi, let cho biến có thể thay đổi. Quên var đi!\n2. Arrow Functions - Code ngắn gọn hơn ES5 way: // Function expression cũ var users = [\u0026#34;Nam\u0026#34;, \u0026#34;Linh\u0026#34;, \u0026#34;Hoa\u0026#34;]; var uppercaseUsers = users.map(function (user) { return user.toUpperCase(); }); var button = document.getElementById(\u0026#34;btn\u0026#34;); button.addEventListener(\u0026#34;click\u0026#34;, function () { console.log(this); // \u0026#39;this\u0026#39; trỏ đến button }); ES6 way: // Arrow function - clean và concise const users = [\u0026#34;Nam\u0026#34;, \u0026#34;Linh\u0026#34;, \u0026#34;Hoa\u0026#34;]; const uppercaseUsers = users.map((user) =\u0026gt; user.toUpperCase()); // Với multiple parameters const add = (a, b) =\u0026gt; a + b; // Với function body const processUser = (user) =\u0026gt; { const processed = user.trim().toUpperCase(); return `Hello, ${processed}!`; }; // Lưu ý về \u0026#39;this\u0026#39; binding const obj = { name: \u0026#34;MyObject\u0026#34;, regularFunction() { console.log(this.name); // \u0026#39;MyObject\u0026#39; const arrowFunction = () =\u0026gt; { console.log(this.name); // \u0026#39;MyObject\u0026#39; - inherit từ parent scope }; arrowFunction(); }, }; Tip: Arrow function không có this binding riêng, nó inherit từ parent scope.\n3. Template Literals - Goodbye string concatenation! Cách cũ: var name = \u0026#34;Nam\u0026#34;; var age = 20; var city = \u0026#34;Ho Chi Minh\u0026#34;; var introduction = \u0026#34;Xin chào, tôi là \u0026#34; + name + \u0026#34;, \u0026#34; + age + \u0026#34; tuổi, \u0026#34; + \u0026#34;đến từ \u0026#34; + city + \u0026#34;.\u0026#34;; var htmlTemplate = \u0026#39;\u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt;\u0026#39; + \u0026#34;\u0026lt;h2\u0026gt;\u0026#34; + name + \u0026#34;\u0026lt;/h2\u0026gt;\u0026#34; + \u0026#34;\u0026lt;p\u0026gt;Age: \u0026#34; + age + \u0026#34;\u0026lt;/p\u0026gt;\u0026#34; + \u0026#34;\u0026lt;/div\u0026gt;\u0026#34;; Cách mới: const name = \u0026#34;Nam\u0026#34;; const age = 20; const city = \u0026#34;Ho Chi Minh\u0026#34;; // Template literals với backticks const introduction = `Xin chào, tôi là ${name}, ${age} tuổi, đến từ ${city}.`; // Multi-line strings dễ dàng const htmlTemplate = ` \u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;${name}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Age: ${age}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Status: ${age \u0026gt;= 18 ? \u0026#34;Adult\u0026#34; : \u0026#34;Minor\u0026#34;}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `; // Tagged template literals (advanced) function highlight(strings, ...values) { return strings.reduce((result, string, i) =\u0026gt; { const value = values[i] ? `\u0026lt;mark\u0026gt;${values[i]}\u0026lt;/mark\u0026gt;` : \u0026#34;\u0026#34;; return result + string + value; }, \u0026#34;\u0026#34;); } const highlighted = highlight`Tôi tên là ${name} và ${age} tuổi.`; 4. Destructuring - Unpack dữ liệu như ninja Array Destructuring: // Cách cũ var numbers = [1, 2, 3, 4, 5]; var first = numbers[0]; var second = numbers[1]; var rest = numbers.slice(2); // Cách mới const [first, second, ...rest] = [1, 2, 3, 4, 5]; console.log(first); // 1 console.log(second); // 2 console.log(rest); // [3, 4, 5] // Skip elements const [a, , c] = [1, 2, 3]; console.log(a, c); // 1, 3 // Default values const [x = 0, y = 0] = [1]; // x = 1, y = 0 Object Destructuring: // Cách cũ var user = { name: \u0026#34;Nam\u0026#34;, age: 20, email: \u0026#34;nam@example.com\u0026#34;, address: { city: \u0026#34;Ho Chi Minh\u0026#34;, district: \u0026#34;District 1\u0026#34;, }, }; var name = user.name; var age = user.age; var email = user.email; // Cách mới const { name, age, email } = user; // Rename variables const { name: userName, age: userAge } = user; // Nested destructuring const { address: { city, district }, } = user; // Default values const { phone = \u0026#34;N/A\u0026#34; } = user; // Function parameters destructuring function greetUser({ name, age = \u0026#34;unknown\u0026#34; }) { return `Hello ${name}, you are ${age} years old`; } greetUser({ name: \u0026#34;Nam\u0026#34;, age: 20 }); 5. Spread \u0026amp; Rest Operators - Ba chấm ma thuật Spread Operator (\u0026hellip;): // Array spreading const arr1 = [1, 2, 3]; const arr2 = [4, 5, 6]; const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6] // Object spreading const user = { name: \u0026#34;Nam\u0026#34;, age: 20 }; const updatedUser = { ...user, age: 21, city: \u0026#34;HCM\u0026#34; }; // { name: \u0026#39;Nam\u0026#39;, age: 21, city: \u0026#39;HCM\u0026#39; } // Function arguments function sum(a, b, c) { return a + b + c; } const numbers = [1, 2, 3]; console.log(sum(...numbers)); // 6 Rest Operator (\u0026hellip;): // Function parameters function logAll(first, ...others) { console.log(\u0026#34;First:\u0026#34;, first); console.log(\u0026#34;Others:\u0026#34;, others); } logAll(1, 2, 3, 4, 5); // First: 1, Others: [2, 3, 4, 5] // Array destructuring (đã thấy ở trên) const [head, ...tail] = [1, 2, 3, 4, 5]; 6. Enhanced Object Literals const name = \u0026#34;Nam\u0026#34;; const age = 20; // Cách cũ var user = { name: name, age: age, greet: function () { return \u0026#34;Hello!\u0026#34;; }, }; // Cách mới - shorthand properties const user = { name, // tương đương name: name age, // tương đương age: age // Method shorthand greet() { return \u0026#34;Hello!\u0026#34;; }, // Computed property names [`full${name}`]: `${name} Nguyen`, // Dynamic property [getPropertyName()]: \u0026#34;dynamic value\u0026#34;, }; 7. Promises \u0026amp; Async/Await - Tạm biệt Callback Hell Callback Hell: // Cách cũ - callback hell fetchUser(userId, function (user) { fetchUserPosts(user.id, function (posts) { fetchPostComments(posts[0].id, function (comments) { // Nested callbacks - khó đọc và maintain console.log(comments); }); }); }); Promises: // Promise chain fetchUser(userId) .then((user) =\u0026gt; fetchUserPosts(user.id)) .then((posts) =\u0026gt; fetchPostComments(posts[0].id)) .then((comments) =\u0026gt; console.log(comments)) .catch((error) =\u0026gt; console.error(error)); Async/Await: // Async/await - code như synchronous async function getUserData(userId) { try { const user = await fetchUser(userId); const posts = await fetchUserPosts(user.id); const comments = await fetchPostComments(posts[0].id); return comments; } catch (error) { console.error(\u0026#34;Error:\u0026#34;, error); throw error; } } // Sử dụng getUserData(123).then((data) =\u0026gt; console.log(data)); Kết luận ES6+ đã thực sự thay đổi cách mình viết JavaScript:\nCode ngắn gọn và dễ đọc hơn Ít bugs hơn nhờ let/const Xử lý async code dễ dàng hơn Destructuring giúp unpack data elegantly Tips cho người mới: Học từ từ - Đừng cố gắng học tất cả một lúc Practice daily - Viết code ES6+ mỗi ngày Use Babel - Để support browser cũ Read MDN docs - Tài liệu chính thức luôn tốt nhất Các bạn đã dùng feature nào trong số này chưa? Feature nào khiến các bạn ấn tượng nhất? Share ở comment nhé!\nModern JavaScript is beautiful! 🚀✨\n","permalink":"http://localhost:1313/blog/javascript-es6+/","tags":["javascript","es6","modern-js","kinh-nghiem"],"title":"JavaScript ES6+: Những tính năng đã thay đổi cách mình code"}]